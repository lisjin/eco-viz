{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stable-stringify/index.js","node_modules/jsonify/index.js","node_modules/jsonify/lib/parse.js","node_modules/jsonify/lib/stringify.js","node_modules/tslib/tslib.js","node_modules/vega-parser/src/parsers/event-selector.js","node_modules/vega-parser/src/parsers/marks/marktypes.js","node_modules/vega-util/build/vega-util.js","package.json","src/aggregate.ts","src/axis.ts","src/bin.ts","src/channel.ts","src/compile/axis/encode.ts","src/compile/axis/parse.ts","src/compile/axis/rules.ts","src/compile/common.ts","src/compile/compile.ts","src/compile/data/bin.ts","src/compile/data/data.ts","src/compile/data/filter.ts","src/compile/data/formatparse.ts","src/compile/data/formula.ts","src/compile/data/nonpositivefilter.ts","src/compile/data/nullfilter.ts","src/compile/data/pathorder.ts","src/compile/data/source.ts","src/compile/data/stack.ts","src/compile/data/summary.ts","src/compile/data/timeunit.ts","src/compile/facet.ts","src/compile/layer.ts","src/compile/layout.ts","src/compile/legend/encode.ts","src/compile/legend/parse.ts","src/compile/legend/rules.ts","src/compile/mark/area.ts","src/compile/mark/bar.ts","src/compile/mark/init.ts","src/compile/mark/line.ts","src/compile/mark/mark.ts","src/compile/mark/mixins.ts","src/compile/mark/point.ts","src/compile/mark/rect.ts","src/compile/mark/rule.ts","src/compile/mark/text.ts","src/compile/mark/tick.ts","src/compile/mark/valueref.ts","src/compile/model.ts","src/compile/scale/domain.ts","src/compile/scale/init.ts","src/compile/scale/parse.ts","src/compile/scale/range.ts","src/compile/scale/rules.ts","src/compile/scale/type.ts","src/compile/selection/interval.ts","src/compile/selection/multi.ts","src/compile/selection/selection.ts","src/compile/selection/single.ts","src/compile/selection/transforms/inputs.ts","src/compile/selection/transforms/nearest.ts","src/compile/selection/transforms/project.ts","src/compile/selection/transforms/scales.ts","src/compile/selection/transforms/toggle.ts","src/compile/selection/transforms/transforms.ts","src/compile/selection/transforms/translate.ts","src/compile/selection/transforms/zoom.ts","src/compile/unit.ts","src/compositemark.ts","src/config.ts","src/data.ts","src/datetime.ts","src/encoding.ts","src/fielddef.ts","src/filter.ts","src/legend.ts","src/log.ts","src/mark.ts","src/scale.ts","src/selection.ts","src/sort.ts","src/spec.ts","src/stack.ts","src/timeunit.ts","src/type.ts","src/util.ts","src/validate.ts","src/vega.schema.ts","src/vl.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","json","JSON","obj","opts","cmp","space","Array","join","cycles","replacer","key","value","node","b","seen","stringify","parent","level","indent","colonSeparator","toJSON","undefined","_typeof","isArray","out","item","push","indexOf","TypeError","keys","objectKeys","sort","keyValue","splice","","x","toString","Object","has","prototype","hasOwnProperty","parse","at","ch","text","escapee","\"","\\","/","error","m","name","message","next","c","charAt","number","string","isFinite","hex","uffff","parseInt","String","fromCharCode","white","word","array","object","source","reviver","result","walk","holder","k","v","quote","escapable","lastIndex","test","replace","meta","charCodeAt","slice","str","partial","mind","gap","rep","apply","\b","\t","\n","\f","\r","__extends","__assign","__rest","__decorate","__param","__metadata","__awaiter","__generator","__exportStar","__values","__read","__spread","__asyncGenerator","__asyncDelegator","__asyncValues","factory","createExporter","previous","id","root","exporter","extendStatics","setPrototypeOf","__proto__","d","p","__","constructor","create","assign","arguments","getOwnPropertySymbols","decorators","target","desc","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","paramIndex","decorator","metadataKey","metadataValue","metadata","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","rejected","done","then","body","verb","op","_","y","label","ops","pop","trys","sent","throw","return","Symbol","iterator","ar","concat","q","resume","shift","settle","delegate","fulfill","asyncIterator","find","endChar","pushChar","popChar","count","parseMerge","output","start","LBRACK","RBRACK","substring","trim","parseSelector","parseBetween","parseStream","stream","map","between","j","filter","DEFAULT_SOURCE","throttle","markname","lastIndexOf","parseThrottle","ILLEGAL","type","_marktypes","isMarkType","marktype","consume","debounce","split","selector","VIEW","marktypes","_vegaUtil","ArcMark","AreaMark","GroupMark","ImageMark","LineMark","PathMark","RectMark","RuleMark","ShapeMark","SymbolMark","TextMark","toSet","vega","accessorName","fn","fname","accessorFields","fields","$","isObject","isString","log","method","input","args","console","accessor","splitAccessPath","path","field","_field","Function","empty","identity","zero","one","truthy","falsy","logger","_level","warn","info","debug","compare","orders","lt","gt","idx","ord","isFunction","constant","extend","len","extentIndex","NULL","fastmap","_test","size","get","set","delete","clear","clean","forEach","inherits","child","proto","isNumber","merge","array0","array1","n0","n1","merged","i0","i1","repeat","reps","pad","padchar","align","Math","ceil","peek","truncate","ellipsis","max","visitArray","visitor","None","Warn","Info","Debug","stringValue","author","version","collaborators","homepage","description","main","types","bin","vl2png","vl2svg","vl2vg","directories","scripts","prebuild","build","postbuild","build:images","build:toc","build:site","build:versions","build:test-gallery","checkschema","data","deploy","deploy:gh","deploy:schema","prestart","poststart","preschema","schema","presite","site","lint","test:nocompile","test:only","test:debug","mocha:test","mocha:examples","codecov","watch:build","watch:test","watch","x-compile","x-diff","repository","url","license","bugs","devDependencies","@types/chai","@types/d3","@types/highlight.js","@types/json-stable-stringify","@types/mocha","@types/node","ajv","babel-preset-es2015","babelify","browser-sync","browserify","browserify-shim","chai","cheerio","d3","exorcist","highlight.js","mocha","nodemon","nyc","source-map-support","tsify","tslint","tslint-eslint-rules","typescript","typescript-json-schema","uglify-js","vega-datasets","vega-embed","vega-parser","watchify","yaml-front-matter","dependencies","json-stable-stringify","tslib","vega-util","yargs","AGGREGATE_OPS","SUM_OPS","SHARED_DOMAIN_OPS","defaultAxisConfig","labelMaxLength","AXIS_PROPERTIES","VL_ONLY_AXIS_PROPERTIES","autoMaxBins","channel","channel_1","ROW","COLUMN","SIZE","SHAPE","supportMark","mark","getSupportedMark","X","Y","COLOR","DETAIL","ORDER","OPACITY","point","tick","rule","circle","square","bar","rect","line","area","X2","Y2","TEXT","hasScale","util_1","contains","supportScaleType","scaleType","POSITION_SCALE_TYPE_INDEX","rangeType","Channel","scale_1","CHANNELS","UNIT_CHANNELS","UNIT_SCALE_CHANNELS","SCALE_CHANNELS","NONSPATIAL_CHANNELS","NONSPATIAL_SCALE_CHANNELS","LEVEL_OF_DETAIL_CHANNELS","without","STACK_GROUP_CHANNELS","SCALE_TYPES","labels","model","labelsSpec","def","fieldDef","axis","config","type_1","NOMINAL","ORDINAL","signal","TEMPORAL","common_1","timeFormatExpression","timeUnit","format","shortTimeLabels","timeFormat","labelAngle","angle","orient","baseline","parseAxisComponent","axisChannels","reduce","vgAxes","parseMainAxis","isVisibleAxis","grid","parseGridAxis","isFalseOrNull","some","AXIS_PARTS","part","hasAxisPart","parseAxis","isGridAxis","vgAxis","scale","scaleName","axis_1","property","getSpecifiedOrDefaultValue","gridScale","encodeSpec","encode","update","specifiedAxis","rules","domain","ticks","tickCount","title","values","zindex","numberFormat","gridShow","hasDiscreteScale","gridChannel","INVALID_CHANNEL_FOR_AXIS","fieldTitle","fielddef_1","maxLength","titleMaxLength","vals","datetime_1","isDateTime","dt","timestamp","z","domainAndTicks","buildModel","spec","parentGivenName","spec_1","isFacetSpec","facet_1","FacetModel","isLayerSpec","layer_1","LayerModel","isUnitSpec","unit_1","UnitModel","INVALID_SPEC","applyConfig","propsList","applyMarkConfig","getMarkConfig","prop","markSpecificConfig","QUANTITATIVE","aggregate","timeFormatConfig","timeunit_1","formatExpression","sortParams","orderDef","orderChannelDef","binSuffix","order","compile","inputSpec","normalize","assemble","reset","$schema","topLevelBasicProperties","signals","selection_1","assembleTopLevelSignals","assembleData","assembleLayout","assembleSelectionData","marks","assembleRootGroup","padding","autosize","viewport","background","rootGroup","getName","from","data_1","LAYOUT","width","height","assembleParentGroupProperties","cell","assembleGroup","numberFormatExpr","expr","reduceFieldDef","binComponent","binTrans","as","transform","extent","extentSignal","maxbins","bin_1","discreteDomain","hasDiscreteDomain","legend","startField","datum","endField","hash","parseUnit","parseFacet","childDataComponent","component","parseLayer","children","flatten","parseUnitData","formatParse","formatparse_1","nullFilter","nullfilter_1","filter_1","nonPositiveFilter","nonpositivefilter_1","pathOrder","pathorder_1","source_1","calculate","formula_1","formula","summary","summary_1","stack","stack_1","parseFacetData","parseLayerData","dataComponent","sourceData","dataName","SOURCE","summaryData","nonPositiveFilterTransform","dataTable","stackData","pathOrderCollectTransform","expression","filterComponent","compatibleSource","calcFieldMap","fieldMap","parseComponent","val","isEqualFilter","equal","isRangeFilter","range","isOneOfFilter","oneOf","forEachFieldDef","isCount","isUrlData","parse_1","differ","formulaComponent","channels","nonPositiveComponent","ScaleType","LOG","nonPositiveFilterComponent","filterInvalid","aggregator","DEFAULT_NULL_FILTERS","nominal","ordinal","quantitative","temporal","nullFilterComponent","filters","_filters","encoding_1","sort_1","channelHasField","encoding","dimensionChannel","markDef","isSortField","isAggregate","pathOrderComponent","stringifiedPathOrder","_i","_a","_b","_c","isInlineData","defaultExtension","exec","dataFormat","formatType","feature","mesh","isNamedData","renameData","childData","getStackByFields","stackBy","by","stackProperties","groupby","groupbyChannel","stackby","STACKED","SUMMARY","fieldChannel","offset","impute","stackComponent","newName","facetedField","orderby","addDimension","dims","meas","dimensions","measures","summaryComponents","summaryComponent","summaryNameWithoutPrefix","substr","mergeMeasures","parentMeasures","childMeasures","field_1","summaries","childSummary","sourceName","fnDictSet","ops_1","timeUnitComponent","fieldExpr","hasSubPlotWithXy","hasDescendantWithFieldOnChannel","spacing","facetSpacing","getFacetGroupProperties","mergedCellConfig","facet","sizeName","assembleAxesGroupData","column","COLUMN_AXES_DATA_PREFIX","row","ROW_AXES_DATA_PREFIX","parseAxisGroups","axisGroup","getSharedAxisGroup","rules_1","axes","isX","facetChannel","hasFacet","dataPrefix","axesGroup","group","getRowGridGroups","facetGridConfig","x2","stroke","color","strokeOpacity","opacity","strokeWidth","getColumnGridGroups","y2","config_1","layout_1","model_1","init_1","parse_2","_super","_this","scales","legends","_spacing","initConfig","initFacet","initScalesAndSpacing","initAxis","tslib_1","specConfig","mergeDeep","duplicate","defaultConfig","emptyFieldDef","incompatibleChannel","_scale","default","_axis","axisSpec","vlOnlyAxisProperties_1","modelAxis","yAxis","hasSummary","facetedTable","parseData","parseSelection","parseLayoutData","layout","parseFacetLayout","parseScale","scaleComponent","scaleNameWithoutPrefix","renameScale","parseMark","parseAxisGroup","xAxisGroup","yAxisGroup","axisGroups","parseGridGroup","gridGroups","parseLegend","assembleSignals","layoutData","assembleMarks","getMapping","isFacet","Model","mark_1","vega_schema_1","data_2","domain_1","layer","parseLayerLayout","childScale","modelScale","isSignalRefDomain","unionDomains","axisComponent","legendComponent","cellConfig","FILL_STROKE_CONFIG","assembleScales","isLayer","layoutComponent","distinctFields","distinct","parseUnitLayout","parseUnitSizeLayout","getDistinct","channelSizeName","unitSizeExpr","rangeStep","cardinality","cardinalityExpr","paddingOuter","paddingInner","parseFacetSizeLayout","childLayoutComponent","sizeType","childSizeComponent","facetSizeFormula","innerSize","parseLayerSizeLayout","sizeType_1","distinctField","prefix","symbols","symbolsSpec","BAR","TICK","shape","CIRCLE","SQUARE","POINT","LINE","AREA","cfg","filled","colorDef","isValueDef","fill","shapeDef","parseLegendComponent","getLegendDefWithScale","legend_1","LEGEND_PROPERTIES","specifiedLegend","isBinScale","mixins","vgMark","role","encodeEntry","pointPosition","pointPosition2","nonPosition","markDefProperties","sizeDef","xDef","xScaleName","xScale","isFieldDef","binnedPosition","binSpacing","BAND","bandPosition","centeredBandPosition","ref","midX","defaultSizeRef","yDef","yScaleName","yScale","midY","discreteBandSize","band","continuousBandSize","BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL","initMarkDef","isMarkDef","specifiedOrient","orientOverridden","initEncoding","stacked","opacityConfig","defaultOpacity","hasRawField","channelDef","vega_util_1","filledConfig","RULE","RECT","yIsRange","xIsRange","xScaleType","yScaleType","xIsContinuous","isContinuous","yIsContinuous","xIsTemporal","yIsTemporal","unclearOrientContinuous","unclearOrientDiscreteOrEmpty","vgChannel","parsePathMark","parseNonPathMark","dataFrom","details","detailFields","pathMarks","markCompiler","area_1","bar_1","line_1","point_1","rect_1","rule_1","text_1","tick_1","defaultValue","util","props","valueIfDefined","opt","defaultRef","valueRef","midPoint","wrapCondition","condition","selection","selectionTest","selectionName","negate","predicate","sizeChannel","fieldRef","defaultPosRef","centerChannel","stackable","baseChannel","stackable2","fixedShape","shapeMixins","x2Def","scaleTypeNotWorkWithMark","y2Def","xDefault","textDef","textXRangeStep","defaultSize","scaleRangeStep","bandSize","vgSizeChannel","vgThicknessChannel","thickness","suffix","aFieldDef","a2fieldDef","side","binMidSignal","zeroOrMinX","zeroOrMinY","zeroOrMaxX","zeroOrMaxY","TIME","UTC","NameMap","nameMap","rename","oldName","dataNameMap","scaleNameMap","sizeNameMap","DEPRECATED_FILTER_NULL","assembleAxes","assembleLegends","init","acc","cd","isUnit","delimiter","dataSourceType","renameSize","originalScaleName","initDomain","scaleConfig","canUseUnaggregatedDomain","valid","reason","useUnaggregatedDomain","parseDomain","parseSingleChannelDomain","domainSort","isBoolean","aggregate_1","unaggregateDomainWithNonSharedDomainOp","unaggregatedDomainWithLogScale","unaggregateDomainHasNoEffectForRawField","normalizeDomain","isDataRefDomain","isFieldRefUnionDomain","isDataRefUnionedDomain","INVAID_DOMAIN","domain1","domain2","UNABLE_TO_MERGE_DOMAINS","normalizedDomain1","normalizedDomain2","domains","unique","allData","topLevelSize","xyRangeSteps","specifiedScale","NON_TYPE_RANGE_SCALE_PROPERTIES","specifiedValue","supportedByScaleType","scaleTypeSupportProperty","channelIncompatability","channelScalePropertyIncompatability","scalePropertyNotWorkWithScaleType","getValue","range_1","getDefaultValue","nice","round","parseScaleComponent","scaleComponentsIndex","scaleComponents","parseRange","NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES","reverse","scheme","isExtendedScheme","rangeMixins","specifiedRangeStepIsNull","RANGE_PROPERTIES_1","RANGE_PROPERTIES","stepSize","rangeStepDropped","sizeRangeMin","sizeRangeMax","defaultRange","minOpacity","maxOpacity","minBandSize","minStrokeWidth","minFontSize","minSize","maxBandSize","minXYRangeStep","maxStrokeWidth","maxFontSize","maxSize","pointStep","min","smallestUnit","pointPadding","bandPaddingInner","bandPaddingOuter","specifiedType","hasTopLevelSize","specifiedRangeStep","defaultScaleType","defaultType","cannotOverrideBinScaleType","scaleTypeNotWorkWithChannel","discreteToContinuousType","discreteChannelCannotEncode","isDiscreteByDefault","invalidFieldType","haveRangeStep","projections","selCmpt","project","channelSignal","channelSignalName","coord","invert","bind","on","scales_1","events","evt","cb","log_1","BRUSH","interval","intervals","translate","cs","tupleExpr","modifyExpr","tpl","TUPLE","enter","multi","proj","parseUnitSelection","selDefs","selCmpts","selectionConfig","name_1","selDef","encodings","event_selector_1","transforms_1","forEachTransform","txCompiler","assembleUnitSignals","forEachSelection","selCompiler","MODIFY","STORE","topLevelSignals","assembleUnitData","assembleUnitMarks","clippedGroup","selMarks","clip","store","PREDICATES_OPS","compiler","selections","name_2","sel","single_1","multi_1","interval_1","single","independent","union","union_others","intersect","intersect_others","inputBindings","unshift","nearest","index","isPathgroup","exists","cellDef","isVoronoi","projection","scaleBindings","bound","hasContinuousDomain","domainRaw","toggle","compilers","project_1","toggle_1","translate_1","zoom_1","inputs_1","nearest_1","zoom","inputs","getSign","onDelta","anchor","delta","DELTA","sign","lo","hi","base","sx","sy","force","sname","vlEncoding","mark_2","parse_3","init_2","providedWidth","providedHeight","dropInvalidFieldDefs","initScales","initAxes","initLegend","initSize","hasFacetParent","topLevelWidth","topLevelHeight","_legend","legendSpec","toSpec","excludeConfig","excludeData","add","normalizer","normalizerRegistry","remove","ERRORBAR","outerSpec","encodingWithoutSize","encodingWithoutX2Y2","encodingWithoutX_X2_Y_Y2","defaultCellConfig","defaultFacetCellConfig","defaultFacetGridConfig","defaultFacetConfig","defaultOverlayConfig","pointStyle","lineStyle","countTitle","defaultMarkConfig","defaultBarConfig","defaultTextConfig","defaultTickConfig","overlay","defaultScaleConfig","defaultLegendConfig","year","quarter","month","date","day","hours","minutes","seconds","milliseconds","normalizeQuarter","invalidTimeUnit","normalizeMonth","lowerM","toLowerCase","monthIndex","MONTHS","shortM","shortMonthIndex","SHORT_MONTHS","normalizeDay","lowerD","dayIndex","DAYS","shortD","shortDayIndex","SHORT_DAYS","Date","droppedDay","setFullYear","setDate","setMonth","setHours","setMinutes","setSeconds","setMilliseconds","getTime","dateTimeExpr","units","channelDefs","isRanged","fieldDefs","arr","mapping","r1","nofn","isDiscrete","toUpperCase","fullType","getFullName","newType","emptyOrInvalidFieldType","channelCompatibility","compatible","warning","facetChannelShouldBeDiscrete","COMPATIBLE","in","valueExpr","lower","upper","isSingleTimeUnit","datetime","runLocalLogger","current","LocalLogger","wrap","warns","infos","debugs","markOrFacet","when","original","actual","cannotUseScalePropertyWithNonColor","cannotUseRangePropertyWithFacet","propName","cannotStackRangedMark","cannotStackNonLinearScale","cannotStackNonSummativeAggregate","unitName","dayReplacedWithDate","fullTimeUnit","CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN","CANNOT_USE_RANGE_WITH_POSITION","CANNOT_USE_PADDING_WITH_FACET","isPrimitiveMark","PRIMITIVE_MARK_INDEX","Mark","PRIMITIVE_MARKS","STROKE_CONFIG","FILL_CONFIG","DISCRETE_DOMAIN_INDEX","BIN_SCALES_INDEX","CONTINUOUS_DOMAIN_INDEX","isContinuousToContinuous","CONTINUOUS_TO_CONTINUOUS_INDEX","LINEAR","BIN_LINEAR","POW","SQRT","SEQUENTIAL","QUANTILE","QUANTIZE","THRESHOLD","BIN_ORDINAL","CONTINUOUS_TO_CONTINUOUS_SCALES","CONTINUOUS_DOMAIN_SCALES","DISCRETE_DOMAIN_SCALES","TIME_SCALE_TYPES","shapes","SCALE_PROPERTIES","isFacetedUnitSpec","hasRow","hasColumn","normalizeFacet","normalizeLayer","normalizeFacetedUnit","normalizeNonFacetUnit","normalizeNonFacet","subspec","rest","isNonFacetUnitSpecWithPrimitiveMark","overlayConfig","overlayWithLine","overlayWithPoint","normalizeRangedUnit","normalizeOverlay","compositeMark","hasX","hasY","hasX2","hasY2","normalizedSpec","outerProps","baseSpec","omit","baseConfig","layerSpec","pick","lineSpec","markConfig","pointSpec","accumulate","dict","pureFieldDef","fieldDefIndex","isStacked","stackConfig","STACKABLE_MARKS","sc","hasXField","hasYField","xIsAggregate","fieldChannelAggregate","fieldChannelScale","stackOffset","STACK_BY_DEFAULT_MARKS","SINGLE_TIMEUNIT_INDEX","convert","unit","SINGLE_TIMEUNITS","singleUnit","containsTimeUnit","TimeUnit","DAY","YEAR","getFullYear","QUARTER","floor","getMonth","MONTH","DATE","getDate","HOURS","getHours","MINUTES","getMinutes","SECONDS","getSeconds","MILLISECONDS","getMilliseconds","isMultiTimeUnit","MULTI_TIMEUNIT_INDEX","func","_d","tu","dateComponents","hasYear","timeComponents","dateTimeComponents","YEARMONTH","YEARMONTHDATE","YEARMONTHDATEHOURS","YEARMONTHDATEHOURSMINUTES","YEARMONTHDATEHOURSMINUTESSECONDS","MONTHDATE","HOURSMINUTES","HOURSMINUTESSECONDS","MINUTESSECONDS","SECONDSMILLISECONDS","YEARQUARTER","QUARTERMONTH","YEARQUARTERMONTH","MULTI_TIMEUNITS","TIMEUNITS","Type","copy","vega_util_2","excludedItems","other","every","arrays","dest","src","src_1","deepMerge_","results","values_1","_vals","getEncodingMappingError","requiredChannelMap","supportedChannelMap","DEFAULT_REQUIRED_CHANNEL_MAP","DEFAULT_SUPPORTED_CHANNEL_TYPE","requiredChannels","supportedChannels","compile_1","validate"],"mappings":"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","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [0, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), q = [], c, i;\r\n        return i = { next: verb(\"next\"), \"throw\": verb(\"throw\"), \"return\": verb(\"return\") }, i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { return function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]), next(); }); }; }\r\n        function next() { if (!c && q.length) resume((c = q.shift())[0], c[1]); }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(c[3], e); } }\r\n        function step(r) { r.done ? settle(c[2], r) : r.value[0] === \"yield\" ? settle(c[2], { value: r.value[1], done: false }) : Promise.resolve(r.value[1]).then(r.value[0] === \"delegate\" ? delegate : fulfill, reject); }\r\n        function delegate(r) { step(r.done ? r : { value: [\"yield\", r.value], done: false }); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { c = void 0, f(v), next(); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i = { next: verb(\"next\"), \"throw\": verb(\"throw\", function (e) { throw e; }), \"return\": verb(\"return\", function (v) { return { value: v, done: true }; }) };\r\n        return o = __asyncValues(o), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { return function (v) { return { value: [\"delegate\", (o[n] || f).call(o, v)], done: false }; }; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator];\r\n        return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n});","import {isMarkType} from './marks/marktypes';\n\n/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\nexport default function(selector, source) {\n  DEFAULT_SOURCE = source || VIEW;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\n\nvar VIEW   = 'view',\n    LBRACK = '[',\n    RBRACK = ']',\n    LBRACE = '{',\n    RBRACE = '}',\n    COLON  = ':',\n    COMMA  = ',',\n    NAME   = '@',\n    GT     = '>';\n\nvar ILLEGAL = /[\\[\\]\\{\\}]/,\n    DEFAULT_SOURCE;\n\nfunction find(s, i, endChar, pushChar, popChar) {\n  var count = 0,\n      n = s.length,\n      c;\n  for (; i<n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;\n    else if (popChar && popChar.indexOf(c) >= 0) --count;\n    else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n  return i;\n}\n\nfunction parseMerge(s) {\n  var output = [],\n      start = 0,\n      n = s.length,\n      i = 0;\n\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n  return output;\n}\n\nfunction parseSelector(s) {\n  return s[0] === '['\n    ? parseBetween(s)\n    : parseStream(s);\n}\n\nfunction parseBetween(s) {\n  var start = 1,\n      n = s.length,\n      i = 1,\n      b, stream;\n\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n\n  b = parseMerge(s.substring(start, i));\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n\n  s = s.slice(i + 1).trim();\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n\n  b = b.map(parseSelector);\n\n  stream = parseSelector(s.slice(1).trim());\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n\n  return stream;\n}\n\nfunction parseStream(s) {\n  var stream = {source: DEFAULT_SOURCE},\n      source = [],\n      throttle = [0, 0],\n      markname = 0,\n      start = 0,\n      n = s.length,\n      i = 0, j,\n      filter;\n\n  // extract throttle from end\n  if (s[n-1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i+1, n-1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n    i = 0;\n  }\n\n  if (!n) throw s;\n\n  // set name flag based on first char\n  if (s[0] === NAME) markname = ++i;\n\n  // extract first part of multi-part stream selector\n  j = find(s, i, COLON);\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  }\n\n  // extract remaining part of stream selector\n  i = find(s, i, LBRACK);\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  }\n\n  // extract filters\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n-1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  }\n\n  // marshall event stream specification\n  if (!(n = source.length) || ILLEGAL.test(source[n-1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n\n  if (n > 1) {\n    stream.type = source[1];\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1)\n  }\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n\n  return stream;\n}\n\nfunction parseThrottle(s) {\n  var a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(function(_) {\n    var x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\n","import {toSet} from 'vega-util';\n\nexport var ArcMark = 'arc';\nexport var AreaMark = 'area';\nexport var GroupMark = 'group';\nexport var ImageMark = 'image';\nexport var LineMark = 'line';\nexport var PathMark = 'path';\nexport var RectMark = 'rect';\nexport var RuleMark = 'rule';\nexport var ShapeMark = 'shape';\nexport var SymbolMark = 'symbol';\nexport var TextMark = 'text';\n\nexport var marktypes = toSet([\n  '*',\n  'arc',\n  'area',\n  'group',\n  'image',\n  'line',\n  'path',\n  'rect',\n  'rule',\n  'shape',\n  'symbol',\n  'text'\n]);\n\nexport function isMarkType(type) {\n  return marktypes.hasOwnProperty(type);\n}\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.vega = global.vega || {})));\n}(this, (function (exports) { 'use strict';\n\nvar accessor = function(fn, fields, name) {\n  return (\n    fn.fields = fields || [],\n    fn.fname = name,\n    fn\n  );\n}\n\nfunction accessorName(fn) {\n  return fn == null ? null : fn.fname;\n}\n\nfunction accessorFields(fn) {\n  return fn == null ? null : fn.fields;\n}\n\nvar error = function(message) {\n  throw Error(message);\n}\n\nvar splitAccessPath = function(p) {\n  var path = [],\n      q = null,\n      b = 0,\n      n = p.length,\n      s = '',\n      i, j, c;\n\n  p = p + '';\n\n  function push() {\n    path.push(s + p.substring(i, j));\n    s = '';\n    i = j + 1;\n  }\n\n  for (i=j=0; j<n; ++j) {\n    c = p[j];\n    if (c === '\\\\') s += p.substring(i, j), i = ++j;\n    else if (c === q) push(), q = null, b = -1;\n    else if (q) continue;\n    else if (i === b && c === '\"') i = j + 1, q = c;\n    else if (i === b && c === \"'\") i = j + 1, q = c;\n    else if (c === '.' && !b) (j > i) ? push() : (i = j + 1);\n    else if (c === '[') {\n      if (j > i) push();\n      b = i = j + 1;\n    }\n    else if (c === ']') {\n      if (!b) error('Access path missing open bracket: ' + p);\n      if (b > 0) push();\n      b = 0;\n      i = j + 1;\n    }\n  }\n\n  if (b) error('Access path missing closing bracket: ' + p);\n  if (q) error('Access path missing closing quote: ' + p);\n  if (j > i) ++j, push();\n  return path;\n}\n\nvar isArray = Array.isArray;\n\nvar isObject = function(_) {\n  return _ === Object(_);\n}\n\nvar isString = function(_) {\n  return typeof _ === 'string';\n}\n\nfunction $(x) {\n  return isArray(x) ? '[' + x.map($) + ']'\n    : isObject(x) || isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n}\n\nvar field = function(field, name) {\n  var path = splitAccessPath(field),\n      code = 'return _[' + path.map($).join('][') + '];';\n\n  return accessor(\n    Function('_', code),\n    [(field = path.length===1 ? path[0] : field)],\n    name || field\n  );\n}\n\nvar empty = [];\n\nvar id = field('id');\n\nvar identity = accessor(function(_) { return _; }, empty, 'identity');\n\nvar zero = accessor(function() { return 0; }, empty, 'zero');\n\nvar one = accessor(function() { return 1; }, empty, 'one');\n\nvar truthy = accessor(function() { return true; }, empty, 'true');\n\nvar falsy = accessor(function() { return false; }, empty, 'false');\n\nfunction log(method, level, input) {\n  var args = [level].concat([].slice.call(input));\n  console[method].apply(console, args); // eslint-disable-line no-console\n}\n\nvar None  = 0;\nvar Warn  = 1;\nvar Info  = 2;\nvar Debug = 3;\n\nvar logger = function(_) {\n  var level = _ || None;\n  return {\n    level: function(_) {\n      return arguments.length ? (level = +_, this) : level;\n    },\n    warn: function() {\n      if (level >= Warn) log('warn', 'WARN', arguments);\n      return this;\n    },\n    info: function() {\n      if (level >= Info) log('log', 'INFO', arguments);\n      return this;\n    },\n    debug: function() {\n      if (level >= Debug) log('log', 'DEBUG', arguments);\n      return this;\n    }\n  }\n}\n\nvar array = function(_) {\n  return _ != null ? (isArray(_) ? _ : [_]) : [];\n}\n\nvar compare = function(fields, orders) {\n  var idx = [],\n      cmp = (fields = array(fields)).map(function(f, i) {\n        return f == null ? null\n          : (idx.push(i), splitAccessPath(f).map($).join(']['));\n      }),\n      n = idx.length - 1,\n      ord = array(orders),\n      code = 'var u,v;return ',\n      i, j, f, u, v, d, lt, gt;\n\n  if (n < 0) return null;\n\n  for (j=0; j<=n; ++j) {\n    i = idx[j];\n    f = cmp[i];\n    u = '(u=a['+f+'])';\n    v = '(v=b['+f+'])';\n    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';\n    lt = ord[i] !== 'descending' ? (gt=1, -1) : (gt=-1, 1);\n    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt\n      + ':(u>v||v==null)&&u!=null?' + gt\n      + ':'+d+'!==u&&v===v?' + lt\n      + ':v!==v&&u===u?' + gt\n      + (i < n ? ':' : ':0');\n  }\n\n  return accessor(\n    Function('a', 'b', code + ';'),\n    fields.filter(function(_) { return _ != null; })\n  );\n}\n\nvar isFunction = function(_) {\n  return typeof _ === 'function';\n}\n\nvar constant = function(_) {\n  return isFunction(_) ? _ : function() { return _; };\n}\n\nvar extend = function(_) {\n  for (var x, k, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (k in x) { _[k] = x[k]; }\n  }\n  return _;\n}\n\nvar extentIndex = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a, b, c, u, v;\n\n  if (f == null) {\n    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = array[i]) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  } else {\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = f(array[i], i, array)) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  }\n\n  return [u, v];\n}\n\nvar NULL = {};\n\nvar fastmap = function(input) {\n  var obj = {},\n      map,\n      test;\n\n  function has(key) {\n    return obj.hasOwnProperty(key) && obj[key] !== NULL;\n  }\n\n  map = {\n    size: 0,\n    empty: 0,\n    object: obj,\n    has: has,\n    get: function(key) {\n      return has(key) ? obj[key] : undefined;\n    },\n    set: function(key, value) {\n      if (!has(key)) {\n        ++map.size;\n        if (obj[key] === NULL) --map.empty;\n      }\n      obj[key] = value;\n      return this;\n    },\n    delete: function(key) {\n      if (has(key)) {\n        --map.size;\n        ++map.empty;\n        obj[key] = NULL;\n      }\n      return this;\n    },\n    clear: function() {\n      map.size = map.empty = 0;\n      map.object = obj = {};\n    },\n    test: function(_) {\n      return arguments.length ? (test = _, map) : test;\n    },\n    clean: function() {\n      var next = {},\n          size = 0,\n          key, value;\n      for (key in obj) {\n        value = obj[key];\n        if (value !== NULL && (!test || !test(value))) {\n          next[key] = value;\n          ++size;\n        }\n      }\n      map.size = size;\n      map.empty = 0;\n      map.object = (obj = next);\n    }\n  };\n\n  if (input) Object.keys(input).forEach(function(key) {\n    map.set(key, input[key]);\n  });\n\n  return map;\n}\n\nvar inherits = function(child, parent) {\n  var proto = (child.prototype = Object.create(parent.prototype));\n  proto.constructor = child;\n  return proto;\n}\n\nvar isNumber = function(_) {\n  return typeof _ === 'number';\n}\n\nvar key = function(fields) {\n  fields = fields ? array(fields) : fields;\n  var fn = !(fields && fields.length)\n    ? function() { return ''; }\n    : Function('_', 'return \\'\\'+' +\n        fields.map(function(f) {\n          return '_[' + splitAccessPath(f).map($).join('][') + ']';\n        }).join('+\\'|\\'+') + ';');\n  return accessor(fn, fields, 'key');\n}\n\nvar merge = function(compare, array0, array1, output) {\n  var n0 = array0.length,\n      n1 = array1.length;\n\n  if (!n1) return array0;\n  if (!n0) return array1;\n\n  var merged = output || new array0.constructor(n0 + n1),\n      i0 = 0, i1 = 0, i = 0;\n\n  for (; i0<n0 && i1<n1; ++i) {\n    merged[i] = compare(array0[i0], array1[i1]) > 0\n       ? array1[i1++]\n       : array0[i0++];\n  }\n\n  for (; i0<n0; ++i0, ++i) {\n    merged[i] = array0[i0];\n  }\n\n  for (; i1<n1; ++i1, ++i) {\n    merged[i] = array1[i1];\n  }\n\n  return merged;\n}\n\nvar repeat = function(str, reps) {\n  var s = '';\n  while (--reps >= 0) s += str;\n  return s;\n}\n\nvar pad = function(str, length, padchar, align) {\n  var c = padchar || ' ',\n      s = str + '',\n      n = length - s.length;\n\n  return n <= 0 ? s\n    : align === 'left' ? repeat(c, n) + s\n    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\n    : s + repeat(c, n);\n}\n\nvar peek = function(array) {\n  return array[array.length - 1];\n}\n\nvar toSet = function(_) {\n  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = 1;\n  return s;\n}\n\nvar truncate = function(str, length, align, ellipsis) {\n  var e = ellipsis != null ? ellipsis : '\\u2026',\n      s = str + '',\n      n = s.length,\n      l = Math.max(0, length - e.length);\n\n  return n <= length ? s\n    : align === 'left' ? e + s.slice(n - l)\n    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\n    : s.slice(0, l) + e;\n}\n\nvar visitArray = function(array, filter, visitor) {\n  if (array) {\n    var i = 0, n = array.length, t;\n    if (filter) {\n      for (; i<n; ++i) {\n        if (t = filter(array[i])) visitor(t, i, array);\n      }\n    } else {\n      array.forEach(visitor);\n    }\n  }\n}\n\nexports.accessor = accessor;\nexports.accessorName = accessorName;\nexports.accessorFields = accessorFields;\nexports.id = id;\nexports.identity = identity;\nexports.zero = zero;\nexports.one = one;\nexports.truthy = truthy;\nexports.falsy = falsy;\nexports.logger = logger;\nexports.None = None;\nexports.Warn = Warn;\nexports.Info = Info;\nexports.Debug = Debug;\nexports.array = array;\nexports.compare = compare;\nexports.constant = constant;\nexports.error = error;\nexports.extend = extend;\nexports.extentIndex = extentIndex;\nexports.fastmap = fastmap;\nexports.field = field;\nexports.inherits = inherits;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isNumber = isNumber;\nexports.isObject = isObject;\nexports.isString = isString;\nexports.key = key;\nexports.merge = merge;\nexports.pad = pad;\nexports.peek = peek;\nexports.repeat = repeat;\nexports.splitAccessPath = splitAccessPath;\nexports.stringValue = $;\nexports.toSet = toSet;\nexports.truncate = truncate;\nexports.visitArray = visitArray;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","module.exports={\n  \"name\": \"vega-lite\",\n  \"author\": \"Jeffrey Heer, Dominik Moritz, Kanit \\\"Ham\\\" Wongsuphasawat\",\n  \"version\": \"2.0.0-alpha.7\",\n  \"collaborators\": [\n    \"Kanit Wongsuphasawat <kanitw@gmail.com> (http://kanitw.yellowpigz.com)\",\n    \"Dominik Moritz <domoritz@cs.washington.edu> (https://www.domoritz.de)\",\n    \"Jeffrey Heer <jheer@uw.edu> (http://jheer.org)\"\n  ],\n  \"homepage\": \"https://vega.github.io/vega-lite/\",\n  \"description\": \"Vega-lite provides a higher-level grammar for visual analysis, comparable to ggplot or Tableau, that generates complete Vega specifications.\",\n  \"main\": \"build/src/vl.js\",\n  \"types\": \"build/src/vl.d.ts\",\n  \"bin\": {\n    \"vl2png\": \"./bin/vl2png\",\n    \"vl2svg\": \"./bin/vl2svg\",\n    \"vl2vg\": \"./bin/vl2vg\"\n  },\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"prebuild\": \"mkdir -p build/site build/examples/images build/test-gallery\",\n    \"build\": \"tsc && cp package.json build && browserify src/vl.ts -p tsify -g [ babelify ] -d -s vl | exorcist build/vega-lite.js.map > build/vega-lite.js\",\n    \"postbuild\": \"uglifyjs build/vega-lite.js -cm --in-source-map build/vega-lite.js.map --source-map build/vega-lite.min.js.map > build/vega-lite.min.js && npm run schema\",\n    \"build:images\": \"npm run data && scripts/generate-images.sh\",\n    \"build:toc\": \"bundle exec jekyll build -q && scripts/generate-toc\",\n    \"build:site\": \"browserify site/static/main.ts -p [tsify -p site] -d | exorcist build/site/main.js.map > build/site/main.js\",\n    \"build:versions\": \"scripts/update-version.sh\",\n    \"build:test-gallery\": \"browserify test-gallery/main.ts -p [tsify -p test-gallery] -d > build/test-gallery/main.js\",\n    \"checkschema\": \"scripts/check-schema.sh\",\n    \"clean\": \"rm -rf build && rm -f vega-lite.* & find -E src test site examples -regex '.*\\\\.(js|js.map|d.ts)' -delete & rm -rf examples/_diff examples/_original examples/_output examples/images && rm -rf data\",\n    \"data\": \"rsync -r node_modules/vega-datasets/data/* data\",\n\n    \"deploy\": \"scripts/deploy.sh\",\n    \"deploy:gh\": \"scripts/deploy-gh.sh\",\n    \"deploy:schema\": \"scripts/deploy-schema.sh\",\n\n    \"prestart\": \"npm run data && npm run build && scripts/index-examples\",\n    \"start\": \"nodemon -x 'npm run build:test-gallery' & browser-sync start --server --files 'build/test-gallery/main.js' --index 'test-gallery/index.html'\",\n    \"poststart\": \"rm examples/all-examples.json\",\n\n    \"preschema\": \"npm run prebuild\",\n    \"schema\": \"typescript-json-schema --required true --noExtraProps true src/spec.ts ExtendedSpec > build/vega-lite-schema.json\",\n\n    \"presite\": \"npm run build && npm run data && npm run build:site && npm run build:toc && npm run build:versions\",\n    \"site\": \"bundle exec jekyll serve\",\n\n    \"lint\": \"tslint -c tslint.json 'src/**/*.ts' 'test/**/*.ts'\",\n\n    \"test\": \"tsc && npm run schema && npm run data && npm run test:nocompile\",\n    \"test:nocompile\": \"npm run test:only && npm run lint && npm run mocha:examples\",\n    \"test:only\": \"nyc --reporter=html --reporter=text-summary npm run mocha:test\",\n    \"test:debug\": \"tsc && npm run schema && npm run data && mocha --recursive --require ./test/babel.ts --debug-brk build/test build/examples\",\n    \"mocha:test\": \"mocha --reporter dot --recursive build/test\",\n    \"mocha:examples\": \"mocha --require ./test/babel.ts --reporter dot --recursive build/examples\",\n\n    \"codecov\": \"nyc report --reporter=json && codecov -f coverage/*.json\",\n    \"watch:build\": \"watchify src/vl.ts -p tsify -g [ babelify ] -v -d -s vl -o 'exorcist build/vega-lite.js.map > build/vega-lite.js'\",\n    \"watch:test\": \"nodemon -x 'npm test'\",\n    \"watch\": \"nodemon -x 'npm run build && npm run test:nocompile' # already ran schema in build\",\n    \"x-compile\": \"./scripts/examples-compile.sh\",\n    \"x-diff\": \"./scripts/examples-diff.sh\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vega/vega-lite.git\"\n  },\n  \"license\": \"BSD-3-Clause\",\n  \"bugs\": {\n    \"url\": \"https://github.com/vega/vega-lite/issues\"\n  },\n  \"devDependencies\": {\n    \"@types/chai\": \"^3.4.35\",\n    \"@types/d3\": \"^4.6.0\",\n    \"@types/highlight.js\": \"^9.1.9\",\n    \"@types/json-stable-stringify\": \"^1.0.30\",\n    \"@types/mocha\": \"^2.2.39\",\n    \"@types/node\": \"^7.0.5\",\n    \"ajv\": \"5.0.1-beta.1\",\n    \"babel-preset-es2015\": \"^6.22.0\",\n    \"babelify\": \"^7.3.0\",\n    \"browser-sync\": \"~2.18.8\",\n    \"browserify\": \"~14.1.0\",\n    \"browserify-shim\": \"^3.8.13\",\n    \"chai\": \"~3.5.0\",\n    \"cheerio\": \"~0.22.0\",\n    \"codecov\": \"~1.0.1\",\n    \"d3\": \"^4.7.1\",\n    \"exorcist\": \"~0.4.0\",\n    \"highlight.js\": \"^9.9.0\",\n    \"mocha\": \"~3.2.0\",\n    \"nodemon\": \"~1.11.0\",\n    \"nyc\": \"~10.1.2\",\n    \"source-map-support\": \"~0.4.11\",\n    \"tsify\": \"~3.0.1\",\n    \"tslint\": \"~4.5.1\",\n    \"tslint-eslint-rules\": \"^3.4.0\",\n    \"typescript\": \"^2.2.1\",\n    \"typescript-json-schema\": \"^0.10.0\",\n    \"uglify-js\": \"~2.8.7\",\n    \"vega\": \"3.0.0-beta.25\",\n    \"vega-datasets\": \"vega/vega-datasets#gh-pages\",\n    \"vega-embed\": \"3.0.0-beta.5\",\n    \"vega-parser\": \"^1.0.0-beta.39\",\n    \"watchify\": \"~3.9.0\",\n    \"yaml-front-matter\": \"~3.4.0\"\n  },\n  \"dependencies\": {\n    \"json-stable-stringify\": \"~1.0.1\",\n    \"tslib\": \"^1.6.0\",\n    \"vega-util\": \"~1.1.4\",\n    \"yargs\": \"~7.0.1\"\n  }\n}\n","\nexport type AggregateOp = 'argmax' | 'argmin' | 'average' | 'count'\n  | 'distinct' | 'max' | 'mean' | 'median' | 'min' | 'missing' | 'modeskew'\n  | 'q1' | 'q3' | 'stdev' | 'stdevp' | 'sum' | 'valid' | 'values' | 'variance'\n  | 'variancep';\n\nexport const AGGREGATE_OPS: AggregateOp[] = [\n    'values',\n    'count',\n    'valid',\n    'missing',\n    'distinct',\n    'sum',\n    'mean',\n    'average',\n    'variance',\n    'variancep',\n    'stdev',\n    'stdevp',\n    'median',\n    'q1',\n    'q3',\n    'modeskew',\n    'min',\n    'max',\n    'argmin',\n    'argmax',\n];\n\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexport const SUM_OPS: AggregateOp[] = [\n    'count',\n    'sum',\n    'distinct',\n    'valid',\n    'missing'\n];\n\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS: AggregateOp[] = [\n    'mean',\n    'average',\n    'median',\n    'q1',\n    'q3',\n    'min',\n    'max',\n];\n","import {DateTime} from './datetime';\nimport {VgAxisEncode, VgAxisBase, VgAxisConfig} from './vega.schema';\n\nexport type AxisOrient = 'top' | 'right' | 'left' | 'bottom';\n\nexport interface AxisConfig extends VgAxisConfig, VlOnlyAxisBase {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n}\n\nexport const defaultAxisConfig: AxisConfig = {\n  labelMaxLength: 25,\n};\n\nexport interface Axis extends VgAxisBase, VlOnlyAxisBase {\n  /**\n   * The padding, in pixels, between axis and text labels.\n   */\n  labelPadding?: number;\n\n  /**\n   * The formatting pattern for axis labels.\n   */\n  format?: string; // default value determined by config.format anyway\n\n  /**\n   * The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).\n   */\n  orient?: AxisOrient;\n\n  /**\n   * The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n   */\n  offset?: number;\n\n  /**\n   * The anchor position of the axis in pixels. For x-axis with top or bottom orientation, this sets the axis group x coordinate. For y-axis with left or right orientation, this sets the axis group y coordinate.\n   *\n   * __Default value__: `0`\n   */\n  position?: number;\n\n  /**\n   * A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n   * @minimum 0\n   * @TJS-type integer\n   */\n  tickCount?: number;\n\n  /**\n   * A title for the axis. Shows field name and its function by default.\n   */\n  title?: string;\n\n  values?: number[] | DateTime[];\n\n  /**\n   * A non-positive integer indicating z-index of the axis.\n   * If zindex is 0, axes should be drawn behind all chart elements.\n   * To put them in front, use zindex = 1.\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n\n  /**\n   * Optional mark definitions for custom axis encoding.\n   */\n  encode?: VgAxisEncode;\n}\n\n\n/**\n * Base object for properties that are shared between Axis and Axis Config.\n * These properties are not in Vega Axis and Axis Config.\n */\nexport interface VlOnlyAxisBase {\n  /**\n   * Truncate labels that are too long.\n   * @minimum 1\n   * @TJS-type integer\n   */\n  labelMaxLength?: number;\n}\n\nexport const AXIS_PROPERTIES:(keyof Axis)[] = [\n  'domain', 'format', 'grid', 'labelPadding', 'labels', 'maxExtent', 'minExtent', 'offset', 'orient', 'position', 'tickCount', 'ticks', 'tickSize', 'title', 'titlePadding', 'values', 'zindex'\n];\n\nexport const VL_ONLY_AXIS_PROPERTIES:(keyof VlOnlyAxisBase)[] = ['labelMaxLength'];\n","import {Channel, ROW, COLUMN, SHAPE, SIZE} from './channel';\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface Bin {\n  /**\n   * A two-element (`[min, max]`) array indicating the range of desired bin values.\n   * @minItems 2\n   * @maxItems 2\n   */\n  extent?: number[];\n\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins. If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   * @minItems 1\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   * @minItems 1\n   */\n  divide?: number[];\n  /**\n   * Maximum number of bins.\n   * @minimum 2\n   */\n  maxbins?: number;\n}\n\nexport function autoMaxBins(channel: Channel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n      // Facets and Size shouldn't have too many bins\n      // We choose 6 like shape to simplify the rule\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    default:\n      return 10;\n  }\n}\n","/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {Encoding} from './encoding';\nimport {Facet} from './facet';\nimport {Mark} from './mark';\nimport {RangeType} from './compile/scale/type';\nimport {ScaleType, SCALE_TYPES} from './scale';\nimport {contains, toSet, without} from './util';\n\nexport namespace Channel {\n  // Facet\n  export const ROW: 'row' = 'row';\n  export const COLUMN: 'column' = 'column';\n\n  // Position\n  export const X: 'x' = 'x';\n  export const Y: 'y' = 'y';\n  export const X2: 'x2' = 'x2';\n  export const Y2: 'y2' = 'y2';\n\n  // Mark property with scale\n  export const COLOR: 'color' = 'color';\n  export const SHAPE: 'shape' = 'shape';\n  export const SIZE: 'size' = 'size';\n  export const OPACITY: 'opacity' = 'opacity';\n\n  // Non-scale channel\n  export const TEXT: 'text' = 'text';\n  export const ORDER: 'order' = 'order';\n  export const DETAIL: 'detail' = 'detail';\n}\n\nexport type Channel = keyof Encoding | keyof Facet;\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\n\n\nexport const CHANNELS = [X, Y, X2, Y2, ROW, COLUMN, SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = [X, Y, X2, Y2, SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT\nexport const UNIT_SCALE_CHANNELS = [X, Y, SIZE, SHAPE, COLOR, OPACITY];\n\n// UNIT_SCALE_CHANNELS with ROW, COLUMN\nexport const SCALE_CHANNELS = [X, Y, SIZE, SHAPE, COLOR, OPACITY, ROW, COLUMN];\n\n// UNIT_CHANNELS without X, Y, X2, Y2;\nexport const NONSPATIAL_CHANNELS = [SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// UNIT_SCALE_CHANNELS without X, Y;\nexport const NONSPATIAL_SCALE_CHANNELS = [SIZE, SHAPE, COLOR, OPACITY];\n\nexport const LEVEL_OF_DETAIL_CHANNELS = without(NONSPATIAL_CHANNELS, ['order'] as Channel[]);\n\n/** Channels that can serve as groupings for stacked charts. */\nexport const STACK_GROUP_CHANNELS = [COLOR, DETAIL, ORDER, OPACITY, SIZE];\n\nexport interface SupportedMark {\n  point?: boolean;\n  tick?: boolean;\n  rule?: boolean;\n  circle?: boolean;\n  square?: boolean;\n  bar?: boolean;\n  rect?: boolean;\n  line?: boolean;\n  area?: boolean;\n  text?: boolean;\n};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return mark in getSupportedMark(channel);\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case DETAIL:\n    case ORDER:    // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case ROW:\n    case COLUMN:\n      return { // all marks\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, rect: true, line: true, area: true, text: true\n      };\n    case X2:\n    case Y2:\n      return {\n        rule: true, bar: true, rect: true, area: true\n      };\n    case SIZE:\n      return {\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, text: true, line: true\n      };\n    case SHAPE:\n      return {point: true};\n    case TEXT:\n      return {text: true};\n  }\n  return {};\n}\n\nexport function hasScale(channel: Channel) {\n  return !contains([DETAIL, TEXT, ORDER], channel);\n}\n\n// Position does not work with ordinal (lookup) scale and sequential (which is only for color)\nconst POSITION_SCALE_TYPE_INDEX = toSet(without(SCALE_TYPES, ['ordinal', 'sequential'] as ScaleType[]));\n\nexport function supportScaleType(channel: Channel, scaleType: ScaleType): boolean {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n      return scaleType === 'band'; // row / column currently supports band only\n    case X:\n    case Y:\n    case SIZE: // TODO: size and opacity can support ordinal with more modification\n    case OPACITY:\n      // Although it generally doesn't make sense to use band with size and opacity,\n      // it can also work since we use band: 0.5 to get midpoint.\n      return scaleType in POSITION_SCALE_TYPE_INDEX;\n    case COLOR:\n      return scaleType !== 'band';    // band does not make sense with color\n    case SHAPE:\n      return scaleType === 'ordinal'; // shape = lookup only\n  }\n  /* istanbul ignore next: it should never reach here */\n  return false;\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case OPACITY:\n      return 'continuous';\n\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n      return 'flexible';\n\n    // No scale, no range type.\n    case X2:\n    case Y2:\n    case DETAIL:\n    case TEXT:\n    case ORDER:\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('getSupportedRole not implemented for ' + channel);\n}\n","import {COLUMN, X, Channel} from '../../channel';\nimport {NOMINAL, ORDINAL, TEMPORAL} from '../../type';\nimport {contains, keys, extend} from '../../util';\nimport {VgAxis} from '../../vega.schema';\n\nimport {timeFormatExpression} from '../common';\nimport {Model} from '../model';\n\nexport function labels(model: Model, channel: Channel, labelsSpec: any, def: VgAxis) {\n  const fieldDef = model.fieldDef(channel);\n  const axis = model.axis(channel);\n  const config = model.config;\n\n  // Text\n  if (contains([NOMINAL, ORDINAL], fieldDef.type) && axis.labelMaxLength) {\n    // TODO replace this with Vega's labelMaxLength once it is introduced\n    labelsSpec = extend({\n      text: {\n        signal: `truncate(datum.value, ${axis.labelMaxLength})`\n      }\n    }, labelsSpec || {});\n  } else if (fieldDef.type === TEMPORAL) {\n    labelsSpec = extend({\n      text: {\n        signal: timeFormatExpression('datum.value', fieldDef.timeUnit, axis.format, config.axis.shortTimeLabels, config.timeFormat)\n      }\n    }, labelsSpec);\n  }\n\n  // Label Angle\n  if (axis.labelAngle !== undefined) {\n    labelsSpec.angle = {value: axis.labelAngle};\n  } else {\n    // auto rotate for X\n    if (channel === X && (contains([NOMINAL, ORDINAL], fieldDef.type) || !!fieldDef.bin || fieldDef.type === TEMPORAL)) {\n      labelsSpec.angle = {value: 270};\n    }\n  }\n\n  // Auto set align if rotated\n  // TODO: consider other value besides 270, 90\n  if (labelsSpec.angle) {\n    if (labelsSpec.angle.value === 270) {\n      labelsSpec.align = {\n        value: def.orient === 'top' ? 'left':\n                (channel === X || channel === COLUMN) ? 'right' :\n                'center'\n      };\n    } else if (labelsSpec.angle.value === 90) {\n      labelsSpec.align = {value: 'center'};\n    }\n  }\n\n  if (labelsSpec.angle) {\n    // Auto set baseline if rotated\n    // TODO: consider other value besides 270, 90\n    if (labelsSpec.angle.value === 270) {\n      labelsSpec.baseline = {value: (channel === X || channel === COLUMN) ? 'middle' : 'bottom'};\n    } else if (labelsSpec.angle.value === 90) {\n      labelsSpec.baseline = {value: 'bottom'};\n    }\n  }\n\n  return keys(labelsSpec).length === 0 ? undefined : labelsSpec;\n}\n","import {Axis, AXIS_PROPERTIES} from '../../axis';\nimport {Channel} from '../../channel';\nimport {VgAxis} from '../../vega.schema';\n\nimport * as encode from './encode';\nimport * as rules from './rules';\n\nimport {Model} from '../model';\nimport {Dict, keys, some} from '../../util';\n\ntype AxisPart = 'domain' | 'grid' | 'labels' | 'ticks' | 'title';\nconst AXIS_PARTS: AxisPart[] = ['domain', 'grid', 'labels', 'ticks', 'title'];\n\nexport function parseAxisComponent(model: Model, axisChannels: Channel[]): Dict<VgAxis[]> {\n  return axisChannels.reduce(function(axis, channel) {\n    const vgAxes: VgAxis[] = [];\n    if (model.axis(channel)) {\n      const main = parseMainAxis(channel, model);\n      if (main && isVisibleAxis(main)) {\n        vgAxes.push(main);\n      }\n\n      const grid = parseGridAxis(channel, model);\n      if (grid && isVisibleAxis(grid)) {\n        vgAxes.push(grid);\n      }\n\n      if (vgAxes.length > 0) {\n        axis[channel] = vgAxes;\n      }\n    }\n    return axis;\n  }, {});\n}\n\nfunction isFalseOrNull(v: boolean | null) {\n  return v === false || v === null;\n}\n\n/**\n * Return if an axis is visible (shows at least one part of the axis).\n */\nfunction isVisibleAxis(axis: VgAxis) {\n  return some(AXIS_PARTS, (part) => hasAxisPart(axis, part));\n}\n\nfunction hasAxisPart(axis: VgAxis, part: AxisPart) {\n  // FIXME this method can be wrong if users use a Vega theme.\n  // (Not sure how to correctly handle that yet.).\n\n  if (part === 'grid' || part === 'title') {\n    return !!axis[part];\n  }\n  // Other parts are enabled by default, so they should not be false or null.\n  return !isFalseOrNull(axis[part]);\n}\n\n/**\n * Make an inner axis for showing grid for shared axis.\n */\nexport function parseGridAxis(channel: Channel, model: Model): VgAxis {\n  // FIXME: support adding ticks for grid axis that are inner axes of faceted plots.\n  return parseAxis(channel, model, true);\n}\n\nexport function parseMainAxis(channel: Channel, model: Model) {\n  return parseAxis(channel, model, false);\n}\n\nfunction parseAxis(channel: Channel, model: Model, isGridAxis: boolean): VgAxis {\n  const axis = model.axis(channel);\n\n  let vgAxis: VgAxis = {\n    scale: model.scaleName(channel)\n  };\n\n  // 1.2. Add properties\n  AXIS_PROPERTIES.forEach(function(property) {\n    const value = getSpecifiedOrDefaultValue(property, axis, channel, model, isGridAxis);\n    if (value !== undefined) {\n      vgAxis[property] = value;\n    }\n  });\n\n  // Special case for gridScale since gridScale is not a Vega-Lite Axis property.\n  const gridScale = getSpecifiedOrDefaultValue('gridScale', axis, channel, model, isGridAxis);\n  if (gridScale !== undefined) {\n      vgAxis.gridScale = gridScale;\n  }\n\n  // 2) Add guide encode definition groups\n\n  const encodeSpec = axis.encode || {};\n  AXIS_PARTS.forEach(function(part) {\n    if (!hasAxisPart(vgAxis, part)) {\n      // No need to create encode for a disabled part.\n      return;\n    }\n    // TODO(@yuhanlu): instead of calling encode[part], break this line based on part type\n    // as different require different parameters.\n    let value;\n    if (part === 'labels') {\n        value = encode.labels(model, channel, encodeSpec.labels || {}, vgAxis);\n    } else {\n        value = encodeSpec[part] || {};\n    }\n\n    if (value !== undefined && keys(value).length > 0) {\n      vgAxis.encode = vgAxis.encode || {};\n      vgAxis.encode[part] = {update: value};\n    }\n  });\n\n  return vgAxis;\n}\n\nfunction getSpecifiedOrDefaultValue(property: keyof VgAxis, specifiedAxis: Axis, channel: Channel, model: Model, isGridAxis: boolean) {\n  const fieldDef = model.fieldDef(channel);\n\n  switch (property) {\n    case 'labels':\n      return isGridAxis ? false : specifiedAxis[property];\n    case 'domain':\n      return rules.domain(property, specifiedAxis, isGridAxis, channel);\n    case 'ticks':\n      return rules.ticks(property, specifiedAxis, isGridAxis, channel);\n    case 'format':\n      return rules.format(specifiedAxis, channel, fieldDef, model.config);\n    case 'grid':\n      return rules.grid(model, channel, isGridAxis); // FIXME: refactor this\n    case 'gridScale':\n      return rules.gridScale(model, channel, isGridAxis);\n    case 'orient':\n      return rules.orient(specifiedAxis, channel);\n    case 'tickCount':\n      return rules.tickCount(specifiedAxis, channel, fieldDef); // TODO: scaleType\n    case 'title':\n      return rules.title(specifiedAxis, fieldDef, model.config, isGridAxis);\n    case 'values':\n      return rules.values(specifiedAxis);\n    case 'zindex':\n      return rules.zindex(specifiedAxis, isGridAxis);\n  }\n  // Otherwise, return specified property.\n  return specifiedAxis[property];\n}\n","import * as log from '../../log';\n\nimport {Axis} from '../../axis';\nimport {VgAxis} from '../../vega.schema';\nimport {COLUMN, ROW, X, Y, Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {title as fieldDefTitle, FieldDef} from '../../fielddef';\nimport {truncate} from '../../util';\n\nimport {numberFormat} from '../common';\nimport {Model} from '../model';\n\nexport function format(specifiedAxis: Axis, channel: Channel, fieldDef: FieldDef, config: Config) {\n  return numberFormat(fieldDef, specifiedAxis.format, config, channel);\n}\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function gridShow(model: Model, channel: Channel) {\n  const grid = model.axis(channel).grid;\n  if (grid !== undefined) {\n    return grid;\n  }\n\n  return !model.hasDiscreteScale(channel) && !model.fieldDef(channel).bin;\n}\n\nexport function grid(model: Model, channel: Channel, isGridAxis: boolean) {\n  if (channel === ROW || channel === COLUMN) {\n    // never apply grid for ROW and COLUMN since we manually create rule-group for them\n    return false;\n  }\n\n  if (!isGridAxis) {\n    return undefined;\n  }\n\n  return gridShow(model, channel);\n}\n\nexport function gridScale(model: Model, channel: Channel, isGridAxis: boolean) {\n  if (isGridAxis) {\n    const gridChannel: Channel = channel === 'x' ? 'y' : 'x';\n    if (model.scale(gridChannel)) {\n      return model.scaleName(gridChannel);\n    }\n  }\n  return undefined;\n}\n\nexport function orient(specifiedAxis: Axis, channel: Channel) {\n  const orient = specifiedAxis.orient;\n  if (orient) {\n    return orient;\n  }\n\n  switch (channel) {\n    case COLUMN:\n      // FIXME test and decide\n      return 'top';\n    case X:\n      return 'bottom';\n    case ROW:\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function tickCount(specifiedAxis: Axis, channel: Channel, fieldDef: FieldDef) {\n  const count = specifiedAxis.tickCount;\n  if (count !== undefined) {\n    return count;\n  }\n\n  // FIXME depends on scale type too\n  if (channel === X && !fieldDef.bin) {\n    // Vega's default tickCount often lead to a lot of label occlusion on X without 90 degree rotation\n    return 5;\n  }\n\n  return undefined;\n}\n\nexport function title(specifiedAxis: Axis, fieldDef: FieldDef, config: Config, isGridAxis: boolean) {\n  if (isGridAxis) {\n    return undefined;\n  }\n  if (specifiedAxis.title !== undefined) {\n    return specifiedAxis.title;\n  }\n\n  // if not defined, automatically determine axis title from field def\n  const fieldTitle = fieldDefTitle(fieldDef, config);\n\n  let maxLength: number = specifiedAxis.titleMaxLength;\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\n}\n\nexport function values(specifiedAxis: Axis) {\n  const vals = specifiedAxis.values;\n  if (specifiedAxis.values && isDateTime(vals[0])) {\n    return (vals as DateTime[]).map((dt) => {\n      // normalize = true as end user won't put 0 = January\n      return timestamp(dt, true);\n    });\n  }\n  return vals;\n}\n\nexport function zindex(specifiedAxis: Axis, isGridAxis: boolean) {\n  const z = specifiedAxis.zindex;\n  if (z !== undefined) {\n    return z;\n  }\n  if (isGridAxis) {\n    // if grid is true, need to put layer on the back so that grid is behind marks\n    return 0;\n  }\n  return 1; // otherwise return undefined and use Vega's default.\n};\n\nexport function domainAndTicks(property: keyof VgAxis, specifiedAxis: Axis, isGridAxis: boolean, channel: Channel) {\n  if (isGridAxis || channel === ROW || channel === COLUMN) {\n    return false;\n  }\n  return specifiedAxis[property];\n}\n\nexport const domain = domainAndTicks;\nexport const ticks = domainAndTicks;\n","import * as log from '../log';\n\nimport {TEXT, Channel} from '../channel';\nimport {Config, CellConfig} from '../config';\nimport {FieldDef, OrderFieldDef, field} from '../fielddef';\nimport {Mark, MarkConfig, TextConfig} from '../mark';\nimport {TimeUnit} from '../timeunit';\nimport {QUANTITATIVE} from '../type';\nimport {isArray} from '../util';\n\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {formatExpression} from '../timeunit';\nimport {UnitModel} from './unit';\nimport {Spec, isUnitSpec, isFacetSpec, isLayerSpec} from '../spec';\nimport {VgEncodeEntry, VgSort} from '../vega.schema';\n\nexport function buildModel(spec: Spec, parent: Model, parentGivenName: string): Model {\n  if (isFacetSpec(spec)) {\n    return new FacetModel(spec, parent, parentGivenName);\n  }\n\n  if (isLayerSpec(spec)) {\n    return new LayerModel(spec, parent, parentGivenName);\n  }\n\n  if (isUnitSpec(spec)) {\n    return new UnitModel(spec, parent, parentGivenName);\n  }\n\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nexport function applyConfig(e: VgEncodeEntry,\n    config: CellConfig | MarkConfig | TextConfig, // TODO(#1842): consolidate MarkConfig | TextConfig?\n    propsList: string[]) {\n  propsList.forEach((property) => {\n    const value = config[property];\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  });\n  return e;\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  propsList.forEach((property) => {\n    const value = getMarkConfig(property, model.mark(), model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  });\n  return e;\n}\n\n/**\n * Return value mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(prop: P, mark: Mark, config: Config): MarkConfig[P] {\n  const markSpecificConfig = config[mark];\n  if (markSpecificConfig[prop] !== undefined) {\n    return markSpecificConfig[prop];\n  }\n  return config.mark[prop];\n}\n\n/**\n * Returns number format for a fieldDef\n *\n * @param format explicitly specified format\n */\nexport function numberFormat(fieldDef: FieldDef, format: string, config: Config, channel: Channel) {\n  if (fieldDef.type === QUANTITATIVE) {\n    // add number format for quantitative type only\n\n    if (format) {\n      return format;\n    } else if (fieldDef.aggregate === 'count' && channel === TEXT) {\n      // FIXME: need a more holistic way to deal with this.\n      return 'd';\n    }\n    // TODO: need to make this work correctly for numeric ordinal / nominal type\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(field: string, timeUnit: TimeUnit, format: string, shortTimeLabels: boolean, timeFormatConfig: string): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    const _format = format || timeFormatConfig; // only use config.timeFormat if there is no timeUnit.\n    return `timeFormat(${field}, '${_format}')`;\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef: OrderFieldDef | OrderFieldDef[]): VgSort {\n  return (isArray(orderDef) ? orderDef : [orderDef]).reduce((s, orderChannelDef) => {\n    s.field.push(field(orderChannelDef, {binSuffix: 'start'}));\n    s.order.push(orderChannelDef.sort || 'ascending');\n    return s;\n  }, {field:[], order: []});\n}\n","/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\n\nimport {LAYOUT} from '../data';\nimport * as log from '../log';\nimport {Model} from './model';\nimport {normalize, ExtendedSpec} from '../spec';\nimport {extend} from '../util';\nimport {assembleTopLevelSignals} from './selection/selection';\nimport {buildModel} from './common';\n\nexport function compile(inputSpec: ExtendedSpec, logger?: log.LoggerInterface) {\n  if (logger) {\n    // set the singleton logger to the provided logger\n    log.set(logger);\n  }\n\n  try {\n    // 1. Convert input spec into a normal form\n    // (Decompose all extended unit specs into composition of unit spec.)\n    const spec = normalize(inputSpec);\n\n    // 2. Instantiate the model with default properties\n    const model = buildModel(spec, null, '');\n\n    // 3. Parse each part of the model to produce components that will be assembled later\n    // We traverse the whole tree to parse once for each type of components\n    // (e.g., data, layout, mark, scale).\n    // Please see inside model.parse() for order for compilation.\n    model.parse();\n\n    // 4. Assemble a Vega Spec from the parsed components in 3.\n    return assemble(model);\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (logger) {\n      log.reset();\n    }\n  }\n}\n\nfunction assemble(model: Model) {\n  // TODO: change type to become VgSpec\n  const output = extend(\n    {\n      $schema: 'http://vega.github.io/schema/vega/v3.0.json',\n    },\n    topLevelBasicProperties(model),\n    {\n      // Map calculated layout width and height to width and height signals.\n      signals: [\n        {\n          name: 'width',\n          update: \"data('layout')[0].width\"\n        },\n        {\n          name: 'height',\n          update: \"data('layout')[0].height\"\n        }\n      ].concat(assembleTopLevelSignals(model))\n    },{\n      data: [].concat(\n        model.assembleData([]),\n        model.assembleLayout([]),\n        model.assembleSelectionData([])\n      ),\n      marks: [assembleRootGroup(model)]\n    });\n\n  return {\n    spec: output\n    // TODO: add warning / errors here\n  };\n}\n\nexport function topLevelBasicProperties(model: Model) {\n  const config = model.config;\n  return extend(\n    // TODO: Add other top-level basic properties (#1778)\n    {padding: model.padding || config.padding},\n    {autosize: 'pad'},\n    config.viewport ? {viewport: config.viewport} : {},\n    config.background ? {background: config.background} : {}\n  );\n}\n\nexport function assembleRootGroup(model: Model) {\n  let rootGroup:any = extend(\n    {\n      name: model.getName('main'),\n      type: 'group',\n    },\n    model.description ? {description: model.description} : {},\n    {\n      from: {data: model.getName(LAYOUT +'')},\n      encode: {\n        update: extend(\n          {\n            width: {field: model.getName('width')},\n            height: {field: model.getName('height')}\n          },\n          model.assembleParentGroupProperties(model.config.cell)\n        )\n      }\n    });\n\n  return extend(rootGroup, model.assembleGroup());\n}\n","import {DataComponentCompiler} from './base';\n\nimport {autoMaxBins} from '../../bin';\nimport {Channel} from '../../channel';\nimport {field, FieldDef} from '../../fielddef';\nimport {extend, vals, flatten, hash, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\nimport {hasDiscreteDomain} from '../../scale';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\n\nfunction numberFormatExpr(expr: string, format: string) {\n  return `format(${expr}, '${format}')`;\n}\n\nfunction parse(model: Model): Dict<VgTransform[]> {\n  return model.reduceFieldDef(function(binComponent: Dict<VgTransform[]>, fieldDef: FieldDef, channel: Channel) {\n    const bin = model.fieldDef(channel).bin;\n    if (bin) {\n\n      let binTrans: VgTransform = extend({\n        type: 'bin',\n        field: fieldDef.field,\n        as: [field(fieldDef, {binSuffix: 'start'}), field(fieldDef, {binSuffix: 'end'})],\n        signal: model.getName(fieldDef.field + '_bins')\n      },\n        // if bin is an object, load parameter here!\n        typeof bin === 'boolean' ? {} : bin\n      );\n\n      const transform: VgTransform[] = [];\n      if (!binTrans.extent) {\n        const extentSignal = model.getName(fieldDef.field + '_extent');\n        transform.push({\n          type: 'extent',\n          field: fieldDef.field,\n          signal: extentSignal\n        });\n\n        binTrans.extent = {signal: extentSignal};\n      }\n\n      if (!binTrans.maxbins && !binTrans.step) {\n        // if both maxbins and step are not specified, need to automatically determine bin\n        binTrans.maxbins = autoMaxBins(channel);\n      }\n\n      transform.push(binTrans);\n\n      const discreteDomain = hasDiscreteDomain(model.scale(channel).type);\n      if (discreteDomain) {\n        // read format from axis or legend, if there is no format then use config.numberFormat\n        const format = (model.axis(channel) || model.legend(channel) || {}).format ||\n          model.config.numberFormat;\n\n        const startField = field(fieldDef, {datum: true, binSuffix: 'start'});\n        const endField = field(fieldDef, {datum: true, binSuffix: 'end'});\n\n        transform.push({\n          type: 'formula',\n          as: field(fieldDef, {binSuffix: 'range'}),\n          expr: `${numberFormatExpr(startField, format)} + ' - ' + ${numberFormatExpr(endField, format)}`\n        });\n      }\n      // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n      const key = hash(bin) + '_' + fieldDef.field + 'oc:' + discreteDomain;\n      binComponent[key] = transform;\n    }\n    return binComponent;\n  }, {});\n}\n\nexport const bin: DataComponentCompiler<Dict<VgTransform[]>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    let binComponent = parse(model);\n\n    const childDataComponent = model.child.component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n      extend(binComponent, childDataComponent.bin);\n      delete childDataComponent.bin;\n    }\n    return binComponent;\n  },\n\n  parseLayer: function (model: LayerModel) {\n    let binComponent = parse(model);\n\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(binComponent, childDataComponent.bin);\n        delete childDataComponent.bin;\n      }\n    });\n\n    return binComponent;\n  },\n\n  assemble: function (component: Dict<VgTransform[]>) {\n    return flatten(vals(component));\n  }\n};\n","import {SOURCE} from '../../data';\nimport {FieldDef} from '../../fielddef';\nimport {Formula} from '../../transform';\nimport {Dict, StringSet} from '../../util';\nimport {VgData, VgSort, VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\nimport {UnitModel} from './../unit';\n\nimport {source} from './source';\nimport {formatParse} from './formatparse';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {pathOrder} from './pathorder';\nimport {nonPositiveFilter} from './nonpositivefilter';\nimport {summary} from './summary';\nimport {stack, StackComponent} from './stack';\nimport {timeUnit} from './timeunit';\n\n/**\n * Composable component instance of a model's data.\n */\nexport interface DataComponent {\n  source: VgData;\n\n  /** Mapping from field name to primitive data type.  */\n  formatParse: Dict<string>;\n\n  /** String set of fields for null filtering */\n  nullFilter: Dict<FieldDef>;\n\n  /** Hashset of a formula object */\n  calculate: Dict<Formula>;\n\n  /** Filter test expression */\n  filter: string;\n\n  /** Dictionary mapping a bin parameter hash to transforms of the binned field */\n  bin: Dict<VgTransform[]>;\n\n  /** Dictionary mapping an output field name (hash) to the time unit transform  */\n  timeUnit: Dict<VgTransform>;\n\n  /** String set of fields to be filtered */\n  nonPositiveFilter: Dict<boolean>;\n\n  /** Sort order to apply at the end */\n  pathOrder: VgSort;\n\n  /**\n   * Stack transforms to be applied.\n   */\n  stack: StackComponent;\n\n  /** Array of summary component object for producing summary (aggregate) data source */\n  summary: SummaryComponent[];\n}\n\n/**\n * Composable component for a model's summary data\n */\nexport interface SummaryComponent {\n  /** Name of the summary data source */\n  name: string;\n\n  /** String set for all dimension fields  */\n  dimensions: StringSet;\n\n  /** dictionary mapping field name to string set of aggregate ops */\n  measures: Dict<StringSet>;\n}\n\n// TODO: split this file into multiple files and remove this linter flag\n/* tslint:disable:no-use-before-declare */\n\nexport function parseUnitData(model: UnitModel): DataComponent {\n  return {\n    formatParse: formatParse.parseUnit(model),\n    nullFilter: nullFilter.parseUnit(model),\n    filter: filter.parseUnit(model),\n    nonPositiveFilter: nonPositiveFilter.parseUnit(model),\n    pathOrder: pathOrder.parseUnit(model),\n\n    source: source.parseUnit(model),\n    bin: bin.parseUnit(model),\n    calculate: formula.parseUnit(model),\n    timeUnit: timeUnit.parseUnit(model),\n    summary: summary.parseUnit(model),\n    stack: stack.parseUnit(model)\n  };\n}\n\nexport function parseFacetData(model: FacetModel): DataComponent {\n  return {\n    formatParse: formatParse.parseFacet(model),\n    nullFilter: nullFilter.parseFacet(model),\n    filter: filter.parseFacet(model),\n    nonPositiveFilter: nonPositiveFilter.parseFacet(model),\n    pathOrder: pathOrder.parseFacet(model),\n\n    source: source.parseFacet(model),\n    bin: bin.parseFacet(model),\n    calculate: formula.parseFacet(model),\n    timeUnit: timeUnit.parseFacet(model),\n    summary: summary.parseFacet(model),\n    stack: stack.parseFacet(model)\n  };\n}\n\nexport function parseLayerData(model: LayerModel): DataComponent {\n  return {\n    // filter and formatParse could cause us to not be able to merge into parent\n    // so let's parse them first\n    filter: filter.parseLayer(model),\n    formatParse: formatParse.parseLayer(model),\n    nullFilter: nullFilter.parseLayer(model),\n    nonPositiveFilter: nonPositiveFilter.parseLayer(model),\n    pathOrder: pathOrder.parseLayer(model),\n\n    // everything after here does not affect whether we can merge child data into parent or not\n    source: source.parseLayer(model),\n    bin: bin.parseLayer(model),\n    calculate: formula.parseLayer(model),\n    timeUnit: timeUnit.parseLayer(model),\n    summary: summary.parseLayer(model),\n    stack: stack.parseLayer(model)\n  };\n}\n\n/* tslint:enable:no-use-before-declare */\n\n/**\n * Creates Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleData(model: Model, data: VgData[]) {\n  const dataComponent = model.component.data;\n\n  const sourceData = source.assemble(dataComponent);\n  if (sourceData) {\n    data.push(sourceData);\n  }\n\n  summary.assemble(dataComponent.summary || [], model.dataName(SOURCE)).forEach(function(summaryData) {\n    data.push(summaryData);\n  });\n\n  // nonPositiveFilter\n  const nonPositiveFilterTransform = nonPositiveFilter.assemble(dataComponent.nonPositiveFilter);\n  if (nonPositiveFilterTransform.length > 0) {\n    if (data.length > 0) {\n      const dataTable = data[data.length - 1];\n      dataTable.transform = (dataTable.transform || []).concat(nonPositiveFilterTransform);\n    } else { /* istanbul ignore else: should never reach here */\n      throw new Error('Invalid nonPositiveFilter not merged');\n    }\n  }\n\n  // stack\n  const stackData = stack.assemble(dataComponent.stack);\n  if (stackData) {\n    data.push(stackData);\n  }\n\n  // Path Order\n  const pathOrderCollectTransform = pathOrder.assemble(dataComponent.pathOrder);\n  if (pathOrderCollectTransform) {\n    const dataTable = data[data.length - 1];\n    if (data.length > 0) {\n      dataTable.transform = (dataTable.transform || []).concat([pathOrderCollectTransform]);\n    } else { /* istanbul ignore else: should never reach here */\n      throw new Error('Invalid path order collect transform not added');\n    }\n  }\n\n  return data;\n}\n","import {DataComponentCompiler} from './base';\n\nimport {expression} from '../../filter';\nimport {isArray} from '../../util';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from '../model';\n\n/**\n * @param v value to be converted into Vega Expression\n * @param timeUnit\n * @return Vega Expression of the value v. This could be one of:\n * - a timestamp value of datetime object\n * - a timestamp value of casted single time unit value\n * - stringified value\n */\n\nfunction parse(model: Model): string {\n  const filter = model.filter();\n  if (isArray(filter)) {\n    return '(' +\n      filter.map((f) => expression(f))\n        .filter((f) => f !==undefined)\n        .join(') && (') +\n      ')';\n  } else if (filter) {\n    return expression(filter);\n  }\n  return undefined;\n}\n\nexport const filter: DataComponentCompiler<string> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    let filterComponent = parse(model);\n\n    const childDataComponent = model.child.component.data;\n\n    // If child doesn't have its own data source but has filter, then merge\n    if (!childDataComponent.source && childDataComponent.filter) {\n      // merge by adding &&\n      filterComponent =\n        (filterComponent ? filterComponent + ' && ' : '') +\n        childDataComponent.filter;\n      delete childDataComponent.filter;\n    }\n    return filterComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n    let filterComponent = parse(model);\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && childDataComponent.filter && childDataComponent.filter === filterComponent) {\n        // same filter in child so we can just delete it\n        delete childDataComponent.filter;\n      }\n    });\n    return filterComponent;\n  },\n\n  assemble: function(filterComponent: string) {\n    return filterComponent ? [{\n      type: 'filter',\n      expr: filterComponent\n    }] : [];\n  }\n};\n","import {DataComponentCompiler} from './base';\n\nimport {isDateTime, DateTime} from '../../datetime';\nimport {isUrlData} from '../../data';\nimport {FieldDef, isCount} from '../../fielddef';\nimport {isOneOfFilter, isEqualFilter, isRangeFilter} from '../../filter';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {extend, differ, keys, isArray, isNumber, isString, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nfunction parse(model: Model): Dict<string> {\n  const calcFieldMap = (model.calculate() || []).reduce(function(fieldMap, formula) {\n    fieldMap[formula.as] = true;\n    return fieldMap;\n  }, {});\n\n  let parseComponent: Dict<string> = {};\n\n  // Parse filter fields\n  let filter = model.filter();\n  if (!isArray(filter)) {\n    filter = [filter];\n  }\n  filter.forEach(f => {\n    let val: string | number | boolean | DateTime = null;\n    // For EqualFilter, just use the equal property.\n    // For RangeFilter and OneOfFilter, all array members should have\n    // the same type, so we only use the first one.\n    if (isEqualFilter(f)) {\n      val = f.equal;\n    } else if (isRangeFilter(f)) {\n      val = f.range[0];\n    } else if (isOneOfFilter(f)) {\n      val = (f.oneOf || f['in'])[0];\n    } // else -- for filter expression, we can't infer anything\n\n    if (!!val) {\n      if (isDateTime(val)) {\n        parseComponent[f['field']] = 'date';\n      } else if (isNumber(val)) {\n        parseComponent[f['field']] = 'number';\n      } else if (isString(val)) {\n        parseComponent[f['field']] = 'string';\n      }\n    }\n  });\n\n  // Parse encoded fields\n  model.forEachFieldDef(function(fieldDef: FieldDef) {\n    if (fieldDef.type === TEMPORAL) {\n      parseComponent[fieldDef.field] = 'date';\n    } else if (fieldDef.type === QUANTITATIVE) {\n      if (isCount(fieldDef) || calcFieldMap[fieldDef.field]) {\n        return;\n      }\n      parseComponent[fieldDef.field] = 'number';\n    }\n  });\n\n  // Custom parse should override inferred parse\n  const data = model.data;\n  if (data && isUrlData(data) && data.format && data.format.parse) {\n    const parse = data.format.parse;\n    keys(parse).forEach((field) => {\n      parseComponent[field] = parse[field];\n    });\n  }\n\n  return parseComponent;\n}\n\nexport const formatParse: DataComponentCompiler<Dict<string>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    let parseComponent = parse(model);\n\n    // If child doesn't have its own data source, but has its own parse, then merge\n    const childDataComponent = model.child.component.data;\n    if (!childDataComponent.source && childDataComponent.formatParse) {\n      extend(parseComponent, childDataComponent.formatParse);\n      delete childDataComponent.formatParse;\n    }\n    return parseComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let parseComponent = parse(model);\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.formatParse, parseComponent)) {\n        // merge parse up if the child does not have an incompatible parse\n        extend(parseComponent, childDataComponent.formatParse);\n        delete childDataComponent.formatParse;\n      }\n    });\n    return parseComponent;\n  },\n\n  // identity function\n  assemble: function (x) {return x;}\n};\n","import {DataComponentCompiler} from './base';\n\nimport {Formula} from '../../transform';\nimport {extend, vals, hash, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nfunction parse(model: Model): Dict<Formula> {\n  return (model.calculate() || []).reduce(function(formulaComponent, formula) {\n    formulaComponent[hash(formula)] = formula;\n    return formulaComponent;\n  }, {});\n}\n\nexport const formula: DataComponentCompiler<Dict<Formula>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel): Dict<Formula> {\n    let formulaComponent = parse(model);\n\n    const childDataComponent = model.child.component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(formulaComponent, childDataComponent.calculate);\n      delete childDataComponent.calculate;\n    }\n    return formulaComponent;\n  },\n\n  parseLayer: function(model: LayerModel): Dict<Formula> {\n    let formulaComponent = parse(model);\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.calculate) {\n        extend(formulaComponent || {}, childDataComponent.calculate);\n        delete childDataComponent.calculate;\n      }\n    });\n    return formulaComponent;\n  },\n\n  assemble: function(component: Dict<Formula>) {\n    return vals(component).reduce(function(transform: any, f: any) {\n      transform.push(extend({type: 'formula'}, f));\n      return transform;\n    }, []);\n  }\n};\n","import {DataComponentCompiler} from './base';\n\nimport {ScaleType} from '../../scale';\nimport {extend, keys, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\n\nexport const nonPositiveFilter: DataComponentCompiler<Dict<boolean>> = {\n  parseUnit: function(model: Model): Dict<boolean> {\n    return model.channels().reduce(function(nonPositiveComponent, channel) {\n      const scale = model.scale(channel);\n      if (!model.field(channel) || !scale) {\n        // don't set anything\n        return nonPositiveComponent;\n      }\n      nonPositiveComponent[model.field(channel)] = scale.type === ScaleType.LOG;\n      return nonPositiveComponent;\n    }, {});\n  },\n\n  parseFacet: function(model: FacetModel) {\n    const childDataComponent = model.child.component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // For now, let's assume it always has union scale\n      const nonPositiveFilterComponent = childDataComponent.nonPositiveFilter;\n      delete childDataComponent.nonPositiveFilter;\n      return nonPositiveFilterComponent;\n    }\n    return {};\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let nonPositiveFilterComponent = {};\n\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.nonPositiveFilter, nonPositiveFilterComponent)) {\n        extend(nonPositiveFilterComponent, childDataComponent.nonPositiveFilter);\n        delete childDataComponent.nonPositiveFilter;\n      }\n    });\n\n    return nonPositiveFilterComponent;\n  },\n\n  assemble: function(nonPositiveFilterComponent: Dict<boolean>) {\n    if (nonPositiveFilterComponent) {\n      return keys(nonPositiveFilterComponent).filter((field) => {\n        // Only filter fields (keys) with value = true\n        return nonPositiveFilterComponent[field];\n      }).map(function(field) {\n        return {\n          type: 'filter',\n          expr: 'datum[\"' + field + '\"] > 0'\n        };\n      });\n    }\n    return [];\n  }\n};\n","import {DataComponentCompiler} from './base';\n\nimport {FieldDef} from '../../fielddef';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, extend, keys, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nconst DEFAULT_NULL_FILTERS = {\n  nominal: false,\n  ordinal: false,\n  quantitative: true,\n  temporal: true\n};\n\n/** Return Hashset of fields for null filtering (key=field, value = true). */\nfunction parse(model: Model): Dict<FieldDef> {\n  const filterInvalid = model.filterInvalid();\n\n  return model.reduceFieldDef(function(aggregator: Dict<FieldDef>, fieldDef: FieldDef) {\n    if (fieldDef.field !== '*') { // Ignore * for count(*) fields.\n      if (filterInvalid ||\n        (filterInvalid === undefined && fieldDef.field && DEFAULT_NULL_FILTERS[fieldDef.type])) {\n        aggregator[fieldDef.field] = fieldDef;\n      } else {\n        // define this so we know that we don't filter nulls for this field\n        // this makes it easier to merge into parents\n        aggregator[fieldDef.field] = null;\n      }\n    }\n    return aggregator;\n  }, {});\n}\n\nexport const nullFilter: DataComponentCompiler<Dict<FieldDef>> = {\n  parseUnit: parse,\n\n  parseFacet: function(model: FacetModel) {\n    const nullFilterComponent = parse(model);\n\n    const childDataComponent = model.child.component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(nullFilterComponent, childDataComponent.nullFilter);\n      delete childDataComponent.nullFilter;\n    }\n    return nullFilterComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n\n    // FIXME: null filters are not properly propagated right now\n    let nullFilterComponent = parse(model);\n\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ<FieldDef>(childDataComponent.nullFilter, nullFilterComponent)) {\n        extend(nullFilterComponent, childDataComponent.nullFilter);\n        delete childDataComponent.nullFilter;\n      }\n    });\n\n    return nullFilterComponent;\n  },\n\n  assemble: function(component: Dict<FieldDef>) {\n    const filters = keys(component).reduce((_filters, field) => {\n      const fieldDef = component[field];\n      if (fieldDef !== null) {\n        _filters.push('datum[\"' + fieldDef.field + '\"] !== null');\n        if (contains([QUANTITATIVE, TEMPORAL], fieldDef.type)) {\n          // TODO(https://github.com/vega/vega-lite/issues/1436):\n          // We can be even smarter and add NaN filter for N,O that are numbers\n          // based on the `parse` property once we have it.\n          _filters.push('!isNaN(datum[\"'+ fieldDef.field + '\"])');\n        }\n      }\n      return _filters;\n    }, []);\n\n    return filters.length > 0 ?\n      [{\n        type: 'filter',\n        expr: filters.join(' && ')\n      }] : [];\n  }\n};\n","import * as stringify from 'json-stable-stringify';\n\nimport {DataComponentCompiler} from './base';\n\nimport {isAggregate} from '../../encoding';\nimport {field} from '../../fielddef';\nimport {isSortField} from '../../sort';\nimport {VgSort} from '../../vega.schema';\nimport {contains} from '../../util';\n\nimport {sortParams} from '../common';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {UnitModel} from '../unit';\n\nexport const pathOrder: DataComponentCompiler<VgSort> = {\n  parseUnit: function(model: UnitModel): VgSort {\n    if (contains(['line', 'area'], model.mark())) {\n      if (model.mark() === 'line' && model.channelHasField('order')) {\n        // For only line, sort by the order field if it is specified.\n        return sortParams(model.encoding.order);\n      } else {\n        // For both line and area, we sort values based on dimension by default\n        const dimensionChannel: 'x' | 'y' = model.markDef.orient === 'horizontal' ? 'y' : 'x';\n        const sort = model.sort(dimensionChannel);\n        const sortField = isSortField(sort) ?\n          field({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? sort.op : undefined,\n            field: sort.field\n          }) :\n          model.field(dimensionChannel, {binSuffix: 'start'});\n\n        return {\n          field: sortField,\n          order: 'descending'\n        };\n      }\n\n    }\n    return null;\n  },\n\n  parseFacet: function(model: FacetModel) {\n    const childDataComponent = model.child.component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // For now, let's assume it always has union scale\n      const pathOrderComponent = childDataComponent.pathOrder;\n      delete childDataComponent.pathOrder;\n      return pathOrderComponent;\n    }\n    return null;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let pathOrderComponent: VgSort = null;\n    let stringifiedPathOrder: string = null;\n\n    for (let child of model.children) {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && childDataComponent.pathOrder !== null) {\n        if (pathOrderComponent === null) {\n          pathOrderComponent = childDataComponent.pathOrder;\n          stringifiedPathOrder = stringify(pathOrderComponent);\n        } else if (stringifiedPathOrder !== stringify(childDataComponent.pathOrder)) {\n          pathOrderComponent = null;\n          break;\n        }\n      }\n    }\n\n    if (pathOrderComponent !== null) {\n      // If we merge pathOrderComponent, remove them from children.\n      for (let child of model.children) {\n        delete child.component.data.pathOrder;\n      }\n    }\n\n    return pathOrderComponent;\n  },\n\n  assemble: function(pathOrderComponent: VgSort) {\n    if (pathOrderComponent) {\n      return {\n        type: 'collect',\n        sort: pathOrderComponent\n      };\n    }\n    return null;\n  }\n};\n","import {DataFormat, isNamedData, isInlineData, isUrlData, SOURCE} from '../../data';\nimport {contains, extend} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {timeUnit} from './timeunit';\n\nexport namespace source {\n  function parse(model: Model): VgData {\n    let data = model.data;\n\n    if (data) {\n      // If data is explicitly provided\n\n      let sourceData: VgData = {name: model.dataName(SOURCE)};\n      if (isInlineData(data)) {\n        sourceData.values = data.values;\n        sourceData.format = {type: 'json'};\n      } else if (isUrlData(data)) {\n        sourceData.url = data.url;\n\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(sourceData.url)[1];\n        if (!contains(['json', 'csv', 'tsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n        const dataFormat: DataFormat = data.format || {};\n\n        // For backward compatibility for former `data.formatType` property\n        const formatType: DataFormat = dataFormat.type || data['formatType'];\n        sourceData.format =\n          extend(\n            {type: formatType ? formatType : defaultExtension},\n            dataFormat.property ? {property: dataFormat.property} : {},\n            // Feature and mesh are two mutually exclusive properties\n            dataFormat.feature ?\n              {feature : dataFormat.feature} :\n            dataFormat.mesh ?\n              {mesh : dataFormat.mesh} :\n              {}\n          );\n      } else if (isNamedData(data)) {\n        return {name: data.name};\n      }\n\n      return sourceData;\n    } else if (!model.parent) {\n      // If data is not explicitly provided but the model is a root,\n      // need to produce a source as well\n      return {name: model.dataName(SOURCE)};\n    }\n    return undefined;\n  }\n\n  export const parseUnit: (model: Model) => VgData = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let sourceData = parse(model);\n    if (!model.child.component.data.source) {\n      // If the child does not have its own source, have to rename its source.\n      model.child.renameData(model.child.dataName(SOURCE), model.dataName(SOURCE));\n    }\n\n    return sourceData;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let sourceData = parse(model);\n    model.children.forEach((child) => {\n      const childData = child.component.data;\n\n      if (model.compatibleSource(child)) {\n        // we cannot merge if the child has filters defined even after we tried to move them up\n        const canMerge = !childData.filter && !childData.formatParse && !childData.nullFilter;\n        if (canMerge) {\n          // rename source because we can just remove it\n          child.renameData(child.dataName(SOURCE), model.dataName(SOURCE));\n          delete childData.source;\n        } else {\n          // child does not have data defined or the same source so just use the parents source\n          childData.source = {\n            name: child.dataName(SOURCE),\n            source: model.dataName(SOURCE)\n          };\n        }\n      }\n    });\n    return sourceData;\n  }\n\n  export function assemble(component: DataComponent) {\n    if (component.source) {\n      let sourceData: VgData = component.source;\n\n      if (component.formatParse) {\n        component.source.format = component.source.format || {};\n        component.source.format.parse = component.formatParse;\n      }\n\n      sourceData.transform = [].concat(\n        formula.assemble(component.calculate),\n        nullFilter.assemble(component.nullFilter),\n        filter.assemble(component.filter),\n        bin.assemble(component.bin),\n        timeUnit.assemble(component.timeUnit)\n      );\n\n      return sourceData;\n    }\n    return null;\n  }\n}\n","import {DataComponentCompiler} from './base';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {UnitModel} from './../unit';\n\nimport {sortParams} from '../common';\nimport {STACKED, SUMMARY} from '../../data';\nimport {FieldDef, field} from '../../fielddef';\nimport {hasDiscreteDomain} from '../../scale';\nimport {StackOffset} from '../../stack';\nimport {contains} from '../../util';\nimport {VgData, VgSort, VgStackTransform, VgImputeTransform} from '../../vega.schema';\n\nexport interface StackComponent {\n  /**\n   * Name of the output stacked data source\n   */\n  name: string;\n\n  /**\n   * Name of the input source data for stacked data source\n   */\n  source: string;\n\n  /**\n   * Grouping fields for stacked charts.  This includes one of x- or 'y-field and may include faceted field.\n   */\n  groupby: string[];\n\n  /**\n   * Stack measure's field\n   */\n  field: string;\n\n  /**\n   * Level of detail fields for each level in the stacked charts such as color or detail.\n   */\n  stackby: string[];\n\n  /**\n   * Field that determines order of levels in the stacked charts.\n   */\n  sort: VgSort;\n\n  /** Mode for stacking marks. */\n  offset: StackOffset;\n\n  /**\n   * Whether to impute the data before stacking.\n   */\n  impute: boolean;\n}\n\n\nfunction getStackByFields(model: UnitModel) {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const channel = by.channel;\n    const fieldDef = by.fieldDef;\n\n    const scale = model.scale(channel);\n    const _field = field(fieldDef, {\n      binSuffix: scale && hasDiscreteDomain(scale.type) ? 'range' : 'start'\n    });\n    if (!!_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, [] as string[]);\n}\n\n/**\n * Stack data compiler\n */\nexport const stack: DataComponentCompiler<StackComponent> = {\n\n  parseUnit: function(model: UnitModel): StackComponent {\n    const stackProperties = model.stack;\n    if (!stackProperties) {\n      return undefined;\n    }\n\n    const groupby = [];\n    if (stackProperties.groupbyChannel) {\n      const groupbyFieldDef = model.fieldDef(stackProperties.groupbyChannel);\n      if (groupbyFieldDef.bin) {\n        // For Bin, we need to add both start and end to ensure that both get imputed\n        // and included in the stack output (https://github.com/vega/vega-lite/issues/1805).\n        groupby.push(model.field(stackProperties.groupbyChannel, {binSuffix: 'start'}));\n        groupby.push(model.field(stackProperties.groupbyChannel, {binSuffix: 'end'}));\n      } else {\n        groupby.push(model.field(stackProperties.groupbyChannel));\n      }\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n\n    let sort: VgSort;\n    if (orderDef) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        s.field.push(field);\n        s.order.push('descending');\n        return s;\n      }, {field:[], order: []});\n    }\n\n    return {\n      name: model.dataName(STACKED),\n      source: model.dataName(SUMMARY),\n      groupby: groupby,\n      field: model.field(stackProperties.fieldChannel),\n      stackby: stackby,\n      sort: sort,\n      offset: stackProperties.offset,\n      impute: contains(['area', 'line'], model.mark())\n    };\n  },\n\n  parseLayer: function(model: LayerModel): StackComponent {\n    // FIXME: merge if identical\n    // FIXME: Correctly support facet of layer of stack.\n    return undefined;\n  },\n\n  parseFacet: function(model: FacetModel): StackComponent {\n    const child = model.child;\n    const childDataComponent = child.component.data;\n    // FIXME: Correctly support facet of layer of stack.\n    if (childDataComponent.stack) {\n      let stackComponent = childDataComponent.stack;\n\n      const newName = model.dataName(STACKED);\n      child.renameData(stackComponent.name, newName);\n      stackComponent.name = newName;\n\n      // Refer to facet's summary instead (always summary because stacked only works with aggregation)\n      stackComponent.source = model.dataName(SUMMARY);\n\n      // Add faceted field to groupby\n      stackComponent.groupby = model.reduceFieldDef((groupby: string[], fieldDef: FieldDef) => {\n        const facetedField = field(fieldDef, {binSuffix: 'start'});\n        if (!contains(groupby, facetedField)) {\n          groupby.push(facetedField);\n        }\n        return groupby;\n      }, stackComponent.groupby);\n\n      delete childDataComponent.stack;\n      return stackComponent;\n    }\n    return undefined;\n  },\n  assemble: (stackComponent: StackComponent): VgData => {\n    if (!stackComponent) {\n      return undefined;\n    }\n\n    let transform: (VgStackTransform|VgImputeTransform)[] = [];\n    // Impute\n    if (stackComponent.impute) {\n      transform.push({\n        type: 'impute',\n        field: stackComponent.field,\n        groupby: stackComponent.stackby,\n        orderby: stackComponent.groupby,\n        method: 'value',\n        value: 0\n      });\n    }\n\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: stackComponent.groupby,\n      field: stackComponent.field,\n      sort: stackComponent.sort,\n      as: [\n        stackComponent.field + '_start',\n        stackComponent.field + '_end'\n      ],\n      offset: stackComponent.offset\n    });\n\n    return {\n      name: stackComponent.name,\n      source: stackComponent.source,\n      transform: transform\n    };\n  }\n};\n","import {SUMMARY} from '../../data';\nimport {field, FieldDef} from '../../fielddef';\nimport {keys, vals, reduce, hash, Dict, StringSet} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {Model} from './../model';\n\nimport {SummaryComponent} from './data';\n\n\nexport namespace summary {\n  function addDimension(dims: {[field: string]: boolean}, fieldDef: FieldDef) {\n    if (fieldDef.bin) {\n      dims[field(fieldDef, {binSuffix: 'start'})] = true;\n      dims[field(fieldDef, {binSuffix: 'end'})] = true;\n\n      // const scale = model.scale(channel);\n      // if (scaleType(scale, fieldDef, channel, model.mark()) === ScaleType.ORDINAL) {\n      // also produce bin_range if the binned field use ordinal scale\n      dims[field(fieldDef, {binSuffix: 'range'})] = true;\n      // }\n    } else {\n      dims[field(fieldDef)] = true;\n    }\n    return dims;\n  }\n\n  export function parseUnit(model: Model): SummaryComponent[] {\n    /* string set for dimensions */\n    const dims: StringSet = {};\n\n    /* dictionary mapping field name => dict set of aggregation functions */\n    const meas: Dict<StringSet> = {};\n\n    model.forEachFieldDef(function(fieldDef, channel) {\n      if (fieldDef.aggregate) {\n        if (fieldDef.aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          /* tslint:disable:no-string-literal */\n          meas['*']['count'] = true;\n          /* tslint:enable:no-string-literal */\n        } else {\n          meas[fieldDef.field] = meas[fieldDef.field] || {};\n          meas[fieldDef.field][fieldDef.aggregate] = true;\n\n          // add min/max so we can use their union as unaggregated domain\n          const scale = model.scale(channel);\n          if (scale && scale.domain === 'unaggregated') {\n            meas[fieldDef.field]['min'] = true;\n            meas[fieldDef.field]['max'] = true;\n          }\n        }\n      } else {\n        addDimension(dims, fieldDef);\n      };\n    });\n\n    return [{\n      name: model.dataName(SUMMARY),\n      dimensions: dims,\n      measures: meas\n    }];\n  }\n\n  export function parseFacet(model: FacetModel): SummaryComponent[] {\n    const childDataComponent = model.child.component.data;\n\n    // FIXME: this could be incorrect for faceted layer charts.\n\n    // If child doesn't have its own data source but has a summary data source, merge\n    if (!childDataComponent.source && childDataComponent.summary) {\n      let summaryComponents = childDataComponent.summary.map(function(summaryComponent) {\n        // add facet fields as dimensions\n        summaryComponent.dimensions = model.reduceFieldDef(addDimension, summaryComponent.dimensions);\n\n        const summaryNameWithoutPrefix = summaryComponent.name.substr(model.child.getName('').length);\n        model.child.renameData(summaryComponent.name, summaryNameWithoutPrefix);\n        summaryComponent.name = summaryNameWithoutPrefix;\n        return summaryComponent;\n      });\n\n      delete childDataComponent.summary;\n      return summaryComponents;\n    }\n    return [];\n  }\n\n  function mergeMeasures(parentMeasures: Dict<Dict<boolean>>, childMeasures: Dict<Dict<boolean>>) {\n    for (const field in childMeasures) {\n      if (childMeasures.hasOwnProperty(field)) {\n        // when we merge a measure, we either have to add an aggregation operator or even a new field\n        const ops = childMeasures[field];\n        for (const op in ops) {\n          if (ops.hasOwnProperty(op)) {\n            if (field in parentMeasures) {\n              // add operator to existing measure field\n              parentMeasures[field][op] = true;\n            } else {\n              parentMeasures[field] = {op: true};\n            }\n          }\n        }\n      }\n    }\n  }\n\n  export function parseLayer(model: LayerModel): SummaryComponent[] {\n    // Index by the fields we are grouping by\n    let summaries: {[key: string]: SummaryComponent} = {};\n\n    // Combine summaries for children that don't have a distinct source\n    // (either having its own data source, or its own tranformation of the same data source).\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.summary) {\n        // Merge the summaries if we can\n        childDataComponent.summary.forEach((childSummary) => {\n          // The key is a hash based on the dimensions;\n          // we use it to find out whether we have a summary that uses the same group by fields.\n          const key = hash(childSummary.dimensions);\n          if (key in summaries) {\n            // yes, there is a summary hat we need to merge into\n            // we know that the dimensions are the same so we only need to merge the measures\n            mergeMeasures(summaries[key].measures, childSummary.measures);\n          } else {\n            // give the summary a new name\n            childSummary.name = model.dataName(SUMMARY) + '_' + keys(summaries).length;\n            summaries[key] = childSummary;\n          }\n\n          // remove summary from child\n          child.renameData(child.dataName(SUMMARY), summaries[key].name);\n          delete childDataComponent.summary;\n        });\n      }\n    });\n\n    return vals(summaries);\n  }\n\n  /**\n   * Assemble the summary. Needs a rename function because we cannot guarantee that the\n   * parent data before the children data.\n   */\n  export function assemble(component: SummaryComponent[], sourceName: string): VgData[] {\n    return component.reduce(function(summaryData, summaryComponent) {\n      const dims = summaryComponent.dimensions;\n      const meas = summaryComponent.measures;\n\n      if (keys(meas).length > 0) { // has aggregate\n        const groupby = keys(dims);\n        const transform = reduce(meas, function(t, fnDictSet, field) {\n          const ops = keys(fnDictSet);\n          for (const op of ops) {\n            t.fields.push(field);\n            t.ops.push(op);\n          }\n          return t;\n        }, {\n          type: 'aggregate',\n          groupby: groupby,\n          fields: [],\n          ops: []\n        });\n\n        summaryData.push({\n          name: summaryComponent.name,\n          source: sourceName,\n          transform: [transform]\n        });\n      }\n      return summaryData;\n    }, []);\n  }\n}\n","import {DataComponentCompiler} from './base';\n\nimport {field, FieldDef} from '../../fielddef';\nimport {fieldExpr} from '../../timeunit';\nimport {TEMPORAL} from '../../type';\nimport {extend, vals, Dict} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model} from '../model';\n\nfunction parse(model: Model): Dict<VgFormulaTransform> {\n  return model.reduceFieldDef(function(timeUnitComponent: Dict<VgFormulaTransform>, fieldDef: FieldDef) {\n    if (fieldDef.type === TEMPORAL && fieldDef.timeUnit) {\n\n      const f = field(fieldDef);\n      timeUnitComponent[f] = {\n        type: 'formula',\n        as: f,\n        expr: fieldExpr(fieldDef.timeUnit, fieldDef.field)\n      };\n    }\n    return timeUnitComponent;\n  }, {});\n}\n\nexport const timeUnit: DataComponentCompiler<Dict<VgFormulaTransform>> = {\n  parseUnit: parse,\n\n  parseFacet: function (model: FacetModel) {\n    let timeUnitComponent = parse(model);\n\n    const childDataComponent = model.child.component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(timeUnitComponent, childDataComponent.timeUnit);\n      delete childDataComponent.timeUnit;\n    }\n    return timeUnitComponent;\n  },\n\n  parseLayer: function(model: LayerModel) {\n    let timeUnitComponent = parse(model);\n    model.children.forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(timeUnitComponent, childDataComponent.timeUnit);\n        delete childDataComponent.timeUnit;\n      }\n    });\n    return timeUnitComponent;\n  },\n  assemble: function(component: Dict<VgFormulaTransform>) {\n    // just join the values, which are already transforms\n    return vals(component);\n  }\n};\n","import * as log from '../log';\n\nimport {Axis, VlOnlyAxisBase, VL_ONLY_AXIS_PROPERTIES} from '../axis';\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\nimport {defaultConfig, Config} from '../config';\nimport {Facet} from '../facet';\nimport {forEach} from '../encoding';\nimport {FieldDef, normalize} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Scale} from '../scale';\nimport {FacetSpec} from '../spec';\nimport {contains, extend, keys, vals, flatten, duplicate, mergeDeep, Dict} from '../util';\nimport {VgData, VgEncodeEntry} from '../vega.schema';\nimport {StackProperties} from '../stack';\n\nimport {parseMainAxis, parseGridAxis, parseAxisComponent} from './axis/parse';\nimport {gridShow} from './axis/rules';\nimport {buildModel} from './common';\nimport {assembleData, parseFacetData} from './data/data';\nimport {assembleLayout, parseFacetLayout} from './layout';\nimport {Model} from './model';\n\nimport initScale from './scale/init';\nimport parseScaleComponent from './scale/parse';\n\n/**\n * Prefix for special data sources for driving column's axis group.\n */\n\nexport const COLUMN_AXES_DATA_PREFIX = 'column-';\n\n/**\n * Prefix for special data sources for driving row's axis group.\n */\nexport const ROW_AXES_DATA_PREFIX = 'row-';\n\nexport class FacetModel extends Model {\n  public readonly facet: Facet;\n\n  public readonly child: Model;\n\n  public readonly children: Model[];\n  protected readonly scales: Dict<Scale> = {};\n\n  protected readonly axes: Dict<Axis> = {};\n\n  protected readonly legends: Dict<Legend> = {};\n\n  public readonly config: Config;\n\n  public readonly stack: StackProperties = null;\n\n  private readonly _spacing: {\n    row?: number;\n    column?: number;\n  } = {};\n\n  constructor(spec: FacetSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    // Config must be initialized before child as it gets cascaded to the child\n    const config = this.config = this.initConfig(spec.config, parent);\n\n    const child  = this.child = buildModel(spec.spec, this, this.getName('child'));\n    this.children = [child];\n\n    const facet  = this.facet = this.initFacet(spec.facet);\n    this.scales  = this.initScalesAndSpacing(facet, config);\n    this.axes   = this.initAxis(facet, config, child);\n    this.legends = {};\n  }\n\n  private initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), parent ? parent.config : {}, specConfig);\n  }\n\n  private initFacet(facet: Facet) {\n    // clone to prevent side effect to the original spec\n    facet = duplicate(facet);\n\n    forEach(facet, function(fieldDef: FieldDef, channel: Channel) {\n      if (!contains([ROW, COLUMN], channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        delete facet[channel];\n        return;\n      }\n\n      // TODO: array of row / column ?\n      if (fieldDef.field === undefined) { // TODO: datum\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        delete facet[channel];\n        return;\n      }\n\n      // Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n      normalize(fieldDef, channel);\n    });\n    return facet;\n  }\n\n  private initScalesAndSpacing(facet: Facet, config: Config): Dict<Scale> {\n    const model = this;\n    return [ROW, COLUMN].reduce(function(_scale, channel) {\n      if (facet[channel]) {\n        _scale[channel] = initScale(\n          channel, facet[channel], config,\n          undefined, // Facet doesn't have one single mark\n          undefined, // TODO(#1647): support width / height here\n          [] // There is no xyRangeSteps here and there is no need to input\n        );\n\n        model._spacing[channel] = spacing(facet[channel].scale || {}, model, config);\n      }\n      return _scale;\n    }, {});\n  }\n\n  private initAxis(facet: Facet, config: Config, child: Model): Dict<Axis> {\n    const model = this;\n    return [ROW, COLUMN].reduce(function(_axis, channel) {\n      if (facet[channel]) {\n        const axisSpec = facet[channel].axis;\n        if (axisSpec !== false) {\n          let vlOnlyAxisProperties: VlOnlyAxisBase = {};\n          VL_ONLY_AXIS_PROPERTIES.forEach(function(property) {\n            if (config.facet.axis[property] !== undefined) {\n              vlOnlyAxisProperties[property] = config.facet.axis[property];\n            }\n          });\n\n          const modelAxis = _axis[channel] = {\n            ...vlOnlyAxisProperties,\n            ...axisSpec\n          };\n\n          if (channel === ROW) {\n            const yAxis: any = child.axis(Y);\n            if (yAxis && yAxis.orient !== 'right' && !modelAxis.orient) {\n              modelAxis.orient = 'right';\n            }\n            if (model.hasDescendantWithFieldOnChannel(X) && !modelAxis.labelAngle) {\n              modelAxis.labelAngle = modelAxis.orient === 'right' ? 90 : 270;\n            }\n          }\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  public channelHasField(channel: Channel): boolean {\n    return !!this.facet[channel];\n  }\n\n  private hasSummary() {\n    const summary = this.component.data.summary;\n    for (const s of summary) {\n      if (keys(s.measures).length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public facetedTable(): string {\n    // FIXME: revise if the suffix should be 'data'\n    return 'faceted-' + this.getName('data');\n  }\n\n  public dataTable(): string {\n    // FIXME: shouldn't we apply data renaming here?\n    if (this.component.data.stack) {\n      return 'stacked';\n    }\n    if (this.hasSummary()) {\n      return 'summary';\n    }\n    return 'source';\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return this.facet[channel];\n  }\n\n  public parseData() {\n    this.child.parseData();\n    this.component.data = parseFacetData(this);\n  }\n\n  public parseSelection() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    this.child.parseLayoutData();\n    this.component.layout = parseFacetLayout(this);\n  }\n\n  public parseScale() {\n    const child = this.child;\n    const model = this;\n\n    child.parseScale();\n\n    // TODO: support scales for field reference of parent data (e.g., for SPLOM)\n\n    // First, add scale for row and column.\n    let scaleComponent = this.component.scales = parseScaleComponent(this);\n\n    // Then, move shared/union from its child spec.\n    keys(child.component.scales).forEach(function(channel) {\n      // TODO: correctly implement independent scale\n      if (true) { // if shared/union scale\n        const scale = scaleComponent[channel] = child.component.scales[channel];\n\n        const scaleNameWithoutPrefix = scale.name.substr(child.getName('').length);\n        const newName = model.scaleName(scaleNameWithoutPrefix, true);\n        child.renameScale(scale.name, newName);\n        scale.name = newName;\n\n        // Once put in parent, just remove the child's scale.\n        delete child.component.scales[channel];\n      }\n    });\n  }\n\n  public parseMark() {\n    this.child.parseMark();\n\n    this.component.mark = extend(\n      {\n        name: this.getName('cell'),\n        type: 'group',\n        from: extend(\n          {\n            facet: {\n              name: this.facetedTable(),\n              data: this.dataTable(),\n              groupby: [].concat(\n                this.channelHasField(ROW) ? [this.field(ROW)] : [],\n                this.channelHasField(COLUMN) ? [this.field(COLUMN)] : []\n              )\n            }\n          }\n        ),\n        encode: {\n          update: getFacetGroupProperties(this)\n        }\n      },\n      // FIXME: move this call to assembleMarks()\n      // Call child's assembleGroup to add marks, scales, axes, and legends.\n      // Note that we can call child's assembleGroup() here because parseMark()\n      // is the last method in compile() and thus the child is completely compiled\n      // at this point.\n      this.child.assembleGroup()\n    );\n  }\n\n  public parseAxis() {\n    this.child.parseAxis();\n    this.component.axes = parseAxisComponent(this, [ROW, COLUMN]);\n  }\n\n  public parseAxisGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child.parseAxisGroup();\n\n    const xAxisGroup = parseAxisGroups(this, X);\n    const yAxisGroup = parseAxisGroups(this, Y);\n\n    this.component.axisGroups = extend(\n      xAxisGroup ? {x: xAxisGroup} : {},\n      yAxisGroup ? {y: yAxisGroup} : {}\n    );\n  }\n\n  public parseGridGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child.parseGridGroup();\n\n    const child = this.child;\n\n    this.component.gridGroups = extend(\n      !child.channelHasField(X) && this.channelHasField(COLUMN) ? {column: getColumnGridGroups(this)} : {},\n      !child.channelHasField(Y) && this.channelHasField(ROW) ? {row: getRowGridGroups(this)} : {}\n    );\n  }\n\n  public parseLegend() {\n    this.child.parseLegend();\n\n    // TODO: support legend for independent non-position scale across facets\n    // TODO: support legend for field reference of parent data (e.g., for SPLOM)\n\n    // For now, assuming that non-positional scales are always shared across facets\n    // Thus, just move all legends from its child\n    this.component.legends = this.child.component.legends;\n    this.child.component.legends = {};\n  }\n\n  public assembleParentGroupProperties(): any {\n    return null;\n  }\n\n  public assembleSignals(signals: any): any[] {\n    return [];\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return [];\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred by children data\n    assembleData(this, data);\n    this.child.assembleData(data);\n    assembleAxesGroupData(this, data);\n\n    return data;\n  }\n\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this.child.assembleLayout(layoutData);\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    return [].concat(\n      // axisGroup is a mapping to VgMarkGroup\n      vals(this.component.axisGroups),\n      flatten(vals(this.component.gridGroups)),\n      this.component.mark\n    );\n  }\n\n  public channels() {\n    return [ROW, COLUMN];\n  }\n\n  protected getMapping() {\n    return this.facet;\n  }\n\n  public spacing(channel: Channel) {\n    return this._spacing[channel];\n  }\n\n  public isFacet() {\n    return true;\n  }\n}\n\nexport function hasSubPlotWithXy(model: FacetModel) {\n  return model.hasDescendantWithFieldOnChannel('x') ||\n    model.hasDescendantWithFieldOnChannel('y');\n}\n\nexport function spacing(scale: Scale, model: FacetModel, config: Config) {\n  if (scale.spacing !== undefined) {\n    return scale.spacing;\n  }\n\n  if (!hasSubPlotWithXy(model)) {\n    // If there is no subplot with x/y, it's a simple table so there should be no spacing.\n    return 0;\n  }\n  return config.scale.facetSpacing;\n}\n\nfunction getFacetGroupProperties(model: FacetModel) {\n  const child = model.child;\n  const mergedCellConfig = extend({}, child.config.cell, child.config.facet.cell);\n\n  return extend({\n      x: model.channelHasField(COLUMN) ? {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN),\n          // offset by the spacing / 2\n          offset: model.spacing(COLUMN) / 2\n        } : {value: model.config.scale.facetSpacing / 2},\n\n      y: model.channelHasField(ROW) ? {\n        scale: model.scaleName(ROW),\n        field: model.field(ROW),\n        // offset by the spacing / 2\n        offset: model.spacing(ROW) / 2\n      } : {value: model.config.scale.facetSpacing / 2},\n\n      width: {field: {parent: model.child.sizeName('width')}},\n      height: {field: {parent: model.child.sizeName('height')}}\n    },\n    hasSubPlotWithXy(model) ? child.assembleParentGroupProperties(mergedCellConfig) : {}\n  );\n}\n\n// TODO: move the rest of the file src/compile/facet/*.ts\n\n/**\n * Add data for driving row/column axes when there are both row and column\n * Note that we don't have to deal with these in the parse step at all\n * because these items never get merged with any other items.\n */\nexport function assembleAxesGroupData(model: FacetModel, data: VgData[]) {\n  if (model.facet.column) {\n    data.push({\n      name: COLUMN_AXES_DATA_PREFIX + model.dataTable(),\n      source: model.dataTable(),\n      transform: [{\n        type: 'aggregate',\n        groupby: [model.field(COLUMN)]\n      }]\n    });\n  }\n\n  if (model.facet.row) {\n    data.push({\n      name: ROW_AXES_DATA_PREFIX + model.dataTable(),\n      source: model.dataTable(),\n      transform: [{\n        type: 'aggregate',\n        groupby: [model.field(ROW)]\n      }]\n    });\n  }\n  return data;\n}\n\nfunction parseAxisGroups(model: FacetModel, channel: 'x' | 'y') {\n  // TODO: add a case where inner spec is not a unit (facet/layer/concat)\n  let axisGroup: any = null;\n\n  const child = model.child;\n  if (child.channelHasField(channel)) {\n    if (child.axis(channel)) {\n      if (true) { // the channel has shared axes\n\n        // add a group for the shared axes\n        axisGroup = getSharedAxisGroup(model, channel);\n\n        if (child.axis(channel) && gridShow(child, channel)) { // show inner grid\n          // add inner axis (aka axis that shows only grid to )\n          child.component.axes[channel] = [parseGridAxis(channel, child)];\n        } else {\n          // Delete existing child axes\n          delete child.component.axes[channel];\n        }\n      } else {\n        // TODO: implement independent axes support\n      }\n    }\n  }\n  return axisGroup;\n}\n\n\nexport function getSharedAxisGroup(model: FacetModel, channel: 'x' | 'y'): VgEncodeEntry {\n  const isX = channel === 'x' ;\n  const facetChannel = isX ? 'column' : 'row';\n  const hasFacet = !!model.facet[facetChannel];\n  const dataPrefix = isX ? COLUMN_AXES_DATA_PREFIX : ROW_AXES_DATA_PREFIX;\n\n  let axesGroup: VgEncodeEntry = {\n    name: model.getName(channel + '-axes'),\n    type: 'group'\n  };\n\n  if (hasFacet) {\n    // Need to drive this with special data source that has one item for each column/row value.\n\n    // TODO: We might only need to drive this with special data source if there are both row and column\n    // However, it might be slightly difficult as we have to merge this with the main group.\n    axesGroup.from = {data: dataPrefix + model.dataTable()};\n  }\n\n  if (isX) {\n    axesGroup.encode = {\n      update: {\n        width: {field: {parent: model.child.sizeName('width')}},\n        height: {field: {group: 'height'}},\n        x: hasFacet ? {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN),\n          // offset by the spacing\n          offset: model.spacing(COLUMN) / 2\n        } : {\n          // TODO: support custom spacing here\n          // offset by the spacing\n          value: model.config.scale.facetSpacing / 2\n        }\n      }\n    };\n  } else {\n    axesGroup.encode = {\n      update: {\n        width: {field: {group: 'width'}},\n        height: {field: {parent: model.child.sizeName('height')}},\n        y: hasFacet ? {\n          scale: model.scaleName(ROW),\n          field: model.field(ROW),\n          // offset by the spacing\n          offset: model.spacing(ROW) / 2\n        } : {\n          // offset by the spacing\n          value: model.config.scale.facetSpacing / 2\n        }\n      }\n    };\n  }\n\n  axesGroup.axes = [parseMainAxis(channel, model.child)];\n  return axesGroup;\n}\n\n\nfunction getRowGridGroups(model: Model): any[] { // TODO: VgMarks\n  const facetGridConfig = model.config.facet.grid;\n\n  const rowGrid = {\n    name: model.getName('row-grid'),\n    type: 'rule',\n    from: {\n      data: ROW_AXES_DATA_PREFIX + model.dataTable()\n    },\n    encode: {\n      update: {\n        y: {\n          scale: model.scaleName(ROW),\n          field: model.field(ROW)\n        },\n        x: {value: 0, offset: -facetGridConfig.offset},\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset},\n        stroke: {value: facetGridConfig.color},\n        strokeOpacity: {value: facetGridConfig.opacity},\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [rowGrid, {\n    name: model.getName('row-grid-end'),\n    type: 'rule',\n    encode: {\n      update: {\n        y: {field: {group: 'height'}},\n        x: {value: 0, offset: -facetGridConfig.offset},\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset},\n        stroke: {value: facetGridConfig.color},\n        strokeOpacity: {value: facetGridConfig.opacity},\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n\nfunction getColumnGridGroups(model: Model): any { // TODO: VgMarks\n  const facetGridConfig = model.config.facet.grid;\n\n  const columnGrid = {\n    name: model.getName('column-grid'),\n    type: 'rule',\n    from: {\n      data: COLUMN_AXES_DATA_PREFIX + model.dataTable()\n    },\n    encode: {\n      update: {\n        x: {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN)\n        },\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset},\n        stroke: {value: facetGridConfig.color},\n        strokeOpacity: {value: facetGridConfig.opacity},\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [columnGrid,  {\n    name: model.getName('column-grid-end'),\n    type: 'rule',\n    encode: {\n      update: {\n        x: {field: {group: 'width'}},\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset},\n        stroke: {value: facetGridConfig.color},\n        strokeOpacity: {value: facetGridConfig.opacity},\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n","import {Channel} from '../channel';\nimport {defaultConfig, CellConfig, Config} from '../config';\nimport {FieldDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Scale} from '../scale';\nimport {Axis} from '../axis';\nimport {LayerSpec} from '../spec';\nimport {StackProperties} from '../stack';\nimport {FILL_STROKE_CONFIG} from '../mark';\nimport {keys, duplicate, mergeDeep, flatten, Dict} from '../util';\nimport {VgData, VgEncodeEntry, isSignalRefDomain, VgScale} from '../vega.schema';\nimport {isUrlData} from '../data';\n\nimport {assembleData, parseLayerData} from './data/data';\nimport {applyConfig, buildModel} from './common';\nimport {assembleLayout, parseLayerLayout} from './layout';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\n\nimport {unionDomains} from './scale/domain';\n\n\nexport class LayerModel extends Model {\n  public readonly children: UnitModel[];\n\n  protected readonly scales: Dict<Scale> = {};\n\n  protected readonly axes: Dict<Axis> = {};\n\n  protected readonly legends: Dict<Legend> = {};\n\n  public readonly config: Config;\n\n  public readonly stack: StackProperties = null;\n\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly height: number;\n\n  constructor(spec: LayerSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    this.width = spec.width;\n    this.height = spec.height;\n\n    this.config = this.initConfig(spec.config, parent);\n    this.children = spec.layer.map((layer, i) => {\n      // we know that the model has to be a unit model because we pass in a unit spec\n      return buildModel(layer, this, this.getName('layer_' + i)) as UnitModel;\n    });\n  }\n\n  private initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config : {});\n  }\n\n  public channelHasField(channel: Channel): boolean {\n    // layer does not have any channels\n    return false;\n  }\n\n  public hasDiscreteScale(channel: Channel) {\n    // since we assume shared scales we can just ask the first child\n    return this.children[0].hasDiscreteScale(channel);\n  }\n\n  public dataTable() {\n    // FIXME: don't just use the first child\n    return this.children[0].dataTable();\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return null; // layer does not have field defs\n  }\n\n  public parseData() {\n    this.children.forEach((child) => {\n      child.parseData();\n    });\n    this.component.data = parseLayerData(this);\n  }\n\n  public parseSelection() {\n    // TODO: @arvind can write this\n    // We might need to split this into compileSelectionData and compileSelectionSignals?\n  }\n\n  public parseLayoutData() {\n    // TODO: correctly union ordinal scales rather than just using the layout of the first child\n    this.children.forEach(child => {\n      child.parseLayoutData();\n    });\n    this.component.layout = parseLayerLayout(this);\n  }\n\n  public parseScale(this: LayerModel) {\n    const model = this;\n\n    const scaleComponent: Dict<VgScale> = this.component.scales = {};\n\n    this.children.forEach(function(child) {\n      child.parseScale();\n\n      // FIXME(#1602): correctly implement independent scale\n      // Also need to check whether the scales are actually compatible, e.g. use the same sort or throw error\n      if (true) { // if shared/union scale\n        keys(child.component.scales).forEach(function(channel) {\n          let childScale = child.component.scales[channel];\n          const modelScale = scaleComponent[channel];\n\n          if (!childScale || isSignalRefDomain(childScale.domain) || (modelScale && isSignalRefDomain(modelScale.domain))) {\n            // TODO: merge signal ref domains\n            return;\n          }\n\n          if (modelScale) {\n            modelScale.domain = unionDomains(modelScale.domain, childScale.domain);\n          } else {\n            scaleComponent[channel] = childScale;\n          }\n\n          // rename child scale to parent scales\n          const scaleNameWithoutPrefix = childScale.name.substr(child.getName('').length);\n          const newName = model.scaleName(scaleNameWithoutPrefix, true);\n          child.renameScale(childScale.name, newName);\n          childScale.name = newName;\n\n          // remove merged scales from children\n          delete child.component.scales[channel];\n        });\n      }\n    });\n  }\n\n  public parseMark() {\n    this.children.forEach(function(child) {\n      child.parseMark();\n    });\n  }\n\n  public parseAxis() {\n    let axisComponent = this.component.axes = {};\n\n    this.children.forEach(function(child) {\n      child.parseAxis();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.axes).forEach(function(channel) {\n          // TODO: support multiple axes for shared scale\n\n          // just use the first axis definition for each channel\n          if (!axisComponent[channel]) {\n            axisComponent[channel] = child.component.axes[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  public parseGridGroup(): void {\n    return null;\n  }\n\n  public parseLegend() {\n    let legendComponent = this.component.legends = {};\n\n    this.children.forEach(function(child) {\n      child.parseLegend();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.legends).forEach(function(channel) {\n          // just use the first legend definition for each channel\n          if (!legendComponent[channel]) {\n            legendComponent[channel] = child.component.legends[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public assembleParentGroupProperties(cellConfig: CellConfig): VgEncodeEntry {\n    return applyConfig({}, cellConfig, FILL_STROKE_CONFIG.concat(['clip']));\n  }\n\n  public assembleSignals(signals: any[]): any[] {\n    return [];\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return [];\n  }\n\n  public assembleScales(): VgScale[] {\n    // combine with scales from children\n    return this.children.reduce((scales, c) => {\n      return scales.concat(c.assembleScales());\n    }, super.assembleScales());\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred to by children data\n    assembleData(this, data);\n    this.children.forEach((child) => {\n      child.assembleData(data);\n    });\n    return data;\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this.children.forEach((child) => {\n      child.assembleLayout(layoutData);\n    });\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return flatten(this.children.map((child) => {\n      return child.assembleMarks();\n    }));\n  }\n\n  public channels(): Channel[] {\n    return [];\n  }\n\n  protected getMapping(): any {\n    return null;\n  }\n\n  public isLayer() {\n    return true;\n  }\n\n  /**\n   * Returns true if the child either has no source defined or uses the same url.\n   * This is useful if you want to know whether it is possible to move a filter up.\n   *\n   * This function can only be called once th child has been parsed.\n   */\n  public compatibleSource(child: UnitModel) {\n    const data = this.data;\n    const childData = child.component.data;\n    const compatible = !childData.source || (data && isUrlData(data) && data.url === childData.source.url);\n    return compatible;\n  }\n}\n","\nimport {Channel, X, Y, ROW, COLUMN} from '../channel';\nimport {LAYOUT} from '../data';\nimport {hasDiscreteDomain} from '../scale';\nimport {Formula} from '../transform';\nimport {extend, keys, StringSet} from '../util';\nimport {VgData} from '../vega.schema';\n\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport interface LayoutComponent {\n  width: SizeComponent;\n  height: SizeComponent;\n}\n\nexport interface SizeComponent {\n  /** Field that we need to calculate distinct */\n  distinct: StringSet;\n\n  /** Array of formulas */\n  formula: Formula[];\n}\n\nexport function assembleLayout(model: Model, layoutData: VgData[]): VgData[] {\n  const layoutComponent = model.component.layout;\n  if (!layoutComponent.width && !layoutComponent.height) {\n    return layoutData; // Do nothing\n  }\n\n  if (true) { // if both are shared scale, we can simply merge data source for width and for height\n    const distinctFields = keys(extend(layoutComponent.width.distinct, layoutComponent.height.distinct));\n    const formula = layoutComponent.width.formula.concat(layoutComponent.height.formula)\n      .map(f => extend({type: 'formula'}, f));\n\n    return [\n      distinctFields.length > 0 ? {\n        name: model.dataName(LAYOUT),\n        source: model.dataTable(),\n        transform: [{\n          type: 'aggregate',\n          fields: distinctFields,\n          ops: distinctFields.map(() => 'distinct')\n        } as any].concat(formula)\n      } : {\n        name: model.dataName(LAYOUT),\n        values: [{}],\n        transform: formula\n      }\n    ];\n  }\n  // FIXME: implement\n  // otherwise, we need to join width and height (cross)\n}\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport function parseUnitLayout(model: UnitModel): LayoutComponent {\n  return {\n    width: parseUnitSizeLayout(model, X),\n    height: parseUnitSizeLayout(model, Y)\n  };\n}\n\nfunction parseUnitSizeLayout(model: UnitModel, channel: Channel): SizeComponent {\n  return {\n    distinct: getDistinct(model, channel),\n    formula: [{\n      as: model.channelSizeName(channel),\n      expr: unitSizeExpr(model, channel)\n    }]\n  };\n}\n\nexport function unitSizeExpr(model: UnitModel, channel: Channel): string {\n  const scale = model.scale(channel);\n  if (scale) {\n\n    if (hasDiscreteDomain(scale.type) && scale.rangeStep) {\n      // If the spec has top level size or specified rangeStep = fit, it will be undefined here.\n\n      const cardinality = cardinalityExpr(model, channel);\n      const paddingOuter = scale.paddingOuter !== undefined ? scale.paddingOuter : scale.padding;\n      const paddingInner = scale.type === 'band' ?\n        // only band has real paddingInner\n        (scale.paddingInner !== undefined ? scale.paddingInner : scale.padding) :\n        // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n        1;\n\n      let space = cardinality +\n        (paddingInner ? ` - ${paddingInner}` : '') +\n        (paddingOuter ? ` + 2*${paddingOuter}` : '');\n\n      // This formula is equivalent to\n      // space = count - inner + outer * 2\n      // range = rangeStep * (space > 0 ? space : 0)\n      // in https://github.com/vega/vega-encode/blob/master/src/Scale.js#L112\n      return `max(${space}, 0) * ${scale.rangeStep}`;\n    }\n  }\n  return (channel === X ? model.width : model.height) + '';\n}\n\nexport function parseFacetLayout(model: FacetModel): LayoutComponent {\n  return {\n    width: parseFacetSizeLayout(model, COLUMN),\n    height: parseFacetSizeLayout(model, ROW)\n  };\n}\n\nfunction parseFacetSizeLayout(model: FacetModel, channel: Channel): SizeComponent {\n  const childLayoutComponent = model.child.component.layout;\n  const sizeType = channel === ROW ? 'height' : 'width';\n  const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n  if (true) { // assume shared scale\n    // For shared scale, we can simply merge the layout into one data source\n\n    const distinct = extend(getDistinct(model, channel), childSizeComponent.distinct);\n    const formula = childSizeComponent.formula.concat([{\n      as: model.channelSizeName(channel),\n      expr: facetSizeFormula(model, channel, model.child.channelSizeName(channel))\n    }]);\n\n    delete childLayoutComponent[sizeType];\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n  // FIXME implement independent scale as well\n  // TODO: - also consider when children have different data source\n}\n\nfunction facetSizeFormula(model: FacetModel, channel: Channel, innerSize: string) {\n  if (model.channelHasField(channel)) {\n    return '(datum[\"' + innerSize + '\"] + ' + model.spacing(channel) + ')' + ' * ' + cardinalityExpr(model, channel);\n  } else {\n    return 'datum[\"' + innerSize + '\"] + ' + model.config.scale.facetSpacing; // need to add outer padding for facet\n  }\n}\n\nexport function parseLayerLayout(model: LayerModel): LayoutComponent {\n  return {\n    width: parseLayerSizeLayout(model, X),\n    height: parseLayerSizeLayout(model, Y)\n  };\n}\n\nfunction parseLayerSizeLayout(model: LayerModel, channel: Channel): SizeComponent {\n  if (true) {\n    // For shared scale, we can simply merge the layout into one data source\n    // TODO: don't just take the layout from the first child\n\n    const childLayoutComponent = model.children[0].component.layout;\n    const sizeType = channel === Y ? 'height' : 'width';\n    const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n    const distinct = childSizeComponent.distinct;\n    const formula: Formula[] = [{\n      as: model.channelSizeName(channel),\n      expr: childSizeComponent.formula[0].expr\n    }];\n\n    model.children.forEach((child) => {\n      delete child.component.layout[sizeType];\n    });\n\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n}\n\nfunction getDistinct(model: Model, channel: Channel): StringSet {\n  if (model.channelHasField(channel) && model.hasDiscreteScale(channel)) {\n    const scale = model.scale(channel);\n    if (hasDiscreteDomain(scale.type) && !(scale.domain instanceof Array)) {\n      // if explicit domain is declared, use array length\n      const distinctField = model.field(channel);\n      let distinct: StringSet = {};\n      distinct[distinctField] = true;\n      return distinct;\n    }\n  }\n  return {};\n}\n\nexport function cardinalityExpr(model: Model, channel: Channel):string {\n  const scale = model.scale(channel);\n  if (scale.domain instanceof Array) {\n    return scale.domain.length + '';\n  }\n\n  return model.field(channel, {datum: true, prefix: 'distinct'});\n}\n","import {COLOR, SHAPE, Channel} from '../../channel';\nimport {FieldDef, isValueDef} from '../../fielddef';\nimport {AREA, BAR, TICK, TEXT, LINE, POINT, CIRCLE, SQUARE, FILL_STROKE_CONFIG} from '../../mark';\nimport {TEMPORAL} from '../../type';\nimport {extend, keys, without} from '../../util';\n\nimport {VgValueRef} from '../../vega.schema';\n\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport {UnitModel} from '../unit';\n\nexport function symbols(fieldDef: FieldDef, symbolsSpec: any, model: UnitModel, channel: Channel) {\n  let symbols:any = {};\n  const mark = model.mark();\n\n  switch (mark) {\n    case BAR:\n    case TICK:\n    case TEXT:\n      symbols.shape = {value: 'square'};\n      break;\n    case CIRCLE:\n    case SQUARE:\n      symbols.shape = {value: mark};\n      break;\n    case POINT:\n    case LINE:\n    case AREA:\n      // use default circle\n      break;\n  }\n\n  const cfg = model.config;\n  const filled = model.markDef.filled;\n\n  let config = channel === COLOR ?\n      /* For color's legend, do not set fill (when filled) or stroke (when unfilled) property from config because the legend's `fill` or `stroke` scale should have precedence */\n      without(FILL_STROKE_CONFIG, [ filled ? 'fill' : 'stroke', 'strokeDash', 'strokeDashOffset']) :\n      /* For other legend, no need to omit. */\n      FILL_STROKE_CONFIG;\n\n  config = without(config, ['strokeDash', 'strokeDashOffset']);\n\n  applyMarkConfig(symbols, model, config);\n\n  if (filled) {\n    symbols.strokeWidth = {value: 0};\n  }\n\n  let value: VgValueRef;\n  const colorDef = model.encoding.color;\n  if (isValueDef(colorDef)) {\n    value = {value: colorDef.value};\n  }\n\n  if (value !== undefined) {\n    // apply the value\n    if (filled) {\n      symbols.fill = value;\n    } else {\n      symbols.stroke = value;\n    }\n  } else if (channel !== COLOR) {\n    // For non-color legend, apply color config if there is no fill / stroke config.\n    // (For color, do not override scale specified!)\n    symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||\n      {value: cfg.mark.color};\n  }\n\n  if (symbols.fill === undefined) {\n    // fall back to mark config colors for legend fill\n    if (cfg.mark.fill !== undefined) {\n      symbols.fill = {value: cfg.mark.fill};\n    } else if (cfg.mark.stroke !== undefined) {\n      symbols.stroke = {value: cfg.mark.stroke};\n    }\n  }\n\n  const shapeDef = model.encoding.shape;\n  if (channel !== SHAPE) {\n    if (isValueDef(shapeDef)) {\n      symbols.shape = {value: shapeDef.value};\n    }\n  }\n\n  symbols = extend(symbols, symbolsSpec || {});\n\n  return keys(symbols).length > 0 ? symbols : undefined;\n}\n\nexport function labels(fieldDef: FieldDef, labelsSpec: any, model: UnitModel, channel: Channel) {\n  const legend = model.legend(channel);\n  const config = model.config;\n\n  let labels:any = {};\n\n  if (fieldDef.type === TEMPORAL) {\n    labelsSpec = extend({\n      text: {\n        signal: timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat)\n      }\n    }, labelsSpec || {});\n  }\n\n  labels = extend(labels, labelsSpec || {});\n\n  return keys(labels).length > 0 ? labels : undefined;\n}\n\n","import {COLOR, SIZE, SHAPE, OPACITY, Channel} from '../../channel';\nimport {keys, Dict} from '../../util';\nimport {VgLegend} from '../../vega.schema';\nimport {Legend, LEGEND_PROPERTIES} from '../../legend';\n\nimport {Model} from '../model';\nimport {numberFormat} from '../common';\nimport {UnitModel} from '../unit';\n\nimport * as encode from './encode';\nimport * as rules from './rules';\n\nexport function parseLegendComponent(model: UnitModel): Dict<VgLegend> {\n  return [COLOR, SIZE, SHAPE, OPACITY].reduce(function(legendComponent, channel) {\n    if (model.legend(channel)) {\n      legendComponent[channel] = parseLegend(model, channel);\n    }\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: Channel): VgLegend {\n  // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels\n  switch (channel) {\n    case COLOR:\n      const scale = model.scaleName(COLOR);\n      return model.markDef.filled ? {fill: scale} : {stroke: scale};\n    case SIZE:\n      return {size: model.scaleName(SIZE)};\n    case SHAPE:\n      return {shape: model.scaleName(SHAPE)};\n    case OPACITY:\n      return {opacity: model.scaleName(OPACITY)};\n  }\n  return null;\n}\n\nexport function parseLegend(model: UnitModel, channel: Channel): VgLegend {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  let def: VgLegend = getLegendDefWithScale(model, channel);\n\n  LEGEND_PROPERTIES.forEach(function(property) {\n    const value = getSpecifiedOrDefaultValue(property, legend, channel, model);\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const encodeSpec = legend.encode || {};\n  ['labels', 'legend', 'title', 'symbols'].forEach(function(part) {\n    let value = encode[part] ?\n      encode[part](fieldDef, encodeSpec[part], model, channel) : // apply rule\n      encodeSpec[part]; // no rule -- just default values\n    if (value !== undefined && keys(value).length > 0) {\n      def.encode = def.encode || {};\n      def.encode[part] = {update: value};\n    }\n  });\n\n  return def;\n}\n\nfunction getSpecifiedOrDefaultValue(property: keyof VgLegend, specifiedLegend: Legend, channel: Channel, model: Model) {\n  const fieldDef = model.fieldDef(channel);\n\n  switch (property) {\n    case 'format':\n      return numberFormat(fieldDef, specifiedLegend.format, model.config, channel);\n    case 'title':\n      return rules.title(specifiedLegend, fieldDef, model.config);\n    case 'values':\n      return rules.values(specifiedLegend);\n    case 'type':\n      return rules.type(specifiedLegend, fieldDef.type, channel, model.scale(channel).type);\n  }\n\n  // Otherwise, return specified property.\n  return specifiedLegend[property];\n}\n\n","import {COLOR, Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {FieldDef} from '../../fielddef';\nimport {Legend} from '../../legend';\nimport {title as fieldTitle} from '../../fielddef';\nimport {contains} from '../../util';\nimport {ScaleType, isBinScale} from '../../scale';\nimport {Type} from '../../type';\n\nexport function title(legend: Legend, fieldDef: FieldDef, config: Config) {\n  if (legend.title !== undefined) {\n    return legend.title;\n  }\n\n  return fieldTitle(fieldDef, config);\n}\n\nexport function values(legend: Legend) {\n  const vals = legend.values;\n  if (vals && isDateTime(vals[0])) {\n    return (vals as DateTime[]).map((dt) => {\n      // normalize = true as end user won't put 0 = January\n      return timestamp(dt, true);\n    });\n  }\n  return vals;\n}\n\nexport function type(legend: Legend, type: Type, channel: Channel, scaleType: ScaleType) {\n  if (legend.type) {\n    return legend.type;\n  }\n  if (channel === COLOR && ((type === 'quantitative' && !isBinScale(scaleType)) || (type === 'temporal' && contains<ScaleType>(['time', 'utc'], scaleType)))) {\n    return 'gradient';\n  }\n  return undefined;\n}\n","import * as mixins from './mixins';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\n\nexport const area: MarkCompiler = {\n  vgMark: 'area',\n  role: undefined,\n  encodeEntry: (model: UnitModel) => {\n    const orient = model.markDef.orient;\n\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin'),\n\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.markDefProperties(model.markDef, ['orient', 'interpolate', 'tension']),\n    };\n  }\n};\n","import {X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {isFieldDef} from '../../fielddef';\nimport {Scale, ScaleType, isBinScale} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport * as log from '../../log';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport * as mixins from './mixins';\nimport {UnitModel} from '../unit';\nimport {VgValueRef} from '../../vega.schema';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const bar: MarkCompiler = {\n  vgMark: 'rect',\n  role: 'bar',\n  encodeEntry: (model: UnitModel) => {\n    const stack = model.stack;\n    return {\n      ...x(model, stack),\n      ...y(model, stack),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model)\n    };\n  }\n};\n\nfunction x(model: UnitModel, stack: StackProperties): VgEncodeEntry {\n  const {config} = model;\n  const orient = model.markDef.orient;\n  const sizeDef = model.encoding.size;\n\n  const xDef = model.encoding.x;\n  const xScaleName = model.scaleName(X);\n  const xScale = model.scale(X);\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (orient === 'horizontal') {\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin'),\n    };\n  } else { // vertical\n    if (isFieldDef(xDef)) {\n      if (!sizeDef && isBinScale(xScale.type)) {\n        return mixins.binnedPosition('x', model, config.bar.binSpacing);\n      } else if (xScale.type === ScaleType.BAND) {\n        return mixins.bandPosition('x', model);\n      }\n    }\n    // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n\n    return mixins.centeredBandPosition('x', model,\n      {...ref.midX(config), offset: 1}, // TODO: config.singleBarOffset,\n      defaultSizeRef(xScaleName, model.scale(X), config)\n    );\n  }\n}\n\nfunction y(model: UnitModel, stack: StackProperties) {\n  const {config, encoding} = model;\n  const orient = model.markDef.orient;\n  const sizeDef = encoding.size;\n\n  const yDef = encoding.y;\n  const yScaleName = model.scaleName(Y);\n  const yScale = model.scale(Y);\n  // y, y2 & height -- we must specify two of these in all conditions\n  if (orient === 'vertical') {\n    return {\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin'),\n    };\n  } else {\n    if (isFieldDef(yDef)) {\n      if (yDef.bin && !sizeDef) {\n        return mixins.binnedPosition('y', model, config.bar.binSpacing);\n      } else if (yScale.type === ScaleType.BAND) {\n        return mixins.bandPosition('y', model);\n      }\n    }\n    return mixins.centeredBandPosition('y', model, ref.midY(config), defaultSizeRef(yScaleName, model.scale(Y), config));\n  }\n}\n\nfunction defaultSizeRef(scaleName: string, scale: Scale, config: Config): VgValueRef {\n  if (config.bar.discreteBandSize) {\n    return {value: config.bar.discreteBandSize};\n  }\n\n  if (scale) {\n    if (scale.type === ScaleType.POINT) {\n      if (scale.rangeStep !== null) {\n        return {value: scale.rangeStep - 1};\n      }\n      log.warn(log.message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL);\n    } else if (scale.type === ScaleType.BAND) {\n      return ref.band(scaleName);\n    } else { // non-ordinal scale\n      return {value: config.bar.continuousBandSize};\n    }\n  }\n  if (config.scale.rangeStep && config.scale.rangeStep !== null) {\n    return {value: config.scale.rangeStep - 1};\n  }\n  // TODO: this should depends on cell's width / height?\n  return {value: 20};\n}\n\n","import {Mark, MarkDef, isMarkDef, BAR, AREA, POINT, LINE, TICK, CIRCLE, SQUARE, RECT, RULE, TEXT, Orient} from '../../mark';\nimport {Encoding, isAggregate, channelHasField} from '../../encoding';\nimport * as log from '../../log';\nimport {Dict, contains, some} from '../../util';\nimport {Scale, hasDiscreteDomain} from '../../scale';\nimport {isFieldDef, FieldDef, isContinuous} from '../../fielddef';\nimport {TEMPORAL} from '../../type';\nimport {Config} from '../../config';\nimport {getMarkConfig} from '../common';\nimport {StackProperties} from '../../stack';\nimport {LEVEL_OF_DETAIL_CHANNELS, Channel} from '../../channel';\nimport {isArray} from 'vega-util';\n\nexport function initMarkDef(mark: Mark | MarkDef, encoding: Encoding, scale: Dict<Scale>, config: Config): MarkDef & {filled: boolean} {\n  const markDef = isMarkDef(mark) ? mark : {type: mark};\n\n  const specifiedOrient = markDef.orient || getMarkConfig('orient', markDef.type, config);\n  markDef.orient = orient(markDef.type, encoding, scale, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient,specifiedOrient));\n  }\n\n  return {\n    ...markDef,\n\n    // TODO: filled could be injected to encoding too, but we don't have filled channel yet.\n    // Thus we inject it here for now.\n    filled: filled(markDef.type, config)\n  };\n}\n\n/**\n * Initialize encoding's value with some special default values\n */\nexport function initEncoding(mark: Mark, encoding: Encoding, stacked: StackProperties, config: Config): Encoding {\n  const opacityConfig = getMarkConfig('opacity', mark, config);\n  if (!encoding.opacity && opacityConfig === undefined) {\n    const opacity = defaultOpacity(mark, encoding, stacked);\n    if (opacity !== undefined) {\n      encoding.opacity = {value: opacity};\n    }\n  }\n  return encoding;\n}\n\n\nfunction defaultOpacity(mark: Mark, encoding: Encoding, stacked: StackProperties) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding) || channelHasField(encoding, 'detail')) {\n      return 0.7;\n    }\n  }\n  if (mark === BAR && !stacked) {\n    if (some(LEVEL_OF_DETAIL_CHANNELS, (channel) => hasRawField(encoding, channel))) {\n      return 0.7;\n    }\n  }\n  if (mark === AREA) {\n    return 0.7; // inspired by Tableau\n  }\n  return undefined;\n}\n\nfunction hasRawField(encoding: Encoding, channel: Channel) {\n  const channelDef = encoding[channel];\n  if (isArray(channelDef)) { // detail\n    return some(channelDef, fieldDef => !fieldDef.aggregate);\n  } else if (isFieldDef(channelDef)) {\n    return !channelDef.aggregate;\n  }\n  return false;\n}\n\nfunction filled(mark: Mark, config: Config) {\n  const filledConfig = getMarkConfig('filled', mark, config);\n  return filledConfig !== undefined ? filledConfig : mark !== POINT && mark !== LINE && mark !== RULE;\n}\n\nfunction orient(mark: Mark, encoding: Encoding, scale: Dict<Scale>, specifiedOrient: Orient): Orient {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const yIsRange = encoding.y && encoding.y2;\n  const xIsRange = encoding.x && encoding.x2;\n\n  switch (mark) {\n    case TICK:\n      const xScaleType = scale['x'] ? scale['x'].type : null;\n      const yScaleType = scale['y'] ? scale['y'].type : null;\n\n      // Tick is opposite to bar, line, area and never have ranged mark.\n      if (!hasDiscreteDomain(xScaleType) && (\n            !encoding.y ||\n            hasDiscreteDomain(yScaleType) ||\n            (isFieldDef(encoding.y) && encoding.y.bin)\n        )) {\n        return 'vertical';\n      }\n      // y:Q or Ambiguous case, return horizontal\n      return 'horizontal';\n\n    case RULE:\n    case BAR:\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (yIsRange) {\n        return 'vertical';\n      } else if (xIsRange) {\n        return 'horizontal';\n      } else if (mark === RULE) {\n        if (encoding.x && !encoding.y) {\n          return 'vertical';\n        } else if (encoding.y && !encoding.x) {\n          return 'horizontal';\n        }\n      }\n\n      /* tslint:disable */\n    case LINE: // intentional fall through\n      /* tslint:enable */\n      const xIsContinuous = isFieldDef(encoding.x) && isContinuous(encoding.x);\n      const yIsContinuous = isFieldDef(encoding.y) && isContinuous(encoding.y);\n      if (xIsContinuous && !yIsContinuous) {\n        return 'horizontal';\n      } else if (!xIsContinuous && yIsContinuous) {\n        return 'vertical';\n      } else if (xIsContinuous && yIsContinuous) {\n        const xDef = encoding.x as FieldDef; // we can cast here since they are surely fieldDef\n        const yDef = encoding.y as FieldDef;\n\n        const xIsTemporal = xDef.type === TEMPORAL;\n        const yIsTemporal = yDef.type === TEMPORAL;\n\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xIsTemporal && !yIsTemporal) {\n          return 'vertical';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return 'horizontal';\n        }\n\n        if (!xDef.aggregate && !!yDef.aggregate) {\n          return 'vertical';\n        } else if (!!xDef.aggregate && !yDef.aggregate) {\n          return 'horizontal';\n        }\n\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        if (!(mark === LINE && encoding.order)) {\n          // Except for connected scatterplot, we should log warning for unclear orientation of QxQ plots.\n          log.warn(log.message.unclearOrientContinuous(mark));\n        }\n        return 'vertical';\n      } else {\n        // For Discrete x Discrete case, return undefined.\n        log.warn(log.message.unclearOrientDiscreteOrEmpty(mark));\n        return undefined;\n      }\n  }\n  return 'vertical';\n}\n","import * as mixins from './mixins';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\n\nexport const line: MarkCompiler = {\n  vgMark: 'line',\n  role: undefined,\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'strokeWidth'  // VL's line size is strokeWidth\n      }),\n      ...mixins.markDefProperties(model.markDef, ['interpolate', 'tension'])\n    };\n  }\n};\n","import {LEVEL_OF_DETAIL_CHANNELS} from '../../channel';\nimport {AREA, LINE} from '../../mark';\nimport {contains} from '../../util';\n\nimport {MarkCompiler} from './base';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {line} from './line';\nimport {point, circle, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nimport {FacetModel} from '../facet';\nimport {UnitModel} from '../unit';\n\nconst markCompiler: {[type: string]: MarkCompiler} = {\n  area: area,\n  bar: bar,\n  line: line,\n  point: point,\n  text: text,\n  tick: tick,\n  rect: rect,\n  rule: rule,\n  circle: circle,\n  square: square\n};\n\nexport function parseMark(model: UnitModel): any[] {\n  if (contains([LINE, AREA], model.mark())) {\n    return parsePathMark(model);\n  } else {\n    return parseNonPathMark(model);\n  }\n}\n\n// FIXME: maybe this should not be here.  Need re-think and refactor, esp. after having all composition in.\nfunction dataFrom(model: UnitModel): string {\n  const parent = model.parent;\n  if (parent && parent.isFacet()) {\n    return (parent as FacetModel).facetedTable();\n  }\n  if (model.stack) {\n    return model.dataName('stacked');\n  }\n  return model.dataTable();\n}\n\nconst FACETED_PATH_PREFIX = 'faceted-path-';\n\nfunction parsePathMark(model: UnitModel) {\n  const mark = model.mark();\n  // FIXME: replace this with more general case for composition\n  const details = detailFields(model);\n\n  let pathMarks: any = [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      // If has subfacet for line/area group, need to use faceted data from below.\n      // FIXME: support sorting path order (in connected scatterplot)\n      from: {data: (details.length > 0 ? FACETED_PATH_PREFIX : '') + dataFrom(model)},\n      encode: {update: markCompiler[mark].encodeEntry(model)}\n    }\n  ];\n\n  if (details.length > 0) { // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [{\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + dataFrom(model),\n          data: dataFrom(model),\n          groupby: details,\n        }\n      },\n      encode: {\n        update: {\n          width: {field: {group: 'width'}},\n          height: {field: {group: 'height'}}\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nfunction parseNonPathMark(model: UnitModel) {\n  const mark = model.mark();\n\n  const role = markCompiler[mark].role;\n\n  let marks: any[] = []; // TODO: vgMarks\n\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n  marks.push({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark,\n    ...(role? {role} : {}),\n    from: {data: dataFrom(model)},\n    encode: {update: markCompiler[mark].encodeEntry(model)}\n  });\n\n  return marks;\n}\n\n\n\n/**\n * Returns list of detail (group-by) fields\n * that the model's spec contains.\n */\nfunction detailFields(model: UnitModel): string[] {\n  return LEVEL_OF_DETAIL_CHANNELS.reduce(function(details, channel) {\n    if (model.channelHasField(channel) && !model.fieldDef(channel).aggregate) {\n      details.push(model.field(channel));\n    }\n    return details;\n  }, []);\n}\n","import {MarkDef} from '../../mark';\nimport * as util from '../../util';\nimport {VgEncodeEntry, VgValueRef} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {UnitModel} from '../unit';\n\nimport * as ref from './valueref';\n\nimport {NONSPATIAL_SCALE_CHANNELS} from '../../channel';\nimport {Condition} from '../../fielddef';\nimport {predicate} from '../selection/selection';\n\nexport function color(model: UnitModel) {\n  const config = model.config;\n  const filled = model.markDef.filled;\n\n  let e = nonPosition('color', model, {\n    vgChannel: filled ? 'fill' : 'stroke',\n    defaultValue: getMarkConfig('color', model.mark(), config) as string\n  });\n\n  // If there is no fill, always fill symbols\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  if (!e.fill && util.contains(['bar', 'point', 'circle', 'square'], model.mark())) {\n    e.fill = {value: 'transparent'};\n  }\n  return e;\n}\n\nexport function markDefProperties(mark: MarkDef, props: (keyof MarkDef)[]) {\n  return props.reduce((m, prop) => {\n    if (mark[prop]) {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop: string, value: VgValueRef): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: {value: value}};\n  }\n  return undefined;\n}\n\n/**\n * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)\n */\nexport function nonPosition(channel: typeof NONSPATIAL_SCALE_CHANNELS[0], model: UnitModel, opt: {defaultValue?: number | string | boolean, vgChannel?: string, defaultRef?: VgValueRef} = {}): VgEncodeEntry {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {defaultValue, vgChannel} = opt;\n  const defaultRef = opt.defaultRef || (defaultValue !== undefined ? {value: defaultValue} : undefined);\n\n  const channelDef = model.encoding[channel];\n  const valueRef = ref.midPoint(channel, channelDef, model.scaleName(channel), model.scale(channel), defaultRef);\n\n  return wrapCondition(model, channelDef && channelDef.condition, vgChannel || channel, valueRef);\n}\n\n/**\n * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nfunction wrapCondition(model: UnitModel, condition: Condition<any>, vgChannel: string, valueRef: VgValueRef): VgEncodeEntry {\n  if (condition) {\n    const {selection, value} = condition;\n    return {\n      [vgChannel]: [\n        {test: selectionTest(model, selection), value},\n        ...(valueRef !== undefined ? [valueRef] : [])\n      ]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n\nfunction selectionTest(model: UnitModel, selectionName: string) {\n  const negate = selectionName.charAt(0) === '!',\n    name = negate ? selectionName.slice(1) : selectionName;\n  return (negate ? '!' : '') + predicate(model.component.selection[name]);\n}\n\nexport function text(model: UnitModel) {\n  const channelDef = model.encoding.text;\n  return wrapCondition(model, channelDef && channelDef.condition, 'text', ref.text(channelDef, model.config));\n}\n\nexport function bandPosition(channel: 'x'|'y', model: UnitModel) {\n  // TODO: band scale doesn't support size yet\n  const fieldDef = model.encoding[channel];\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    [channel]: ref.fieldRef(fieldDef, scaleName, {}),\n    [sizeChannel]: ref.band(scaleName)\n  };\n}\n\nexport function centeredBandPosition(channel: 'x' | 'y', model: UnitModel, defaultPosRef: VgValueRef, defaultSizeRef: VgValueRef) {\n  const centerChannel: 'xc' | 'yc' = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    ...pointPosition(channel, model, defaultPosRef, centerChannel),\n    ...nonPosition('size', model, {defaultRef: defaultSizeRef, vgChannel: sizeChannel})\n  };\n}\n\nexport function binnedPosition(channel: 'x'|'y', model: UnitModel, spacing: number) {\n  const fieldDef = model.encoding[channel];\n  const scaleName = model.scaleName(channel);\n  if (channel === 'x') {\n    return {\n      x2: ref.bin(fieldDef, scaleName, 'start', spacing),\n      x: ref.bin(fieldDef, scaleName, 'end')\n    };\n  } else {\n    return {\n      y2: ref.bin(fieldDef, scaleName, 'start'),\n      y: ref.bin(fieldDef, scaleName, 'end', spacing)\n    };\n  }\n}\n\n/**\n * Return mixins for point (non-band) position channels.\n */\nexport function pointPosition(channel: 'x'|'y', model: UnitModel, defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax', vgChannel?: 'x'|'y'|'xc'|'yc') {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, stack} = model;\n  const valueRef = ref.stackable(channel, encoding[channel], model.scaleName(channel), model.scale(channel), stack, defaultRef);\n\n  return {\n    [vgChannel || channel]: valueRef\n  };\n}\n\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nexport function pointPosition2(model: UnitModel, defaultRef: 'zeroOrMin' | 'zeroOrMax', channel?: 'x2' | 'y2') {\n  const {encoding, markDef, stack} = model;\n  channel = channel || (markDef.orient === 'horizontal' ? 'x2' : 'y2');\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n\n  const valueRef = ref.stackable2(channel, encoding[baseChannel], encoding[channel], model.scaleName(baseChannel), model.scale(baseChannel), stack, defaultRef);\n  return {[channel]: valueRef};\n}\n","\n\nimport * as mixins from './mixins';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\nimport {getMarkConfig} from '../common';\nimport {Config} from '../../config';\n\nfunction encodeEntry(model: UnitModel, fixedShape?: 'circle' | 'square') {\n  const {config} = model;\n\n  return {\n    ...mixins.pointPosition('x', model, ref.midX(config)),\n    ...mixins.pointPosition('y', model, ref.midY(config)),\n\n    ...mixins.color(model),\n    ...mixins.nonPosition('size', model),\n    ...shapeMixins(model, config, fixedShape),\n    ...mixins.nonPosition('opacity', model)\n  };\n}\n\nexport function shapeMixins(model: UnitModel, config: Config, fixedShape?: 'circle' | 'square') {\n  if (fixedShape) {\n    return {shape: {value: fixedShape}};\n  }\n  return mixins.nonPosition('shape', model, {defaultValue: getMarkConfig('shape', 'point', config) as string});\n}\n\nexport const point: MarkCompiler = {\n  vgMark: 'symbol',\n  role: 'point',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model);\n  }\n};\n\nexport const circle: MarkCompiler = {\n  vgMark: 'symbol',\n  role: 'circle',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'circle');\n  }\n};\n\nexport const square: MarkCompiler = {\n  vgMark: 'symbol',\n  role: 'square',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'square');\n  }\n};\n","import {X, Y} from '../../channel';\nimport {isFieldDef} from '../../fielddef';\nimport {ScaleType, hasDiscreteDomain} from '../../scale';\nimport {RECT} from '../../mark';\nimport * as log from '../../log';\n\nimport * as mixins from './mixins';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\n\nexport const rect: MarkCompiler = {\n  vgMark: 'rect',\n  role: undefined,\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...x(model),\n      ...y(model),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n    };\n  }\n};\n\nfunction x(model: UnitModel) {\n  const xDef = model.encoding.x;\n  const x2Def = model.encoding.x2;\n  const xScale = model.scale(X);\n\n  if (isFieldDef(xDef) && xDef.bin && !x2Def) {\n    return mixins.binnedPosition('x', model, 0);\n  } else if (xScale && hasDiscreteDomain(xScale.type)) {\n    /* istanbul ignore else */\n    if (xScale.type === ScaleType.BAND) {\n      return mixins.bandPosition('x', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, xScale.type));\n    }\n  } else { // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'x2')\n    };\n  }\n}\n\nfunction y(model: UnitModel) {\n  const yDef = model.encoding.y;\n  const y2Def = model.encoding.y2;\n  const yScale = model.scale(Y);\n\n  if (isFieldDef(yDef) && yDef.bin && !y2Def) {\n    return mixins.binnedPosition('y', model, 0);\n  } else if (yScale && hasDiscreteDomain(yScale.type)) {\n    /* istanbul ignore else */\n    if (yScale.type === ScaleType.BAND) {\n      return mixins.bandPosition('y', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, yScale.type));\n    }\n  } else { // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('y', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'y2')\n    };\n  }\n}\n","import {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\n\nexport const rule: MarkCompiler = {\n  vgMark: 'rule',\n  role: undefined,\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMax'),\n\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'strokeWidth'  // VL's rule size is strokeWidth\n      })\n    };\n  }\n};\n","import {X} from '../../channel';\nimport {getMarkConfig} from '../common';\n\nimport * as mixins from './mixins';\nimport {Config} from '../../config';\nimport {ChannelDef, isFieldDef} from '../../fielddef';\nimport {QUANTITATIVE} from '../../type';\nimport {UnitModel} from '../unit';\nimport {VgValueRef} from '../../vega.schema';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\nimport {Encoding, channelHasField} from '../../encoding';\n\nexport const text: MarkCompiler = {\n  vgMark: 'text',\n  role: undefined,\n\n  encodeEntry: (model: UnitModel) => {\n    const {config, encoding} = model;\n    const textDef = encoding.text;\n\n    return {\n      ...mixins.pointPosition('x', model, xDefault(config, textDef)),\n      ...mixins.pointPosition('y', model, ref.midY(config)),\n      ...mixins.text(model),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'fontSize'  // VL's text size is fontSize\n      }),\n      ...mixins.valueIfDefined('align', align(encoding, config))\n    };\n  }\n};\n\nfunction xDefault(config: Config, textDef: ChannelDef): VgValueRef {\n  if (isFieldDef(textDef) && textDef.type === QUANTITATIVE) {\n    return {field: {group: 'width'}, offset: -5};\n  }\n  // TODO: allow this to fit (Be consistent with ref.midX())\n  return {value: config.scale.textXRangeStep / 2};\n}\n\nfunction align(encoding: Encoding, config: Config) {\n  const alignConfig = getMarkConfig('align', 'text', config);\n  if (alignConfig === undefined) {\n    return channelHasField(encoding, X) ? 'center' : 'right';\n  }\n  // If there is a config, Vega-parser will process this already.\n  return undefined;\n}\n","\n\nimport * as mixins from './mixins';\nimport {UnitModel} from '../unit';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const tick: MarkCompiler = {\n  vgMark: 'rect',\n  role: 'tick',\n\n  encodeEntry: (model: UnitModel) => {\n    const {config, markDef} = model;\n    const orient = markDef.orient;\n\n    const vgSizeChannel = orient === 'horizontal' ? 'width' : 'height';\n    const vgThicknessChannel = orient === 'horizontal' ? 'height' : 'width';\n\n    return {\n      ...mixins.pointPosition('x', model, ref.midX(config), 'xc'),\n      ...mixins.pointPosition('y', model, ref.midY(config), 'yc'),\n\n      // size / thickness => width / height\n      ...mixins.nonPosition('size', model, {\n        defaultValue: defaultSize(model),\n        vgChannel: vgSizeChannel\n      }),\n      [vgThicknessChannel]: {value: config.tick.thickness},\n\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n    };\n  }\n};\n\nfunction defaultSize(model: UnitModel): number {\n  const {config} = model;\n  const orient = model.markDef.orient;\n\n  const scaleRangeStep: number | null = (model.scale(orient === 'horizontal' ? 'x' : 'y') || {}).rangeStep;\n\n  if (config.tick.bandSize !== undefined) {\n    return config.tick.bandSize;\n  } else {\n    const rangeStep = scaleRangeStep !== undefined ?\n      scaleRangeStep :\n      config.scale.rangeStep;\n    if (typeof rangeStep !== 'number') {\n      // FIXME consolidate this log\n      throw new Error('Function does not handle non-numeric rangeStep');\n    }\n    return rangeStep / 1.5;\n  }\n}\n","/**\n * Utility files for producing Vega ValueRef for marks\n */\n\nimport {Channel, X, X2, Y, Y2} from '../../channel';\nimport {Config} from '../../config';\nimport {ChannelDef, FieldDef, FieldRefOption, field, isFieldDef, TextFieldDef, ValueDef} from '../../fielddef';\nimport {Scale, ScaleType, hasDiscreteDomain, isBinScale} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {contains} from '../../util';\nimport {VgValueRef} from '../../vega.schema';\nimport {numberFormat, timeFormatExpression} from '../common';\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for stackable x or y\n */\nexport function stackable(channel: 'x' | 'y', channelDef: ChannelDef, scaleName: string, scale: Scale,\n    stack: StackProperties, defaultRef: VgValueRef): VgValueRef {\n  if (channelDef && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'});\n  }\n  return midPoint(channel, channelDef, scaleName, scale, defaultRef);\n}\n\n/**\n * @return Vega ValueRef for stackable x2 or y2\n */\nexport function stackable2(channel: 'x2' | 'y2', aFieldDef: FieldDef, a2fieldDef: FieldDef, scaleName: string, scale: Scale,\n    stack: StackProperties, defaultRef: VgValueRef): VgValueRef {\n  if (aFieldDef && stack &&\n      // If fieldChannel is X and channel is X2 (or Y and Y2)\n      channel.charAt(0) === stack.fieldChannel.charAt(0)\n      ) {\n    return fieldRef(aFieldDef, scaleName, {suffix: 'start'});\n  }\n  return midPoint(channel, a2fieldDef, scaleName, scale, defaultRef);\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin(fieldDef: FieldDef, scaleName: string, side: 'start' | 'end',  offset?: number) {\n  return fieldRef(fieldDef, scaleName, {binSuffix: side}, offset);\n}\n\nexport function fieldRef(fieldDef: FieldDef, scaleName: string, opt: FieldRefOption, offset?: number | VgValueRef): VgValueRef {\n  let ref: VgValueRef = {\n    scale: scaleName,\n    field: field(fieldDef, opt),\n  };\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\n\nexport function band(scaleName: string, band: number|boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\n/**\n * Signal that returns the middle of a bin. Should only be used with x and y.\n */\nfunction binMidSignal(fieldDef: FieldDef, scaleName: string) {\n  return {\n    signal: `(` +\n      `scale(\"${scaleName}\", ${field(fieldDef, {binSuffix: 'start', datum: true})})` +\n      ` + ` +\n      `scale(\"${scaleName}\", ${field(fieldDef, {binSuffix: 'end', datum: true})})`+\n    `)/2`\n  };\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(channel: Channel, channelDef: ChannelDef, scaleName: string, scale: Scale,\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax'): VgValueRef {\n  // TODO: datum support\n\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldDef(channelDef)) {\n      if (isBinScale(scale.type)) {\n        // Use middle only for x an y to place marks in the center between start and end of the bin range.\n        // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n        if (contains(['x', 'y'], channel)) {\n          return binMidSignal(channelDef, scaleName);\n        }\n        return fieldRef(channelDef, scaleName, {binSuffix: 'start'});\n      }\n\n      if (hasDiscreteDomain(scale.type)) {\n        if (scale.type === 'band') {\n          // For band, to get mid point, need to offset by half of the band\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, band(scaleName, 0.5));\n        }\n        return fieldRef(channelDef, scaleName, {binSuffix: 'range'});\n      } else {\n        return fieldRef(channelDef, scaleName, {}); // no need for bin suffix\n      }\n    } else if (channelDef.value) {\n      return {value: channelDef.value};\n    } else {\n      throw new Error('FieldDef without field or value.'); // FIXME add this to log.message\n    }\n  }\n\n  if (defaultRef === 'zeroOrMin') {\n    /* istanbul ignore else */\n    if (channel === X || channel === X2) {\n      return zeroOrMinX(scaleName, scale);\n    } else if (channel === Y || channel === Y2) {\n      return zeroOrMinY(scaleName, scale);\n    } else {\n      throw new Error(`Unsupported channel ${channel} for base function`); // FIXME add this to log.message\n    }\n  } else if (defaultRef === 'zeroOrMax') {\n    /* istanbul ignore else */\n    if (channel === X || channel === X2) {\n      return zeroOrMaxX(scaleName, scale);\n    } else if (channel === Y || channel === Y2) {\n      return zeroOrMaxY(scaleName, scale);\n    } else {\n      throw new Error(`Unsupported channel ${channel} for base function`); // FIXME add this to log.message\n    }\n  }\n  return defaultRef;\n}\n\nexport function text(textDef: TextFieldDef | ValueDef<any>, config: Config): VgValueRef {\n  // text\n  if (textDef) {\n    if (isFieldDef(textDef)) {\n      if (textDef.type === 'quantitative') {\n        // FIXME: what happens if we have bin?\n        const format = numberFormat(textDef, textDef.format, config, 'text');\n        return {\n          signal: `format(${field(textDef, {datum: true})}, '${format}')`\n        };\n      } else if (textDef.type === 'temporal') {\n        return {\n          signal: timeFormatExpression(field(textDef, {datum: true}), textDef.timeUnit, textDef.format, config.text.shortTimeLabels, config.timeFormat)\n        };\n      } else {\n        return {field: textDef.field};\n      }\n    } else if (textDef.value) {\n      return {value: textDef.value};\n    }\n  }\n  return {value: config.text.text};\n}\n\nexport function midX(config: Config): VgValueRef {\n\n  if (typeof config.scale.rangeStep === 'string') {\n    // TODO: For fit-mode, use middle of the width\n    throw new Error('midX can not handle string rangeSteps');\n  }\n  return {value: config.scale.rangeStep / 2};\n}\n\nexport function midY(config: Config): VgValueRef {\n  if (typeof config.scale.rangeStep === 'string') {\n    // TODO: For fit-mode, use middle of the width\n    throw new Error('midX can not handle string rangeSteps');\n  }\n  return {value: config.scale.rangeStep / 2};\n}\n\nfunction zeroOrMinX(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the x-axis\n  return {value: 0};\n}\n\n/**\n * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist\n */\nfunction zeroOrMaxX(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  return {field: {group: 'width'}};\n}\n\nfunction zeroOrMinY(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the y-axis\n  return {field: {group: 'height'}};\n}\n\n/**\n * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist\n */\nfunction zeroOrMaxY(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the y-axis\n  return {value: 0};\n}\n","import * as log from '../log';\n\nimport {Axis} from '../axis';\nimport {Channel, X, COLUMN} from '../channel';\nimport {Config, CellConfig} from '../config';\nimport {Data, DataSourceType, isNamedData, SOURCE} from '../data';\nimport {reduce, forEach} from '../encoding';\nimport {FieldDef, FieldRefOption, field, isFieldDef, ChannelDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Scale, hasDiscreteDomain} from '../scale';\nimport {SortField, SortOrder} from '../sort';\nimport {BaseSpec, Padding} from '../spec';\nimport {Transform} from '../transform';\nimport {extend, vals, Dict} from '../util';\nimport {VgData, VgEncodeEntry, VgScale, VgAxis, VgLegend} from '../vega.schema';\nimport {Formula} from '../transform';\nimport {OneOfFilter, EqualFilter, RangeFilter} from '../filter';\n\nimport {DataComponent} from './data/data';\nimport {LayoutComponent} from './layout';\nimport {StackProperties} from '../stack';\n\nimport {SelectionComponent} from './selection/selection';\n\n/**\n * Composable Components that are intermediate results of the parsing phase of the\n * compilations.  These composable components will be assembled in the last\n * compilation step.\n */\nexport interface Component {\n  data: DataComponent;\n  layout: LayoutComponent;\n  scales: Dict<VgScale>;\n  selection: Dict<SelectionComponent>;\n\n  /** Dictionary mapping channel to VgAxis definition */\n  axes: Dict<VgAxis[]>;\n\n  /** Dictionary mapping channel to VgLegend definition */\n  legends: Dict<VgLegend>;\n\n  /** Dictionary mapping channel to axis mark group for facet and concat */\n  axisGroups: Dict<VgEncodeEntry>;\n\n  /** Dictionary mapping channel to grid mark group for facet (and concat?) */\n  gridGroups: Dict<VgEncodeEntry[]>;\n\n  mark: VgEncodeEntry[];\n}\n\nexport class NameMap implements NameMapInterface {\n  private nameMap: Dict<string>;\n\n  constructor() {\n    this.nameMap = {};\n  }\n\n  public rename(oldName: string, newName: string) {\n    this.nameMap[oldName] = newName;\n  }\n\n\n  public has(name: string): boolean {\n    return this.nameMap[name] !== undefined;\n  }\n\n  public get(name: string): string {\n    // If the name appears in the _nameMap, we need to read its new name.\n    // We have to loop over the dict just in case the new name also gets renamed.\n    while (this.nameMap[name]) {\n      name = this.nameMap[name];\n    }\n\n    return name;\n  }\n}\n\nexport interface NameMapInterface {\n  rename(oldname: string, newName: string): void;\n  has(name: string): boolean;\n  get(name: string): string;\n}\n\nexport abstract class Model {\n  public readonly parent: Model;\n  protected readonly name: string;\n  public readonly description: string;\n  public readonly padding: Padding;\n\n  public readonly data: Data;\n\n  /** Name map for data sources, which can be renamed by a model's parent. */\n  protected dataNameMap: NameMapInterface;\n\n  /** Name map for scales, which can be renamed by a model's parent. */\n  protected scaleNameMap: NameMapInterface;\n\n  /** Name map for size, which can be renamed by a model's parent. */\n  protected sizeNameMap: NameMapInterface;\n\n  protected readonly transform: Transform;\n  protected abstract readonly scales: Dict<Scale> = {};\n\n  protected abstract readonly axes: Dict<Axis> = {};\n\n  protected abstract readonly legends: Dict<Legend> = {};\n\n  public abstract readonly config: Config;\n\n  public component: Component;\n\n  public abstract readonly children: Model[] = [];\n\n  public abstract stack: StackProperties;\n\n  constructor(spec: BaseSpec, parent: Model, parentGivenName: string) {\n    this.parent = parent;\n\n    // If name is not provided, always use parent's givenName to avoid name conflicts.\n    this.name = spec.name || parentGivenName;\n\n    // Shared name maps\n    this.dataNameMap = parent ? parent.dataNameMap : new NameMap();\n    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();\n    this.sizeNameMap = parent ? parent.sizeNameMap : new NameMap();\n\n    this.data = spec.data;\n\n    this.description = spec.description;\n    this.padding = spec.padding;\n    this.transform = spec.transform;\n\n    if (spec.transform) {\n      if (spec.transform.filterInvalid === undefined &&\n          spec.transform['filterNull'] !== undefined) {\n        spec.transform.filterInvalid = spec.transform['filterNull'];\n        log.warn(log.message.DEPRECATED_FILTER_NULL);\n      }\n    }\n\n    this.component = {data: null, layout: null, mark: null, scales: null, axes: null, axisGroups: null, gridGroups: null, legends: null, selection: null};\n  }\n\n\n  public parse() {\n    this.parseData();\n    this.parseLayoutData();\n    this.parseScale(); // depends on data name\n    this.parseSelection();\n    this.parseAxis(); // depends on scale name\n    this.parseLegend(); // depends on scale name\n    this.parseAxisGroup(); // depends on child axis\n    this.parseGridGroup();\n    this.parseMark(); // depends on data name and scale name, axisGroup, gridGroup and children's scale, axis, legend and mark.\n  }\n\n  public abstract parseData(): void;\n\n  public abstract parseSelection(): void;\n\n  public abstract parseLayoutData(): void;\n\n  public abstract parseScale(): void;\n\n  public abstract parseMark(): void;\n\n  public abstract parseAxis(): void;\n\n  public abstract parseLegend(): void;\n\n  // TODO: revise if these two methods make sense for shared scale concat\n  public abstract parseAxisGroup(): void;\n  public abstract parseGridGroup(): void;\n\n  public abstract assembleSignals(signals: any[]): any[];\n\n  public abstract assembleSelectionData(data: VgData[]): VgData[];\n  public abstract assembleData(data: VgData[]): VgData[];\n\n  public abstract assembleLayout(layoutData: VgData[]): VgData[];\n\n  public assembleScales(): VgScale[] {\n    // FIXME: write assembleScales() in scale.ts that\n    // help assemble scale domains with scale signature as well\n    return vals(this.component.scales);\n  }\n\n  public abstract assembleMarks(): any[]; // TODO: VgMarkGroup[]\n\n  public assembleAxes(): VgAxis[] {\n    return [].concat.apply([], vals(this.component.axes));\n  }\n\n  public assembleLegends(): VgLegend[] {\n    return vals(this.component.legends);\n  }\n\n  public assembleGroup() {\n    let group: VgEncodeEntry = {};\n\n    const signals = this.assembleSignals(group.signals || []);\n    if (signals.length > 0) {\n      group.signals = signals;\n    }\n\n    // TODO: consider if we want scales to come before marks in the output spec.\n    group.marks = this.assembleMarks();\n    const scales = this.assembleScales();\n    if (scales.length > 0) {\n      group.scales = scales;\n    }\n\n    const axes = this.assembleAxes();\n    if (axes.length > 0) {\n      group.axes = axes;\n    }\n\n    const legends = this.assembleLegends();\n    if (legends.length > 0) {\n      group.legends = legends;\n    }\n\n    return group;\n  }\n\n  public abstract assembleParentGroupProperties(cellConfig: CellConfig): VgEncodeEntry;\n\n  public abstract channels(): Channel[];\n\n  protected abstract getMapping(): {[key: string]: any};\n\n  public reduceFieldDef<T, U>(f: (acc: U, fd: FieldDef, c: Channel) => U, init: T, t?: any) {\n    return reduce(this.getMapping(), (acc:U , cd: ChannelDef, c: Channel) => {\n      return isFieldDef(cd) ? f(acc, cd, c) : acc;\n    }, init, t);\n  }\n\n  public forEachFieldDef(f: (fd: FieldDef, c: Channel) => void, t?: any) {\n    forEach(this.getMapping(), (cd: ChannelDef, c: Channel) => {\n      if (isFieldDef(cd)) {\n        f(cd, c);\n      }\n    }, t);\n  }\n\n  public hasDescendantWithFieldOnChannel(channel: Channel) {\n    for (let child of this.children) {\n      if (child.isUnit()) {\n        if (child.channelHasField(channel)) {\n          return true;\n        }\n      } else {\n        if (child.hasDescendantWithFieldOnChannel(channel)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public abstract channelHasField(channel: Channel): boolean;\n\n  public getName(text: string, delimiter: string = '_') {\n    if (this.data && text === SOURCE && isNamedData(this.data)) {\n      return this.data.name;\n    }\n    return (this.name ? this.name + delimiter : '') + text;\n  }\n\n  public renameData(oldName: string, newName: string) {\n     this.dataNameMap.rename(oldName, newName);\n  }\n\n  /**\n   * Return the data source name for the given data source type.\n   *\n   * For unit spec, this is always simply the spec.name + '-' + dataSourceType.\n   * We already use the name map so that marks and scales use the correct data.\n   */\n  public dataName(dataSourceType: DataSourceType): string {\n    return this.dataNameMap.get(this.getName(String(dataSourceType)));\n  }\n\n  public renameSize(oldName: string, newName: string) {\n    this.sizeNameMap.rename(oldName, newName);\n  }\n\n  public channelSizeName(channel: Channel): string {\n    return this.sizeName(channel === X || channel === COLUMN ? 'width' : 'height');\n  }\n\n  public sizeName(size: string): string {\n     return this.sizeNameMap.get(this.getName(size, '_'));\n  }\n\n  public abstract dataTable(): string;\n\n  // TRANSFORMS\n  public calculate(): Formula[] {\n    return this.transform ? this.transform.calculate : undefined;\n  }\n\n  public filterInvalid(): boolean {\n    const transform = this.transform || {};\n    if (transform.filterInvalid === undefined) {\n      return this.parent ? this.parent.filterInvalid() : undefined;\n    }\n    return transform.filterInvalid;\n  }\n\n  public filter(): string | OneOfFilter | EqualFilter| RangeFilter | (string | OneOfFilter | EqualFilter| RangeFilter)[] {\n    return this.transform ? this.transform.filter : undefined;\n  }\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public abstract fieldDef(channel: Channel): FieldDef;\n\n  public scale(channel: Channel): Scale {\n    return this.scales[channel];\n  }\n\n  public hasDiscreteScale(channel: Channel) {\n    const scale = this.scale(channel);\n    return scale && hasDiscreteDomain(scale.type);\n  }\n\n  public renameScale(oldName: string, newName: string) {\n    this.scaleNameMap.rename(oldName, newName);\n  }\n\n\n  /**\n   * @return scale name for a given channel after the scale has been parsed and named.\n   */\n  public scaleName(this: Model, originalScaleName: Channel | string, parse?: boolean): string {\n    if (parse) {\n      // During the parse phase always return a value\n      // No need to refer to rename map because a scale can't be renamed\n      // before it has the original name.\n      return this.getName(originalScaleName);\n    }\n\n    // If there is a scale for the channel, it should either\n    // be in the _scale mapping or exist in the name map\n    if (\n        // in the scale map (the scale is not merged by its parent)\n        (this.scale && this.scales[originalScaleName]) ||\n        // in the scale name map (the the scale get merged by its parent)\n        this.scaleNameMap.has(this.getName(originalScaleName))\n      ) {\n      return this.scaleNameMap.get(this.getName(originalScaleName));\n    }\n    return undefined;\n  }\n\n  public sort(channel: Channel): SortField | SortOrder {\n    return (this.getMapping()[channel] || {}).sort;\n  }\n\n  public axis(channel: Channel): Axis {\n    return this.axes[channel];\n  }\n\n  public legend(channel: Channel): Legend {\n    return this.legends[channel];\n  }\n\n  /**\n   * Type checks\n   */\n  public isUnit() {\n    return false;\n  }\n  public isFacet() {\n    return false;\n  }\n  public isLayer() {\n    return false;\n  }\n}\n","import * as log from '../../log';\n\nimport {SHARED_DOMAIN_OPS} from '../../aggregate';\nimport {Channel} from '../../channel';\nimport {SOURCE} from '../../data';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {Domain, hasDiscreteDomain, isBinScale, Scale, ScaleConfig, ScaleType} from '../../scale';\nimport {isSortField} from '../../sort';\nimport {\n  FieldRefUnionDomain,\n  DataRefUnionDomain,\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  isSignalRefDomain,\n  VgDataRef,\n  VgDomain,\n  VgSortField\n} from '../../vega.schema';\n\nimport * as util from '../../util';\n\nimport {Model} from '../model';\nimport {FieldDef} from '../../fielddef';\n\nexport function initDomain(domain: Domain, fieldDef: FieldDef, scale: ScaleType, scaleConfig: ScaleConfig) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scale);\n    if(!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scale);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\n\nexport function parseDomain(model: Model, channel: Channel): VgDomain {\n  const scale = model.scale(channel);\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return unionDomains(parseSingleChannelDomain(scale, model, 'x'), parseSingleChannelDomain(scale, model, 'x2'));\n    } else {\n      return parseSingleChannelDomain(scale, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return unionDomains(parseSingleChannelDomain(scale, model, 'y'), parseSingleChannelDomain(scale, model, 'y2'));\n    } else {\n      return parseSingleChannelDomain(scale, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scale, model, channel);\n}\n\nfunction parseSingleChannelDomain(scale: Scale, model: Model, channel:Channel): VgDomain {\n  const fieldDef = model.fieldDef(channel);\n\n  if (scale.domain && scale.domain !== 'unaggregated') { // explicit value\n    if (isDateTime(scale.domain[0])) {\n      return (scale.domain as DateTime[]).map((dt) => {\n        return timestamp(dt, true);\n      });\n    }\n    return scale.domain;\n  }\n\n  // special case for temporal scale\n  if (fieldDef.type === 'temporal') {\n    return {\n      data: model.dataTable(),\n      field: model.field(channel),\n      sort: {\n        field: model.field(channel),\n        op: 'min'\n      }\n    };\n  }\n\n  // For stack, use STACKED data.\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if(stack.offset === 'normalize') {\n      return [0, 1];\n    }\n    return {\n      data: model.dataName('stacked'),\n      fields: [\n        model.field(channel, {suffix: 'start'}),\n        model.field(channel, {suffix: 'end'})\n      ]\n    };\n  }\n\n  const sort = domainSort(model, channel, scale.type);\n\n  if (scale.domain === 'unaggregated') {\n    return {\n      data: model.dataTable(),\n      fields: [\n        model.field(channel, {aggregate: 'min'}),\n        model.field(channel, {aggregate: 'max'})\n      ]\n    };\n  } else if (fieldDef.bin) { // bin\n    if (isBinScale(scale.type)) {\n      const field = model.getName(fieldDef.field + '_bins');\n      return {signal: `sequence(${field}.start, ${field}.stop + ${field}.step, ${field}.step)`};\n    }\n\n    if (hasDiscreteDomain(scale.type)) {\n      // ordinal bin scale takes domain from bin_range, ordered by bin_start\n      // This is useful for both axis-based scale (x, y, column, and row) and legend-based scale (other channels).\n      return {\n        data: model.dataTable(),\n        field: model.field(channel, {binSuffix: 'range'}),\n        sort: {\n          field: model.field(channel, {binSuffix: 'start'}),\n          op: 'min' // min or max doesn't matter since same _range would have the same _start\n        }\n      };\n    } else { // continuous scales\n      if (channel === 'x' || channel === 'y') {\n        // X/Y position have to include start and end for non-ordinal scale\n        return {\n          data: model.dataTable(),\n          fields: [\n            model.field(channel, {binSuffix: 'start'}),\n            model.field(channel, {binSuffix: 'end'})\n          ]\n        };\n      } else {\n        // TODO: use bin_mid\n        return {\n          data: model.dataTable(),\n          field: model.field(channel, {binSuffix: 'start'})\n        };\n      }\n    }\n  } else if (sort) { // have sort -- only for ordinal\n    return {\n      // If sort by aggregation of a specified sort field, we need to use SOURCE table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.dataTable(): SOURCE,\n      field: model.field(channel),\n      sort: sort\n    };\n  } else {\n    return {\n      data: model.dataTable(),\n      field: model.field(channel),\n    };\n  }\n}\n\nexport function domainSort(model: Model, channel: Channel, scaleType: ScaleType): VgSortField {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  const sort = model.sort(channel);\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    return {\n      op: sort.op,\n      field: sort.field\n    };\n  }\n\n  if (util.contains(['ascending', 'descending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort === 'none'\n  return undefined;\n}\n\n\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef: FieldDef, scaleType: ScaleType): {valid: boolean, reason?: string} {\n  if (!fieldDef.aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) === -1) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(fieldDef.aggregate)\n    };\n  }\n\n  if (fieldDef.type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Scale domains that we can union. We cannot union signal domains we use for\n * binned data because they have to be exactly the same. Otherwise it doesn't\n * make any sense to union.\n */\ntype UnionableDomain = any[] | VgDataRef | DataRefUnionDomain | FieldRefUnionDomain;\n\n/**\n * Convert the domain to an array of data refs or an array of values. Also, throw\n * away sorting information since we always sort the domain when we union two domains.\n */\nfunction normalizeDomain(domain: UnionableDomain): (any[] | VgDataRef)[] {\n  if (util.isArray(domain)) {\n    return [domain];\n  } else if (isDataRefDomain(domain)) {\n    delete domain.sort;\n    return [domain];\n  } else if(isFieldRefUnionDomain(domain)) {\n    return domain.fields.map(d => {\n      return {\n        data: domain.data,\n        field: d\n      };\n    });\n  } else if (isDataRefUnionedDomain(domain)) {\n    return domain.fields.map(d => {\n      if (util.isArray(d)) {\n        return d;\n      }\n      return {\n        field: d.field,\n        data: d.data\n      };\n    });\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVAID_DOMAIN);\n}\n\n/**\n * Union two data domains. A unioned domain is always sorted.\n */\nexport function unionDomains(domain1: VgDomain, domain2: VgDomain): VgDomain {\n  if (isSignalRefDomain(domain1) || isSignalRefDomain(domain2)) {\n    if (!isSignalRefDomain(domain1) || !isSignalRefDomain(domain2) || domain1.signal !== domain2.signal) {\n      throw new Error(log.message.UNABLE_TO_MERGE_DOMAINS);\n    }\n    return domain1;\n  }\n\n  const normalizedDomain1 = normalizeDomain(domain1);\n  const normalizedDomain2 = normalizeDomain(domain2);\n\n  let domains = normalizedDomain1.concat(normalizedDomain2);\n  domains = util.unique(domains, util.hash);\n\n  if (domains.length > 1) {\n    const allData = domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    });\n\n    if (util.unique(allData, x => x).length === 1 && allData[0] !== null) {\n      return {\n        data: allData[0],\n        fields: domains.map(d => (d as VgDataRef).field)\n      };\n    }\n\n    return {fields: domains, sort: true};\n  } else {\n    return domains[0];\n  }\n}\n","import * as log from '../../log';\n\nimport {Config} from '../../config';\nimport {Channel} from '../../channel';\nimport {ScaleFieldDef, FieldDef} from '../../fielddef';\nimport {Mark} from '../../mark';\nimport {Scale, ScaleConfig, scaleTypeSupportProperty, channelScalePropertyIncompatability} from '../../scale';\n\nimport {initDomain} from './domain';\nimport rangeMixins from './range';\nimport * as rules from './rules';\nimport scaleType from './type';\nimport * as util from '../../util';\n\n/**\n * All scale properties except type and all range properties.\n */\nexport const NON_TYPE_RANGE_SCALE_PROPERTIES: (keyof Scale)[] = [\n  // general properties\n  'domain', // For domain, we only copy specified value here.  Default value is determined during parsing phase.\n  'round',\n  // quantitative / time\n  'clamp', 'nice',\n  // quantitative\n  'exponent', 'zero', // zero depends on domain\n  'interpolate',\n  // ordinal\n  'padding', 'paddingInner', 'paddingOuter' // padding\n];\n\n/**\n * Initialize Vega-Lite Scale's properties\n *\n * Note that we have to apply these rules here because:\n * - many other scale and non-scale properties (including layout, mark) depend on scale type\n * - layout depends on padding\n * - range depends on zero and size (width and height) depends on range\n */\nexport default function init(\n    channel: Channel, fieldDef: ScaleFieldDef, config: Config,\n    mark: Mark | undefined, topLevelSize: number | undefined, xyRangeSteps: number[]): Scale {\n  const specifiedScale = (fieldDef || {}).scale || {};\n\n  const scale: Scale = {\n    type: scaleType(\n      specifiedScale.type, channel, fieldDef, mark, topLevelSize !== undefined,\n      specifiedScale.rangeStep, config.scale\n    )\n  };\n\n  // Use specified value if compatible or determine default values for each property\n  NON_TYPE_RANGE_SCALE_PROPERTIES.forEach(function(property) {\n    const specifiedValue = specifiedScale[property];\n\n    const supportedByScaleType = scaleTypeSupportProperty(scale.type, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scale.type, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      const value = getValue(specifiedValue, property, scale, channel, fieldDef, config.scale);\n      if (value !== undefined) { // use the default value\n        scale[property] = value;\n      }\n    }\n  });\n\n  return util.extend(\n    scale,\n    rangeMixins(\n      channel, scale.type, fieldDef.type, specifiedScale, config,\n      scale.zero, mark, topLevelSize, xyRangeSteps\n    )\n  );\n}\n\nfunction getValue(specifiedValue: any, property: keyof Scale, scale: Scale, channel: Channel, fieldDef: FieldDef, scaleConfig: ScaleConfig) {\n  // For domain, we might override specified value\n  if (property === 'domain') {\n    return initDomain(specifiedValue, fieldDef, scale.type, scaleConfig);\n  }\n\n  // Other properties, no overriding default values\n  if (specifiedValue !== undefined) {\n    return specifiedValue;\n  }\n  return getDefaultValue(property, scale, channel, fieldDef, scaleConfig);\n}\n\nfunction getDefaultValue(property: keyof Scale, scale: Scale, channel: Channel, fieldDef: FieldDef, scaleConfig: ScaleConfig) {\n\n  // If we have default rule-base, determine default value first\n  switch (property) {\n    case 'nice':\n      return rules.nice(scale.type, channel, fieldDef);\n    case 'padding':\n      return rules.padding(channel, scale.type, scaleConfig);\n    case 'paddingInner':\n      return rules.paddingInner(scale.padding, channel, scaleConfig);\n    case 'paddingOuter':\n      return rules.paddingOuter(scale.padding, channel, scale.type, scale.paddingInner, scaleConfig);\n    case 'round':\n      return rules.round(channel, scaleConfig);\n    case 'zero':\n      return rules.zero(scale, channel, fieldDef);\n  }\n  // Otherwise, use scale config\n  return scaleConfig[property];\n}\n","import {Channel} from '../../channel';\nimport {Scale} from '../../scale';\nimport {isSortField} from '../../sort';\nimport {Dict} from '../../util';\n\nimport {Model} from '../model';\n\nimport {parseDomain} from './domain';\nimport {parseRange} from './range';\nimport {VgScale} from '../../vega.schema';\n\n/**\n * Parse scales for all channels of a model.\n */\nexport default function parseScaleComponent(model: Model): Dict<VgScale> {\n  // TODO: should model.channels() inlcude X2/Y2?\n  return model.channels().reduce(function(scaleComponentsIndex: Dict<VgScale>, channel: Channel) {\n    const scaleComponents = parseScale(model, channel);\n    if (scaleComponents) {\n      scaleComponentsIndex[channel] = scaleComponents;\n    }\n    return scaleComponentsIndex;\n  }, {});\n}\n\nexport const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES: (keyof Scale)[] = [\n  'round',\n  // quantitative / time\n  'clamp', 'nice',\n  // quantitative\n  'exponent', 'interpolate', 'zero', // zero depends on domain\n  // ordinal\n  'padding', 'paddingInner', 'paddingOuter', // padding\n];\n\n/**\n * Parse scales for a single channel of a model.\n */\nexport function parseScale(model: Model, channel: Channel) {\n  if (!model.scale(channel)) {\n    return null;\n  }\n\n  const scale = model.scale(channel);\n  const sort = model.sort(channel);\n\n  let scaleComponent: VgScale = {\n    name: model.scaleName(channel + '', true),\n    type: scale.type,\n    domain: parseDomain(model, channel),\n    range: parseRange(scale)\n  };\n\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES.forEach((property) => {\n    scaleComponent[property] = scale[property];\n  });\n\n  if (sort && (isSortField(sort) ? sort.order : sort) === 'descending') {\n    scaleComponent.reverse = true;\n  }\n  return scaleComponent;\n}\n","import * as log from '../../log';\n\nimport {COLUMN, ROW, X, Y, SHAPE, SIZE, COLOR, OPACITY, Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {Mark} from '../../mark';\nimport {Scale, ScaleConfig, ScaleType, scaleTypeSupportProperty, Scheme, Range, isExtendedScheme, channelScalePropertyIncompatability} from '../../scale';\nimport {Type} from '../../type';\nimport {VgRange, VgRangeScheme} from '../../vega.schema';\nimport * as util from '../../util';\n\nexport type RangeMixins = {range: Range} | {rangeStep: number} | {scheme: Scheme};\n\nexport function parseRange(scale: Scale): VgRange {\n  if (scale.rangeStep) {\n    return {step: scale.rangeStep};\n  } else if (scale.scheme) {\n    const scheme = scale.scheme;\n    if (isExtendedScheme(scheme)) {\n      let r: VgRangeScheme = {scheme: scheme.name};\n      if (scheme.count) {\n        r.count = scheme.count;\n      }\n      if (scheme.extent) {\n        r.extent = scheme.extent;\n      }\n      return r;\n    } else {\n      return {scheme};\n    }\n  }\n  return scale.range;\n}\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'rangeStep', 'scheme'];\n\n/**\n * Return mixins that includes one of the range properties (range, rangeStep, scheme).\n */\nexport default function rangeMixins(\n  channel: Channel, scaleType: ScaleType, type: Type, specifiedScale: Scale, config: Config,\n  zero: boolean, mark: Mark, topLevelSize: number | undefined, xyRangeSteps: number[]): RangeMixins {\n\n  let specifiedRangeStepIsNull = false;\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (let property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      let supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return {range: specifiedScale[property]};\n          case 'scheme':\n            return {scheme: specifiedScale[property]};\n          case 'rangeStep':\n            if (topLevelSize === undefined) {\n              const stepSize = specifiedScale[property];\n              if (stepSize !== null) {\n                return {rangeStep: stepSize};\n              } else {\n                specifiedRangeStepIsNull = true;\n              }\n            } else {\n              // If top-level size is specified, we ignore specified rangeStep.\n              log.warn(log.message.rangeStepDropped(channel));\n            }\n        }\n      }\n    }\n  }\n\n  switch (channel) {\n    // TODO: revise row/column when facetSpec has top-level width/height\n    case ROW:\n      return {range: 'height'};\n    case COLUMN:\n      return {range: 'width'};\n    case X:\n    case Y:\n      if (topLevelSize === undefined) {\n        if (util.contains(['point', 'band'], scaleType) && !specifiedRangeStepIsNull) { // FIXME isDiscrete blah blah\n          if (channel === X && mark === 'text') {\n            if (config.scale.textXRangeStep) {\n              return {rangeStep: config.scale.textXRangeStep};\n            }\n          } else {\n            if (config.scale.rangeStep) {\n              return {rangeStep: config.scale.rangeStep};\n            }\n          }\n        }\n        // If specified range step is null or the range step config is null.\n        // Use default topLevelSize rule/config\n        topLevelSize = channel === X ? config.cell.width : config.cell.height;\n      }\n      return {range: channel === X ? [0, topLevelSize] : [topLevelSize, 0]};\n\n    case SIZE:\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, xyRangeSteps, config);\n      return {range: [rangeMin, rangeMax]};\n    case SHAPE:\n    case COLOR:\n      return {range: defaultRange(channel, scaleType, type, mark)};\n\n\n    case OPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return {range: [config.scale.minOpacity, config.scale.maxOpacity]};\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nfunction defaultRange(channel: 'shape' | 'color', scaleType: ScaleType, type: Type, mark: Mark) {\n  switch (channel) {\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      }\n      return mark === 'rect' ? 'heatmap' : 'ramp';\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n      return config.scale.minBandSize !== undefined ? config.scale.minBandSize : config.bar.continuousBandSize;\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config.scale.minSize) {\n        return config.scale.minSize;\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nfunction sizeRangeMax(mark: Mark, xyRangeSteps: number[], config: Config) {\n  const scaleConfig = config.scale;\n  // TODO(#1168): make max size scale based on rangeStep / overall plot size\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      return minXYRangeStep(xyRangeSteps, config.scale) - 1;\n    case 'line':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      // FIXME this case totally should be refactored\n      const pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);\n      return (pointStep - 2) * (pointStep - 2);\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYRangeStep(xyRangeSteps: number[], scaleConfig: ScaleConfig): number {\n  if (xyRangeSteps.length > 0) {\n    return Math.min.apply(null, xyRangeSteps);\n  }\n  if (scaleConfig.rangeStep) {\n    return scaleConfig.rangeStep;\n  }\n  return 21; // FIXME: re-evaluate the default value here.\n}\n","\nimport {X, Y, Channel} from '../../channel';\nimport {FieldDef} from '../../fielddef';\nimport {Scale, ScaleConfig, ScaleType, NiceTime} from '../../scale';\nimport {smallestUnit} from '../../timeunit';\nimport * as util from '../../util';\n\nexport function nice(scaleType: ScaleType, channel: Channel, fieldDef: FieldDef): boolean | NiceTime {\n  if (util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return smallestUnit(fieldDef.timeUnit) as any;\n  }\n  return util.contains([X, Y], channel); // return true for quantitative X/Y\n}\n\nexport function padding(channel: Channel, scaleType: ScaleType, scaleConfig: ScaleConfig) {\n  if (util.contains([X, Y], channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(padding: number, channel: Channel,  scaleConfig: ScaleConfig) {\n  if (padding !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    return scaleConfig.bandPaddingInner;\n  }\n  return undefined;\n}\n\nexport function paddingOuter(padding: number, channel: Channel, scaleType: ScaleType, paddingInner: number, scaleConfig: ScaleConfig) {\n  if (padding !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      if (scaleConfig.bandPaddingOuter !== undefined) {\n        return scaleConfig.bandPaddingOuter;\n      }\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n      return paddingInner / 2;\n    }\n  }\n  return undefined;\n}\n\nexport function round(channel: Channel, scaleConfig: ScaleConfig) {\n  if (util.contains(['x', 'y', 'row', 'column'], channel)) {\n    return scaleConfig.round;\n  }\n  return undefined;\n}\n\nexport function zero(specifiedScale: Scale, channel: Channel, fieldDef: FieldDef) {\n  // By default, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common.\n  if (channel === 'size' && fieldDef.type === 'quantitative') {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale if no custom domain is provided.\n  // (For binning, we should not include zero by default because binning are calculated without zero.\n  // Similar, if users explicitly provide a domain range, we should not augment zero as that will be unexpected.)\n  if (!specifiedScale.domain && !fieldDef.bin && util.contains([X, Y], channel)) {\n    return true;\n  }\n  return false;\n}\n","import * as log from '../../log';\n\nimport {hasScale, supportScaleType, rangeType, Channel} from '../../channel';\nimport {Mark} from '../../mark';\nimport {ScaleType, ScaleConfig} from '../../scale';\nimport {isDiscreteByDefault} from '../../timeunit';\n\nimport * as util from '../../util';\nimport {FieldDef} from '../../fielddef';\n\nexport type RangeType = 'continuous' | 'discrete' | 'flexible' | undefined;\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport default function type(\n  specifiedType: ScaleType, channel: Channel, fieldDef: FieldDef, mark: Mark,\n  hasTopLevelSize: boolean, specifiedRangeStep: number, scaleConfig: ScaleConfig): ScaleType {\n\n  const defaultScaleType = defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n\n  if (!hasScale(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (specifiedType !== undefined) {\n    // for binned fields we don't allow overriding the default scale\n    if (fieldDef.bin) {\n      // TODO: generalize this as a method in fieldDef that determines scale type support for a fieldDef (looking at functions and type)\n      log.warn(log.message.cannotOverrideBinScaleType(channel, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    // Check if explicitly specified scale type is supported by the channel\n    if (supportScaleType(channel, specifiedType)) {\n      return specifiedType;\n    } else {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, specifiedType, defaultScaleType));\n      return defaultScaleType;\n    }\n  }\n\n  return defaultScaleType;\n}\n\n/**\n * Determine appropriate default scale type.\n */\nfunction defaultType(channel: Channel, fieldDef: FieldDef, mark: Mark,\n  hasTopLevelSize: boolean, specifiedRangeStep: number, scaleConfig: ScaleConfig): ScaleType {\n\n  if (util.contains(['row', 'column'], channel)) {\n    return 'band';\n  }\n\n  switch (fieldDef.type) {\n    case 'nominal':\n      if (channel === 'color' || rangeType(channel) === 'discrete') {\n        return 'ordinal';\n      }\n      return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n\n    case 'ordinal':\n      if (channel === 'color') {\n        return 'ordinal';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        return 'ordinal';\n      }\n      return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n\n    case 'temporal':\n      if (channel === 'color') {\n        // Always use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      if (isDiscreteByDefault(fieldDef.timeUnit)) {\n        return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n      }\n      return 'time';\n\n    case 'quantitative':\n      if (channel === 'color') {\n        if (fieldDef.bin) {\n          return 'bin-ordinal';\n        }\n        // Use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n\n      if (fieldDef.bin) {\n        return 'bin-linear';\n      }\n      return 'linear';\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n\n/**\n * Determines default scale type for nominal/ordinal field.\n * @returns BAND or POINT scale based on channel, mark, and rangeStep\n */\nfunction discreteToContinuousType(\n    channel: Channel, mark: Mark, hasTopLevelSize: boolean,\n    specifiedRangeStep: number, scaleConfig: ScaleConfig): ScaleType {\n\n  if (util.contains(['x', 'y'], channel)) {\n    if (mark === 'rect') {\n      // The rect mark should fit into a band.\n      return 'band';\n    }\n    if (mark === 'bar') {\n      // For bar, use band only if there is no rangeStep since we need to use band for fit mode.\n      // However, for non-fit mode, point scale provides better center position.\n      if (haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig)) {\n        return 'point';\n      }\n      return 'band';\n    }\n  }\n  // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n  return 'point';\n}\n\nfunction haveRangeStep(hasTopLevelSize: boolean, specifiedRangeStep: number, scaleConfig: ScaleConfig) {\n  if (hasTopLevelSize) {\n    // if topLevelSize is provided, rangeStep will be dropped.\n    return false;\n  }\n  if (specifiedRangeStep !== undefined) {\n    return specifiedRangeStep !== null;\n  }\n  return !!scaleConfig.rangeStep;\n}\n","import {SelectionComponent, SelectionCompiler, TUPLE, invert as invertFn, channelSignalName} from './selection';\nimport {X, Y, Channel} from '../../channel';\nimport {UnitModel} from '../unit';\nimport {stringValue, extend} from '../../util';\nimport {warn} from '../../log';\nimport scales from './transforms/scales';\n\nexport const BRUSH = '_brush',\n  SIZE = '_size';\n\nconst interval:SelectionCompiler = {\n  predicate: 'vlInterval',\n\n  signals: function(model, selCmpt) {\n    let signals: any[] = [],\n        intervals:any[] = [],\n        name = selCmpt.name,\n        size = name + SIZE;\n\n    if (selCmpt.translate && !(scales.has(selCmpt))) {\n      events(selCmpt, function(_: any[], evt: any) {\n        let filters = evt.between[0].filter || (evt.between[0].filter = []);\n        filters.push('!event.item || (event.item && ' +\n          `event.item.mark.name !== ${stringValue(name + BRUSH)})`);\n      });\n    }\n\n    selCmpt.project.forEach(function(p) {\n      if (p.encoding !== X && p.encoding !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      let cs = channelSignal(model, selCmpt, p.encoding);\n      signals.push(cs);\n      intervals.push(`{field: ${stringValue(p.field)}, extent: ${cs.name}}`);\n    });\n\n    signals.push({\n      name: size,\n      value: [],\n      on: events(selCmpt, function(on: any[], evt: any) {\n        on.push({\n          events: evt.between[0],\n          update: '{x: x(unit), y: y(unit), width: 0, height: 0}'\n        });\n\n        on.push({\n          events: evt,\n          update: `{x: ${size}.x, y: ${size}.y, ` +\n           `width: abs(x(unit) - ${size}.x), height: abs(y(unit) - ${size}.y)}`\n        });\n\n        return on;\n      })\n    }, {\n      name: name,\n      update: `[${intervals.join(', ')}]`\n    });\n\n    return signals;\n  },\n\n  tupleExpr: function(model, selCmpt) {\n    return `intervals: ${selCmpt.name}`;\n  },\n\n  modifyExpr: function(model, selCmpt) {\n    let tpl = selCmpt.name + TUPLE;\n    return `${tpl}, {unit: ${tpl}.unit}`;\n  },\n\n  marks: function(model, selCmpt, marks) {\n    let name = selCmpt.name,\n        {x, y} = projections(selCmpt);\n\n    // Do not add a brush if we're binding to scales.\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    let update = {\n      x: extend({}, x !== null ?\n        {scale: model.scaleName(X), signal: `${name}[${x}].extent[0]`} :\n        {value: 0}),\n\n      x2: extend({}, x !== null ?\n        {scale: model.scaleName(X), signal: `${name}[${x}].extent[1]`} :\n        {field: {group: 'width'}}),\n\n      y: extend({}, y !== null ?\n        {scale: model.scaleName(Y), signal: `${name}[${y}].extent[0]`} :\n        {value: 0}),\n\n      y2: extend({}, y !== null ?\n        {scale: model.scaleName(Y), signal: `${name}[${y}].extent[1]`} :\n        {field: {group: 'height'}}),\n    };\n\n    return [{\n      name: undefined,\n      type: 'rect',\n      encode: {\n        enter: {fill: {value: '#eee'}},\n        update: update\n      }\n    }].concat(marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      encode: {\n        enter: {fill: {value: 'transparent'}},\n        update: update\n      }\n    });\n  }\n};\nexport {interval as default};\n\nexport function projections(selCmpt: SelectionComponent) {\n  let x:number = null, y:number = null;\n  selCmpt.project.forEach(function(p, i) {\n    if (p.encoding === X) {\n      x = i;\n    } else if (p.encoding === Y) {\n      y = i;\n    }\n  });\n  return {x: x, y: y};\n}\n\nfunction channelSignal(model: UnitModel, selCmpt: SelectionComponent, channel: Channel): any {\n  let name  = channelSignalName(selCmpt, channel),\n      size  = (channel === X ? 'width' : 'height'),\n      coord = `${channel}(unit)`,\n      invert = invertFn.bind(null, model, selCmpt, channel);\n\n  return {\n    name: name,\n    value: [],\n    on: scales.has(selCmpt) ? [] : events(selCmpt, function(on: any[], evt: any) {\n      on.push({\n        events: evt.between[0],\n        update: invert(`[${coord}, ${coord}]`)\n      });\n\n      on.push({\n        events: evt,\n        update: `[${name}[0], ` + invert(`clamp(${coord}, 0, ${size})`) + ']'\n      });\n\n      return on;\n    })\n  };\n}\n\nfunction events(selCmpt: SelectionComponent, cb: Function) {\n  return selCmpt.events.reduce(function(on: any[], evt: any) {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections`);\n      return on;\n    }\n    return cb(on, evt);\n  }, []);\n}\n","import {TUPLE, SelectionCompiler} from './selection';\nimport {stringValue} from '../../util';\n\nconst multi:SelectionCompiler = {\n  predicate: 'vlPoint',\n\n  signals: function(model, selCmpt) {\n    let proj = selCmpt.project,\n        datum  = '(item().isVoronoi ? datum.datum : datum)',\n        fields = proj.map((p) => stringValue(p.field)).join(', '),\n        values = proj.map((p) => `${datum}[${stringValue(p.field)}]`).join(', ');\n    return [{\n      name: selCmpt.name,\n      value: {},\n      on: [{\n        events: selCmpt.events,\n        update: `{fields: [${fields}], values: [${values}]}`\n      }]\n    }];\n  },\n\n  tupleExpr: function(model, selCmpt) {\n    let name = selCmpt.name;\n    return `fields: ${name}.fields, values: ${name}.values`;\n  },\n\n  modifyExpr: function(model, selCmpt) {\n    return selCmpt.name + TUPLE;\n  }\n};\n\nexport {multi as default};\n","import {SelectionDef, SelectionDomain, SelectionResolutions, SelectionTypes} from '../../selection';\nimport {SelectionComponent} from './selection';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {Channel} from '../../channel';\nimport {Dict, extend, stringValue, isString} from '../../util';\nimport {forEachTransform} from './transforms/transforms';\nimport parseSelector from 'vega-parser/src/parsers/event-selector';\nimport {VgData, VgBinding} from '../../vega.schema';\nimport singleCompiler from './single';\nimport multiCompiler from './multi';\nimport intervalCompiler from './interval';\n\nexport const STORE = '_store',\n  TUPLE  = '_tuple',\n  MODIFY = '_modify';\n\nexport interface SelectionComponent {\n  name: string;\n  type: SelectionTypes;\n  domain: SelectionDomain;\n  events: any;\n  // predicate?: string;\n  bind?: 'scales' | VgBinding | {[key: string]: VgBinding};\n  resolve: SelectionResolutions;\n\n  // Transforms\n  project?: ProjectComponent[];\n  scales?: Channel[];\n  toggle?: any;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n}\n\nexport interface ProjectComponent {\n  field?: string;\n  encoding?: Channel;\n}\n\nexport interface SelectionCompiler {\n  signals: (model: UnitModel, selCmpt: SelectionComponent) => any[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent) => any[];\n  tupleExpr: (model: UnitModel, selCmpt: SelectionComponent) => string;\n  modifyExpr: (model: UnitModel, selCmpt: SelectionComponent) => string;\n  marks?: (model: UnitModel, selCmpt:SelectionComponent, marks: any[]) => any[];\n  predicate: string;  // Vega expr string to determine inclusion in selection.\n}\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  let selCmpts: Dict<SelectionComponent> = {},\n      selectionConfig = model.config.selection;\n\n  for (let name in selDefs) {\n    if (!selDefs.hasOwnProperty(name)) {\n      continue;\n    }\n\n    let selDef = selDefs[name],\n        cfg = selectionConfig[selDef.type];\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (let key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] || selDef[key];\n      }\n    }\n\n    let selCmpt = selCmpts[name] = extend({}, selDef, {\n      name: model.getName(name),\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on,\n      domain: 'data' as SelectionDomain, // TODO: Support def.domain\n      resolve: 'union' as SelectionResolutions\n    }) as SelectionComponent;\n\n    forEachTransform(selCmpt, function(txCompiler) {\n      if (txCompiler.parse) {\n        txCompiler.parse(model, selDef, selCmpt);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n\nexport function assembleUnitSignals(model: UnitModel, signals: any[]) {\n  forEachSelection(model, function(selCmpt, selCompiler) {\n    let name = selCmpt.name,\n        tupleExpr = selCompiler.tupleExpr(model, selCmpt),\n        modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    signals.push.apply(signals, selCompiler.signals(model, selCmpt));\n\n    forEachTransform(selCmpt, function(txCompiler) {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n\n    signals.push({\n      name: name + TUPLE,\n      on: [{\n        events: {signal: name},\n        update: `{unit: unit.datum && unit.datum._id, ${tupleExpr}}`\n      }]\n    }, {\n      name: name + MODIFY,\n      on: [{\n        events: {signal: name},\n        update: `modify(${stringValue(name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  });\n\n  return signals;\n}\n\nexport function assembleTopLevelSignals(model: Model) {\n  let signals:any[] = [{\n    name: 'unit',\n    value: {},\n    on: [{events: 'mousemove', update: 'group()._id ? group() : unit'}]\n  }];\n\n  forEachSelection(model, function(selCmpt, selCompiler) {\n    if (selCompiler.topLevelSignals) {\n      signals.push.apply(signals, selCompiler.topLevelSignals(model, selCmpt));\n    }\n\n    forEachTransform(selCmpt, function(txCompiler) {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n  });\n\n  return signals;\n}\n\nexport function assembleUnitData(model: UnitModel, data: VgData[]): VgData[] {\n  return data\n    .concat(Object.keys(model.component.selection)\n      .map(function(k: string) {\n        return {name: k + STORE};\n      }));\n}\n\nexport function assembleUnitMarks(model: UnitModel, marks: any[]): any[] {\n  let clippedGroup = false,\n      selMarks = marks;\n  forEachSelection(model, function(selCmpt, selCompiler) {\n    selMarks = selCompiler.marks ? selCompiler.marks(model, selCmpt, selMarks) : selMarks;\n    forEachTransform(selCmpt, function(txCompiler) {\n      clippedGroup = clippedGroup || txCompiler.clippedGroup;\n      if (txCompiler.marks) {\n        selMarks = txCompiler.marks(model, selCmpt, marks, selMarks);\n      }\n    });\n  });\n\n  if (clippedGroup) {\n    selMarks = [{\n      type: 'group',\n      encode: {\n        enter: {\n          width: {field: {group: 'width'}},\n          height: {field: {group: 'height'}},\n          fill: {value: 'transparent'},\n          clip: {value: true}\n        }\n      },\n      marks: selMarks\n    }];\n  }\n\n  return selMarks;\n}\n\nlet PREDICATES_OPS = {\n  'single': '\"intersect\", \"all\"',\n  'independent': '\"intersect\", \"unit\"',\n  'union': '\"union\", \"all\"',\n  'union_others': '\"union\", \"others\"',\n  'intersect': '\"intersect\", \"all\"',\n  'intersect_others': '\"intersect\", \"others'\n};\n\nexport function predicate(selCmpt: SelectionComponent, datum?: string): string {\n  const store = stringValue(selCmpt.name + STORE),\n        op = PREDICATES_OPS[selCmpt.resolve];\n  datum = datum || 'datum';\n  return compiler(selCmpt).predicate + `(${store}, parent._id, ${datum}, ${op})`;\n}\n\n// Utility functions\n\nfunction forEachSelection(model: Model, cb: (selCmpt: SelectionComponent, selCompiler: SelectionCompiler) => void) {\n  let selections = model.component.selection;\n  for (let name in selections) {\n    if (selections.hasOwnProperty(name)) {\n      let sel = selections[name];\n      cb(sel, compiler(sel));\n    }\n  }\n}\n\nfunction compiler(selCmpt: SelectionComponent): SelectionCompiler {\n  switch (selCmpt.type) {\n    case 'single':\n      return singleCompiler;\n    case 'multi':\n      return multiCompiler;\n    case 'interval':\n      return intervalCompiler;\n  }\n  return null;\n}\n\nexport function invert(model: UnitModel, selCmpt: SelectionComponent, channel: Channel, expr: string) {\n  let scale = stringValue(model.scaleName(channel));\n  return selCmpt.domain === 'data' ? `invert(${scale}, ${expr})` : expr;\n}\n\nexport function channelSignalName(selCmpt: SelectionComponent, channel: Channel) {\n  return selCmpt.name + '_' + channel;\n}\n","import {TUPLE, STORE, SelectionCompiler} from './selection';\nimport multi from './multi';\nimport {stringValue} from '../../util';\n\nconst single:SelectionCompiler = {\n  predicate: multi.predicate,\n\n  signals: multi.signals,\n\n  topLevelSignals: function(model, selCmpt) {\n    let name = selCmpt.name;\n    return [{\n      name: name,\n      update: `data(${stringValue(name + STORE)})[0]`\n    }];\n  },\n\n  tupleExpr: function(model, selCmpt) {\n    let name = selCmpt.name, values = `${name}.values`;\n    return `fields: ${name}.fields, values: ${values}, ` +\n      selCmpt.project.map(function(p, i) {\n        return `${p.field}: ${values}[${i}]`;\n      }).join(', ');\n  },\n\n  modifyExpr: function(model, selCmpt) {\n    return selCmpt.name + TUPLE + ', true';\n  }\n};\n\nexport {single as default};\n","import {TransformCompiler} from './transforms';\nimport {stringValue} from '../../../util';\n\nconst inputBindings:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.type === 'single' && selCmpt.bind && selCmpt.bind !== 'scales';\n  },\n\n  topLevelSignals: function(model, selCmpt, signals) {\n    let name = selCmpt.name,\n        proj = selCmpt.project,\n        bind = selCmpt.bind,\n        datum = '(item().isVoronoi ? datum.datum : datum)';\n\n    proj.forEach(function(p) {\n      signals.unshift({\n        name: name + id(p.field),\n        value: '',\n        on: [{\n          events: selCmpt.events,\n          update: `${datum}[${stringValue(p.field)}]`\n        }],\n        bind: bind[p.field] || bind[p.encoding] || bind\n      });\n    });\n\n    return signals;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    let name = selCmpt.name, proj = selCmpt.project,\n        signal = signals.filter((s) => s.name === name)[0],\n        fields = proj.map((p) => stringValue(p.field)).join(', '),\n        values = proj.map((p) => name + id(p.field)).join(', ');\n\n    signal.update = `{fields: [${fields}], values: [${values}]}`;\n    delete signal.value;\n    delete signal.on;\n\n    return signals;\n  }\n};\n\nexport {inputBindings as default};\n\nfunction id(str: string) {\n  return '_' + str.replace(/\\W/g, '_');\n}\n","import {TransformCompiler} from './transforms';\n\nconst VORONOI = 'voronoi';\n\nconst nearest:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.nearest !== undefined && selCmpt.nearest !== false;\n  },\n\n  marks: function(model, selCmpt, marks, selMarks) {\n    let mark = marks[0],\n        index = selMarks.indexOf(mark),\n        isPathgroup = mark.name === model.getName('pathgroup'),\n        exists = ((m: any) => m.name && m.name.indexOf(VORONOI) >= 0),\n        cellDef = {\n          name: model.getName(VORONOI),\n          type: 'path',\n          from: {data: model.getName('marks')},\n          encode: {\n            enter: {\n              fill: {value: 'transparent'},\n              strokeWidth: {value: 0.35},\n              stroke: {value: 'transparent'},\n              isVoronoi: {value: true}\n            }\n          },\n          transform: [{\n            type: 'voronoi',\n            x: 'datum.x',\n            y: 'datum.y',\n            size: [{signal: 'width'}, {signal: 'height'}]\n          }]\n        };\n\n    if (isPathgroup && !mark.marks.filter(exists).length) {\n      mark.marks.push(cellDef);\n      selMarks.splice(index, 1, mark);\n    } else if (!isPathgroup && !selMarks.filter(exists).length) {\n      selMarks.splice(index + 1, 0, cellDef);\n    }\n\n    return selMarks;\n  }\n};\n\nexport {nearest as default};\n","import {Channel} from '../../../channel';\nimport {SelectionDef} from '../../../selection';\nimport {TransformCompiler} from './transforms';\n\nconst project:TransformCompiler = {\n  has: function(selDef: SelectionDef) {\n    return selDef.fields !== undefined || selDef.encodings !== undefined;\n  },\n\n  parse: function(model, selDef, selCmpt) {\n    let fields = {};\n    // TODO: find a possible channel mapping for these fields.\n    (selDef.fields || []).forEach((f) => fields[f] = null);\n    (selDef.encodings || []).forEach((e: Channel) => fields[model.field(e)] = e);\n\n    let projection = selCmpt.project || (selCmpt.project = []);\n    for (let field in fields) {\n      if (fields.hasOwnProperty(field)) {\n        projection.push({field: field, encoding: fields[field]});\n      }\n    }\n  }\n};\n\nexport {project as default};\n","import {TransformCompiler} from './transforms';\nimport {warn} from '../../../log';\nimport {hasContinuousDomain} from '../../../scale';\nimport {Channel} from '../../../channel';\nimport {TUPLE, MODIFY, channelSignalName} from '../selection';\nimport {UnitModel} from '../../unit';\nimport {SIZE as INTERVAL_SIZE} from '../interval';\nimport {stringValue} from '../../../util';\n\nconst scaleBindings:TransformCompiler = {\n  clippedGroup: true,\n\n  has: function(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n\n  parse: function(model, selDef, selCmpt) {\n    const scales = model.component.scales;\n    const bound:Channel[] = selCmpt.scales = [];\n\n    selCmpt.project.forEach(function(p) {\n      const channel = p.encoding;\n      const scale = scales[channel];\n\n      if (!scale || !hasContinuousDomain(scale.type)) {\n        warn('Scale bindings are currently only supported for scales with continuous domains.');\n        return;\n      }\n\n      scale.domainRaw = {signal: channelSignalName(selCmpt, channel)};\n      bound.push(channel);\n    });\n  },\n\n  topLevelSignals: function(model, selCmpt, signals) {\n    return signals.concat(selCmpt.scales.map((channel) => {\n      return {name: channelSignalName(selCmpt, channel)};\n    }));\n  },\n\n  signals: function(model, selCmpt, signals) {\n    let name = selCmpt.name;\n    signals = signals.filter(function(s) {\n      return s.name !== name + INTERVAL_SIZE &&\n        s.name !== name + TUPLE && s.name !== MODIFY;\n    });\n\n    selCmpt.scales.forEach(function(channel) {\n      let signal = signals.filter((s) => s.name === name + '_' + channel)[0];\n      signal.push = 'outer';\n      delete signal.value;\n      delete signal.update;\n    });\n\n    return signals;\n  }\n};\n\nexport {scaleBindings as default};\n\nexport function domain(model: UnitModel, channel: Channel) {\n  let scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n","import {TransformCompiler} from './transforms';\nimport {TUPLE} from '../selection';\n\nconst TOGGLE = '_toggle';\n\nconst toggle:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.toggle !== undefined && selCmpt.toggle !== false;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    return signals.concat({\n      name: selCmpt.name + TOGGLE,\n      value: false,\n      on: [{events: selCmpt.events, update: selCmpt.toggle}]\n    });\n  },\n\n  modifyExpr: function(model, selCmpt, expr) {\n    let tpl = selCmpt.name + TUPLE,\n        signal = selCmpt.name + TOGGLE;\n\n    return `${signal} ? null : ${tpl}, ` +\n      `${signal} ? null : true, ` +\n      `${signal} ? ${tpl} : null`;\n  }\n};\n\nexport {toggle as default};\n","import {Model} from '../../model';\nimport {UnitModel} from '../../unit';\nimport {SelectionDef} from '../../../selection';\nimport {SelectionComponent} from '../selection';\nimport {Dict} from '../../../util';\n\nexport interface TransformCompiler {\n  has: (selCmpt: SelectionComponent | SelectionDef) => boolean;\n  parse?: (model: UnitModel, def: SelectionDef, selCmpt: SelectionComponent) => void;\n  signals?: (model: UnitModel, selCmpt: SelectionComponent, signals: any[]) => any[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent, signals: any[]) => any[];\n  // tupleExpr?: (model: UnitModel, selCmpt: SelectionComponent, expr: string) => string;\n  modifyExpr?: (model: UnitModel, selCmpt: SelectionComponent, expr: string) => string;\n  marks?: (model: UnitModel, selCmpt:SelectionComponent, marks: any[], selMarks: any[]) => any[];\n  clippedGroup?: boolean;\n}\n\nimport project from './project';\nimport toggle from './toggle';\nimport translate from './translate';\nimport zoom from './zoom';\nimport scales from './scales';\nimport inputs from './inputs';\nimport nearest from './nearest';\nconst compilers: Dict<TransformCompiler> = {project, toggle, scales,\n  translate, zoom, inputs, nearest};\n\nexport function forEachTransform(selCmpt: SelectionComponent, cb: (tx: TransformCompiler) => void) {\n  for (let t in compilers) {\n    if (compilers[t].has(selCmpt)) {\n      cb(compilers[t]);\n    }\n  }\n}\n","import parseSelector from 'vega-parser/src/parsers/event-selector';\nimport {UnitModel} from './../../unit';\nimport {SelectionComponent} from '../selection';\nimport {X, Y, Channel} from '../../../channel';\nimport {stringValue} from '../../../util';\nimport {TransformCompiler} from './transforms';\nimport {default as scalesCompiler, domain} from './scales';\nimport {projections as intervalProjections, SIZE as INTERVAL_SIZE, BRUSH as INTERVAL_BRUSH} from '../interval';\n\nconst ANCHOR = '_translate_anchor',\n      DELTA  = '_translate_delta';\n\nconst translate:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.translate !== undefined && selCmpt.translate !== false;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    let name = selCmpt.name,\n        scales = scalesCompiler.has(selCmpt),\n        size = scales ? 'unit' : name + INTERVAL_SIZE,\n        anchor = name + ANCHOR,\n        events = parseSelector(selCmpt.translate, 'scope'),\n        {x, y} = intervalProjections(selCmpt);\n\n    if (!scales) {\n      events = events.map((e) => (e.between[0].markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: anchor,\n      value: {},\n      on: [{\n        events: events.map((e) => e.between[0]),\n        update: '{x: x(unit), y: y(unit), ' +\n          `width: ${size}.width, height: ${size}.height, ` +\n\n          (x !== null ? 'extent_x: ' + (scales ? domain(model, X) :\n              `slice(${name}_x)`) + ', ' : '') +\n\n          (y !== null ? 'extent_y: ' + (scales ? domain(model, Y) :\n              `slice(${name}_y)`) + ', ' : '') + '}'\n      }]\n    }, {\n      name: name + DELTA,\n      value: {},\n      on: [{\n        events: events,\n        update: `{x: x(unit) - ${anchor}.x, y: y(unit) - ${anchor}.y}`\n      }]\n    });\n\n    if (x !== null) {\n      onDelta(model, selCmpt, X, 'width', signals);\n    }\n\n    if (y !== null) {\n      onDelta(model, selCmpt, Y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport {translate as default};\n\nfunction getSign(selCmpt: SelectionComponent, channel: Channel) {\n  let s = channel === X ? '+' : '-';\n  if (scalesCompiler.has(selCmpt)) {\n    s = s === '+' ? '-' : '+';\n  }\n  return s;\n}\n\nfunction onDelta(model: UnitModel, selCmpt: SelectionComponent, channel: Channel, size: string, signals: any[]) {\n  let name = selCmpt.name,\n      signal:any = signals.filter((s:any) => s.name === name + '_' + channel)[0],\n      anchor = name + ANCHOR,\n      delta  = name + DELTA,\n      scale  = stringValue(model.scaleName(channel)),\n      extent = `.extent_${channel}`,\n      sign = getSign(selCmpt, channel),\n      offset = `${sign} abs(span(${anchor}${extent})) * ` +\n        `${delta}.${channel} / ${anchor}.${size}`,\n      range = `[${anchor}${extent}[0] ${offset}, ` +\n        `${anchor}${extent}[1] ${offset}]`,\n      lo = `invert(${scale}` + (channel === X ? ', 0' : `, unit.${size}`) + ')',\n      hi = `invert(${scale}` + (channel === X ? `, unit.${size}` : ', 0') + ')';\n\n  signal.on.push({\n    events: {signal: delta},\n    update: scalesCompiler.has(selCmpt) ? range : `clampRange(${range}, ${lo}, ${hi})`\n  });\n}\n","import parseSelector from 'vega-parser/src/parsers/event-selector';\nimport {UnitModel} from './../../unit';\nimport {SelectionComponent} from '../selection';\nimport {X, Y, Channel} from '../../../channel';\nimport {stringValue} from '../../../util';\nimport {TransformCompiler} from './transforms';\nimport {default as scalesCompiler, domain} from './scales';\nimport {projections as intervalProjections, SIZE as INTERVAL_SIZE, BRUSH as INTERVAL_BRUSH} from '../interval';\n\nconst ANCHOR = '_zoom_anchor',\n      DELTA  = '_zoom_delta';\n\nconst zoom:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.zoom !== undefined && selCmpt.zoom !== false;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    let name = selCmpt.name,\n        delta = name + DELTA,\n        events = parseSelector(selCmpt.zoom, 'scope'),\n        {x, y} = intervalProjections(selCmpt),\n        sx = stringValue(model.scaleName(X)),\n        sy = stringValue(model.scaleName(Y));\n\n    if (!scalesCompiler.has(selCmpt)) {\n      events = events.map((e) => (e.markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: name + ANCHOR,\n      on: [{\n        events: events,\n        update: `{x: invert(${sx}, x(unit)), y: invert(${sy}, y(unit))}`\n      }]\n    }, {\n      name: delta,\n      on: [{\n        events: events,\n        force: true,\n        update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n      }]\n    });\n\n    if (x !== null) {\n      onDelta(model, selCmpt, 'x', 'width', signals);\n    }\n\n    if (y !== null) {\n      onDelta(model, selCmpt, 'y', 'height', signals);\n    }\n\n    let size = signals.filter((s:any) => s.name === name + INTERVAL_SIZE);\n    if (size.length) {\n      let sname = size[0].name;\n      size[0].on.push({\n        events: {signal: delta},\n        update: `{x: ${sname}.x, y: ${sname}.y, ` +\n          `width: ${sname}.width * ${delta} , ` +\n          `height: ${sname}.height * ${delta}}`\n      });\n    }\n\n    return signals;\n  }\n};\n\nexport {zoom as default};\n\nfunction onDelta(model: UnitModel, selCmpt: SelectionComponent, channel: Channel, size: string, signals: any[]) {\n  let name = selCmpt.name,\n      signal:any = signals.filter((s:any) => s.name === name + '_' + channel)[0],\n      scales = scalesCompiler.has(selCmpt),\n      base = scales ? domain(model, channel) : signal.name,\n      anchor = `${name}${ANCHOR}.${channel}`,\n      delta  = name + DELTA,\n      scale  = stringValue(model.scaleName(channel)),\n      range  = `[${anchor} + (${base}[0] - ${anchor}) * ${delta}, ` +\n        `${anchor} + (${base}[1] - ${anchor}) * ${delta}]`,\n      lo = `invert(${scale}` + (channel === X ? ', 0' : `, unit.${size}`) + ')',\n      hi = `invert(${scale}` + (channel === X ? `, unit.${size}` : ', 0') + ')';\n\n  signal.on.push({\n    events: {signal: delta},\n    update: scales ? range : `clampRange(${range}, ${lo}, ${hi})`\n  });\n}\n","\n\nimport {Axis, VlOnlyAxisBase, VL_ONLY_AXIS_PROPERTIES} from '../axis';\nimport {X, Y, X2, Y2, Channel, UNIT_CHANNELS,  UNIT_SCALE_CHANNELS, NONSPATIAL_SCALE_CHANNELS} from '../channel';\nimport {defaultConfig, Config, CellConfig} from '../config';\nimport {SOURCE, SUMMARY} from '../data';\nimport {Encoding, dropInvalidFieldDefs} from '../encoding';\nimport * as vlEncoding from '../encoding'; // TODO: remove\nimport {FieldDef, FieldRefOption, field, isFieldDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {Mark, MarkDef, TEXT as TEXT_MARK, FILL_STROKE_CONFIG, isMarkDef} from '../mark';\nimport {Scale, ScaleConfig, hasDiscreteDomain} from '../scale';\nimport {UnitSpec} from '../spec';\nimport {duplicate, extend, mergeDeep, Dict} from '../util';\nimport {VgData} from '../vega.schema';\n\nimport {parseAxisComponent} from './axis/parse';\nimport {applyConfig} from './common';\nimport {assembleData, parseUnitData} from './data/data';\nimport {parseLegendComponent} from './legend/parse';\nimport {assembleLayout, parseUnitLayout} from './layout';\nimport {Model} from './model';\nimport {parseMark} from './mark/mark';\nimport initScale from './scale/init';\nimport parseScaleComponent from './scale/parse';\nimport {stack, StackProperties} from '../stack';\nimport {SelectionDef} from '../selection';\nimport {parseUnitSelection, assembleUnitSignals, assembleUnitData as assembleSelectionData, assembleUnitMarks as assembleSelectionMarks} from './selection/selection';\nimport {initMarkDef, initEncoding} from './mark/init';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends Model {\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly height: number;\n\n  public readonly markDef: MarkDef & {filled: boolean};\n  public readonly encoding: Encoding;\n\n  protected readonly selection: Dict<SelectionDef> = {};\n  protected readonly scales: Dict<Scale> = {};\n  protected readonly axes: Dict<Axis> = {};\n  protected readonly legends: Dict<Legend> = {};\n  public readonly config: Config;\n  public readonly stack: StackProperties;\n  public children: Model[] = [];\n\n  constructor(spec: UnitSpec, parent: Model, parentGivenName: string) {\n    super(spec, parent, parentGivenName);\n\n    // use top-level width / height or parent's top-level width / height\n\n    // FIXME: once facet supports width/height, this is no longer correct!\n    const providedWidth = spec.width !== undefined ? spec.width :\n      parent ? parent['width'] : undefined; // only exists if parent is layer\n    const providedHeight = spec.height !== undefined ? spec.height :\n      parent ? parent['height'] : undefined; // only exists if parent is layer\n\n    const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n    const encoding = this.encoding = dropInvalidFieldDefs(mark, spec.encoding || {});\n\n    // TODO?: ideally we should use config only inside this constructor\n    const config = this.config = this.initConfig(spec.config, parent);\n\n    // calculate stack properties\n    this.stack = stack(mark, encoding, config.stack);\n    this.scales = this.initScales(mark, encoding, config, providedWidth, providedHeight);\n\n    this.markDef = initMarkDef(spec.mark, encoding, this.scales, config);\n    this.encoding = initEncoding(mark, encoding, this.stack, config);\n\n    this.axes = this.initAxes(encoding, config);\n    this.legends = this.initLegend(encoding, config);\n\n    // Selections will be initialized upon parse.\n    this.selection = spec.selection;\n\n    // width / height\n    const {width = this.width, height = this.height} = this.initSize(mark, this.scales,\n      providedWidth,\n      providedHeight,\n      config.cell, config.scale\n    );\n    this.width = width;\n    this.height = height;\n  }\n\n\n  /**\n   * Init config by merging config from parent and, if applicable, from facet config\n   */\n  private initConfig(specConfig: Config, parent: Model) {\n    let config = mergeDeep(duplicate(defaultConfig), parent ? parent.config : {}, specConfig);\n    let hasFacetParent = false;\n    while (parent !== null) {\n      if (parent.isFacet()) {\n        hasFacetParent = true;\n        break;\n      }\n      parent = parent.parent;\n    }\n\n    if (hasFacetParent) {\n      config.cell = extend({}, config.cell, config.facet.cell);\n    }\n    return config;\n  }\n\n  private initScales(mark: Mark, encoding: Encoding, config: Config, topLevelWidth:number, topLevelHeight: number): Dict<Scale> {\n    const xyRangeSteps: number[] = [];\n\n    return UNIT_SCALE_CHANNELS.reduce((scales, channel) => {\n      if (vlEncoding.channelHasField(encoding, channel) ||\n          (channel === X && vlEncoding.channelHasField(encoding, X2)) ||\n          (channel === Y && vlEncoding.channelHasField(encoding, Y2))\n        ) {\n        const scale = scales[channel] = initScale(\n          channel, encoding[channel], config, mark,\n          channel === X ? topLevelWidth : channel === Y ? topLevelHeight : undefined,\n          xyRangeSteps // for determine point / bar size\n        );\n\n        if (channel === X || channel === Y) {\n          if (scale.rangeStep) {\n            xyRangeSteps.push(scale.rangeStep);\n          }\n        }\n      }\n      return scales;\n    }, {});\n  }\n\n  // TODO: consolidate this with scale?  Current scale range is in parseScale (later),\n  // but not in initScale because scale range depends on size,\n  // but size depends on scale type and rangeStep\n  private initSize(mark: Mark, scale: Dict<Scale>, width: number, height: number, cellConfig: CellConfig, scaleConfig: ScaleConfig) {\n    if (width === undefined) {\n      if (scale[X]) {\n        if (!hasDiscreteDomain(scale[X].type) || !scale[X].rangeStep) {\n          width = cellConfig.width;\n        } // else: Do nothing, use dynamic width.\n      } else { // No scale X\n        if (mark === TEXT_MARK) {\n          // for text table without x/y scale we need wider rangeStep\n          width = scaleConfig.textXRangeStep;\n        } else {\n          if (typeof scaleConfig.rangeStep === 'string') {\n            throw new Error('_initSize does not handle string rangeSteps');\n          }\n          width = scaleConfig.rangeStep;\n        }\n      }\n    }\n\n    if (height === undefined) {\n      if (scale[Y]) {\n        if (!hasDiscreteDomain(scale[Y].type) || !scale[Y].rangeStep) {\n          height = cellConfig.height;\n        } // else: Do nothing, use dynamic height .\n      } else {\n        if (typeof scaleConfig.rangeStep === 'string') {\n          throw new Error('_initSize does not handle string rangeSteps');\n        }\n        height = scaleConfig.rangeStep;\n      }\n    }\n\n    return {width, height};\n  }\n\n  private initAxes(encoding: Encoding, config: Config): Dict<Axis> {\n    return [X, Y].reduce(function(_axis, channel) {\n      // Position Axis\n\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef) ||\n          (channel === X && isFieldDef(encoding.x2)) ||\n          (channel === Y && isFieldDef(encoding.y2))) {\n\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        // We no longer support false in the schema, but we keep false here for backward compatability.\n        if (axisSpec !== null && axisSpec !== false) {\n          let vlOnlyAxisProperties: VlOnlyAxisBase = {};\n          VL_ONLY_AXIS_PROPERTIES.forEach(function(property) {\n            if (config.axis[property] !== undefined) {\n              vlOnlyAxisProperties[property] = config.axis[property];\n            }\n          });\n          _axis[channel] = {\n            ...vlOnlyAxisProperties,\n            ...axisSpec\n          };\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  private initLegend(encoding: Encoding, config: Config): Dict<Legend> {\n    return NONSPATIAL_SCALE_CHANNELS.reduce(function(_legend, channel) {\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef)) {\n        const legendSpec = channelDef.legend;\n        if (legendSpec !== null && legendSpec !== false) {\n          _legend[channel] = {...legendSpec};\n        }\n      }\n      return _legend;\n    }, {});\n  }\n\n  public parseData() {\n    this.component.data = parseUnitData(this);\n  }\n\n  public parseSelection() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseLayoutData() {\n    this.component.layout = parseUnitLayout(this);\n  }\n\n  public parseScale() {\n    this.component.scales = parseScaleComponent(this);\n  }\n\n  public parseMark() {\n    this.component.mark = parseMark(this);\n  }\n\n  public parseAxis() {\n    this.component.axes = parseAxisComponent(this, [X, Y]);\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  public parseGridGroup(): void {\n    return null;\n  }\n\n  public parseLegend() {\n    this.component.legends = parseLegendComponent(this);\n  }\n\n  public assembleSignals(signals: any[]): any[] {\n    return assembleUnitSignals(this, signals);\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return assembleSelectionData(this, data);\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    return assembleData(this, data);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks() {\n    return assembleSelectionMarks(this, this.component.mark);\n  }\n\n  public assembleParentGroupProperties(cellConfig: CellConfig) {\n    return applyConfig({}, cellConfig, FILL_STROKE_CONFIG.concat(['clip']));\n  }\n\n  public channels() {\n    return UNIT_CHANNELS;\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public toSpec(excludeConfig?: any, excludeData?: any) {\n    const encoding = duplicate(this.encoding);\n    let spec: any;\n\n    spec = {\n      mark: this.markDef,\n      encoding: encoding\n    };\n\n    if (!excludeConfig) {\n      spec.config = duplicate(this.config);\n    }\n\n    if (!excludeData) {\n      spec.data = duplicate(this.data);\n    }\n\n    // remove defaults\n    return spec;\n  }\n\n  public mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    // TODO: remove this || {}\n    // Currently we have it to prevent null pointer exception.\n    return this.encoding[channel] || {};\n  }\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public dataTable() {\n    return this.dataName(vlEncoding.isAggregate(this.encoding) ? SUMMARY : SOURCE);\n  }\n\n  public isUnit() {\n    return true;\n  }\n}\n","import {Encoding} from './encoding';\nimport {MarkDef, isMarkDef} from './mark';\nimport {GenericUnitSpec, LayerSpec} from './spec';\n\nexport const ERRORBAR: 'error-bar' = 'error-bar';\nexport type ERRORBAR = typeof ERRORBAR;\n\nexport type UnitNormalizer = (spec: GenericUnitSpec<any, any>)=> LayerSpec;\n\n/**\n * Registry index for all composite mark's normalizer\n */\nconst normalizerRegistry: {[mark: string]: UnitNormalizer} = {};\n\nexport function add(mark: string, normalizer: UnitNormalizer) {\n  normalizerRegistry[mark] = normalizer;\n}\n\nexport function remove(mark: string) {\n  delete normalizerRegistry[mark];\n}\n\n/**\n * Transform a unit spec with composite mark into a normal layer spec.\n */\nexport function normalize(\n    // This GenericUnitSpec has any as Encoding because unit specs with composite mark can have additional encoding channels.\n    spec: GenericUnitSpec<string | MarkDef, any>\n  ): LayerSpec {\n\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n  const normalizer = normalizerRegistry[mark];\n  if (normalizer) {\n    return normalizer(spec);\n  }\n\n  throw new Error(`Unregistered composite mark ${mark}`);\n}\n\n\nadd(ERRORBAR, (spec: GenericUnitSpec<ERRORBAR, Encoding>): LayerSpec => {\n  const {mark: _m, encoding: encoding, ...outerSpec} = spec;\n  const {size: _s, ...encodingWithoutSize} = encoding;\n  const {x2: _x2, y2: _y2, ...encodingWithoutX2Y2} = encoding;\n  const {x: _x, y: _y, ...encodingWithoutX_X2_Y_Y2} = encodingWithoutX2Y2;\n\n  if (!encoding.x2 && !encoding.y2) {\n    throw new Error('Neither x2 or y2 provided');\n  }\n\n  return {\n    ...outerSpec,\n    layer: [\n      {\n        mark: 'rule',\n        encoding: encodingWithoutSize\n      },{ // Lower tick\n        mark: 'tick',\n        encoding: encodingWithoutX2Y2\n      }, { // Upper tick\n        mark: 'tick',\n        encoding: encoding.x2 ? {\n          x: encoding.x2,\n          y: encoding.y,\n          ...encodingWithoutX_X2_Y_Y2\n        } : {\n          x: encoding.x,\n          y: encoding.y2,\n          ...encodingWithoutX_X2_Y_Y2\n        }\n      }\n    ]\n  };\n});\n","import {AxisConfig, defaultAxisConfig} from './axis';\nimport {LegendConfig, defaultLegendConfig} from './legend';\nimport {MarkConfig, BarConfig, TextConfig, TickConfig} from './mark';\nimport * as mark from './mark';\nimport {ScaleConfig, defaultScaleConfig} from './scale';\nimport {StackOffset} from './stack';\nimport {Padding} from './spec';\nimport {VgRangeScheme} from './vega.schema';\nimport {SelectionConfig, defaultConfig as defaultSelectionConfig} from './selection';\n\nexport interface CellConfig {\n  width?: number;\n  height?: number;\n\n  clip?: boolean;\n\n  // FILL_STROKE_CONFIG\n  /**\n   * The fill color.\n   */\n  fill?: string;\n\n  /** The fill opacity (value between [0,1]). */\n  fillOpacity?: number;\n\n  /** The stroke color. */\n  stroke?: string;\n\n  /** The stroke opacity (value between [0,1]). */\n  strokeOpacity?: number;\n\n  /** The stroke width, in pixels. */\n  strokeWidth?: number;\n\n  /** An array of alternating stroke, space lengths for creating dashed or dotted lines. */\n  strokeDash?: number[];\n\n  /** The offset (in pixels) into which to begin drawing with the stroke dash array. */\n  strokeDashOffset?: number;\n}\n\nexport const defaultCellConfig: CellConfig = {\n  width: 200,\n  height: 200,\n  fill: 'transparent'\n};\n\nexport const defaultFacetCellConfig: CellConfig = {\n  stroke: '#ccc',\n  strokeWidth: 1\n};\n\nexport interface FacetConfig {\n  /** Facet Axis Config */\n  axis?: AxisConfig;\n\n  /** Facet Grid Config */\n  grid?: FacetGridConfig;\n\n  /** Facet Cell Config */\n  cell?: CellConfig;\n}\n\nexport interface FacetGridConfig {\n  color?: string;\n  opacity?: number;\n  offset?: number;\n}\n\nconst defaultFacetGridConfig: FacetGridConfig = {\n  color: '#000000',\n  opacity: 0.4,\n  offset: 0\n};\n\nexport const defaultFacetConfig: FacetConfig = {\n  axis: {},\n  grid: defaultFacetGridConfig,\n  cell: defaultFacetCellConfig\n};\n\nexport type AreaOverlay = 'line' | 'linepoint' | 'none';\n\nexport interface OverlayConfig {\n  /**\n   * Whether to overlay line with point.\n   */\n  line?: boolean;\n\n  /**\n   * Type of overlay for area mark (line or linepoint)\n   */\n  area?: AreaOverlay;\n\n  /**\n   * Default style for the overlayed point.\n   */\n  pointStyle?: MarkConfig;\n\n  /**\n   * Default style for the overlayed point.\n   */\n  lineStyle?: MarkConfig;\n}\n\nexport const defaultOverlayConfig: OverlayConfig = {\n  line: false,\n  pointStyle: {filled: true},\n  lineStyle: {}\n};\n\nexport type RangeConfig = (number|string)[] | VgRangeScheme | {step: number};\n\nexport interface Config {\n  // TODO: add this back once we have top-down layout approach\n  // width?: number;\n  // height?: number;\n  // padding?: number|string;\n  /**\n   * The width and height of the on-screen viewport, in pixels. If necessary, clipping and scrolling will be applied.\n   */\n  viewport?: number;\n  /**\n   * CSS color property to use as background of visualization. Default is `\"transparent\"`.\n   */\n  background?: string;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. This can be a single number or an object with `\"top\"`, `\"left\"`, `\"right\"`, `\"bottom\"` properties.\n   *\n   * __Default value__: `5`\n   *\n   * * @minimum 0\n   */\n  padding?: Padding;\n\n  /**\n   * D3 Number format for axis labels and text tables. For example \"s\" for SI units.\n   */\n  numberFormat?: string;\n\n  /**\n   * Default datetime format for axis and legend labels. The format can be set directly on each axis and legend.\n   */\n  timeFormat?: string;\n\n  /**\n   * Default axis and legend title for count fields.\n   * @type {string}\n   */\n  countTitle?: string;\n\n  /** Cell Config */\n  cell?: CellConfig;\n\n  /** Default stack offset for stackable mark. */\n  stack?: StackOffset;\n\n  /** Mark Config */\n  mark?: MarkConfig;\n\n  // MARK-SPECIFIC CONFIGS\n  /** Area-Specific Config */\n  area?: MarkConfig;\n\n  /** Bar-Specific Config */\n  bar?: BarConfig;\n\n  /** Circle-Specific Config */\n  circle?: MarkConfig;\n\n  /** Line-Specific Config */\n  line?: MarkConfig;\n\n  /** Point-Specific Config */\n  point?: MarkConfig;\n\n  /** Rect-Specific Config */\n  rect?: MarkConfig;\n\n  /** Rule-Specific Config */\n  rule?: MarkConfig;\n\n  /** Square-Specific Config */\n  square?: MarkConfig;\n\n  /** Text-Specific Config */\n  text?: TextConfig;\n\n  /** Tick-Specific Config */\n  tick?: TickConfig;\n\n  // OTHER CONFIG\n\n  // FIXME: move this to line/area\n  /** Mark Overlay Config */\n  overlay?: OverlayConfig;\n\n  /** Scale Config */\n  scale?: ScaleConfig;\n\n  /**\n   * Scale range config, or properties defining named range arrays\n   * that can be used within scale range definitions\n   * (such as `{\"type\": \"ordinal\", \"range\": \"category\"}`).\n   * For default range that Vega-Lite adopts from Vega, see https://github.com/vega/vega-parser#scale-range-properties.\n   */\n  range?: {[name: string]: RangeConfig};\n\n  /** Axis Config */\n  axis?: AxisConfig;\n\n  /** Legend Config */\n  legend?: LegendConfig;\n\n  /** Facet Config */\n  facet?: FacetConfig;\n\n  /** Selection Config */\n  selection?: SelectionConfig;\n}\n\nexport const defaultConfig: Config = {\n  padding: 5,\n  numberFormat: 's',\n  timeFormat: '%b %d, %Y',\n  countTitle: 'Number of Records',\n\n  cell: defaultCellConfig,\n\n  mark: mark.defaultMarkConfig,\n  area: {},\n  bar: mark.defaultBarConfig,\n  circle: {},\n  line: {},\n  point: {},\n  rect: {},\n  rule: {},\n  square: {},\n  text: mark.defaultTextConfig,\n  tick: mark.defaultTickConfig,\n\n  overlay: defaultOverlayConfig,\n  scale: defaultScaleConfig,\n  axis: defaultAxisConfig,\n  legend: defaultLegendConfig,\n\n  facet: defaultFacetConfig,\n\n  selection: defaultSelectionConfig\n};\n","/*\n * Constants and utilities for data.\n */\n\nexport interface DataFormat {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`.\n   * The default format type is determined by the extension of the file url.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: DataFormatType;\n\n  /**\n   * A collection of parsing instructions can be used to define the data types of string-valued attributes in the JSON file. Each instruction is a name-value pair, where the name is the name of the attribute, and the value is the desired data type (one of `\"number\"`, `\"boolean\"` or `\"date\"`). For example, `\"parse\": {\"modified_on\":\"date\"}` ensures that the `modified_on` value in each row of the input data is parsed as a Date value. (See Datalib's [`dl.read.types` method](https://github.com/vega/datalib/wiki/Import#dl_read_types) for more information.)\n   */\n  parse?: any;\n\n  /**\n   * JSON only) The JSON property containing the desired data.\n   * This parameter can be used when the loaded JSON file may have surrounding structure or meta-data.\n   * For example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features`\n   * from the loaded JSON object.\n   */\n  property?: string;\n\n  /**\n   * The name of the TopoJSON object set to convert to a GeoJSON feature collection.\n   * For example, in a map of the world, there may be an object set named `\"countries\"`.\n   * Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.\n   */\n  feature?: string;\n  /**\n   * The name of the TopoJSON object set to convert to a mesh.\n   * Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.\n   *  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features.\n   * Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.\n   */\n  mesh?: string;\n}\n\nexport type DataFormatType = 'json' | 'csv' | 'tsv' | 'topojson';\n\nexport type Data = UrlData | InlineData | NamedData;\n\nexport interface UrlData {\n  /**\n   * An object that specifies the format for the data file or values.\n   */\n  format?: DataFormat;\n\n  /**\n   * A URL from which to load the data set. Use the format.type property\n   * to ensure the loaded data is correctly parsed.\n   */\n  url: string;\n}\n\nexport interface InlineData {\n  /**\n   * Pass array of objects instead of a url to a file.\n   */\n  values: any[];\n}\n\nexport interface NamedData {\n  /**\n   * Provide a placeholder name and bind data at runtime.\n   */\n  name: string;\n}\n\nexport function isUrlData(data: Data): data is UrlData {\n  return !!data['url'];\n}\n\nexport function isInlineData(data: Data): data is InlineData {\n  return !!data['values'];\n}\n\nexport function isNamedData(data: Data): data is NamedData {\n  return !!data['name'];\n}\n\nexport type DataSourceType = 'source' | 'summary' | 'stacked' | 'layout';\n\nexport const SUMMARY: 'summary' = 'summary';\nexport const SOURCE: 'source' = 'source';\nexport const STACKED: 'stacked' = 'stacked';\nexport const LAYOUT: 'layout' = 'layout';\n","// DateTime definition object\n\nimport {duplicate, keys, isNumber} from './util';\nimport * as log from './log';\n\n/*\n * A designated year that starts on Sunday.\n */\nconst SUNDAY_YEAR = 2006;\n\n/**\n * @minimum 1\n * @maximum 12\n * @TJS-type integer\n */\nexport type Month = number;\n\n/**\n * @minimum 1\n * @maximum 7\n */\nexport type Day = number;\n\n/**\n * Object for defining datetime in Vega-Lite Filter.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n * We accept string for month and day names.\n */\nexport interface DateTime {\n  /**\n   * Integer value representing the year.\n   * @TJS-type integer\n   */\n  year?: number;\n\n  /**\n   * Integer value representing the quarter of the year (from 1-4).\n   * @minimum 1\n   * @maximum 4\n   * @TJS-type integer\n   */\n  quarter?: number;\n\n  /** One of: (1) integer value representing the month from `1`-`12`. `1` represents January;  (2) case-insensitive month name (e.g., `\"January\"`);  (3) case-insensitive, 3-character short month name (e.g., `\"Jan\"`). */\n  month?: Month | string;\n\n  /**\n   * Integer value representing the date from 1-31.\n   * @minimum 1\n   * @maximum 31\n   * @TJS-type integer\n   */\n  date?: number;\n\n  /**\n   * Value representing the day of week.  This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `\"Monday\"`);  (3) case-insensitive, 3-character short day name (e.g., `\"Mon\"`).   <br/> **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.\n   */\n  day?: Day | string;\n\n  /**\n   * Integer value representing the hour of day from 0-23.\n   * @minimum 0\n   * @maximum 23\n   * @TJS-type integer\n   */\n  hours?: number;\n\n  /**\n   * Integer value representing minute segment of a time from 0-59.\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  minutes?: number;\n\n  /**\n   * Integer value representing second segment of a time from 0-59.\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  seconds?: number;\n\n  /**\n   * Integer value representing millisecond segment of a time.\n   * @minimum 0\n   * @maximum 999\n   * @TJS-type integer\n   */\n  milliseconds?: number;\n}\n\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\nexport interface DateTimeExpr {\n  year?: string;\n  quarter?: string;\n  month?: string;\n  date?: string;\n  day?: string;\n  hours?: string;\n  minutes?: string;\n  seconds?: string;\n  milliseconds?: string;\n}\n\nexport function isDateTime(o: any): o is DateTime {\n  return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\n    !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);\n}\n\nexport const MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nexport const SHORT_MONTHS = MONTHS.map((m) => m.substr(0, 3));\n\nexport const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexport const SHORT_DAYS = DAYS.map((d) => d.substr(0,3));\n\nfunction normalizeQuarter(q: number | string) {\n  if (isNumber(q)) {\n    if (q > 4) {\n      log.warn(log.message.invalidTimeUnit('quarter', q));\n    }\n    // We accept 1-based quarter, so need to readjust to 0-based quarter\n    return (q - 1) + '';\n  } else {\n    // Invalid quarter\n    throw new Error(log.message.invalidTimeUnit('quarter', q));\n  }\n}\n\nfunction normalizeMonth(m: string | number) {\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return (m - 1) + '';\n  } else {\n    const lowerM = m.toLowerCase();\n    const monthIndex = MONTHS.indexOf(lowerM);\n    if (monthIndex !== -1) {\n      return monthIndex + ''; // 0 for january, ...\n    }\n    const shortM = lowerM.substr(0, 3);\n    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n    if (shortMonthIndex !== -1) {\n      return shortMonthIndex + '';\n    }\n    // Invalid month\n    throw new Error(log.message.invalidTimeUnit('month', m));\n  }\n}\n\nfunction normalizeDay(d: string | number) {\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return (d % 7) + '';\n  } else {\n    const lowerD = d.toLowerCase();\n    const dayIndex = DAYS.indexOf(lowerD);\n    if (dayIndex !== -1) {\n      return dayIndex + ''; // 0 for january, ...\n    }\n    const shortD = lowerD.substr(0, 3);\n    const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n    if (shortDayIndex !== -1) {\n      return shortDayIndex + '';\n    }\n    // Invalid day\n    throw new Error(log.message.invalidTimeUnit('day', d));\n  }\n}\n\nexport function timestamp(d: DateTime, normalize: boolean) {\n  const date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n\n  // FIXME support UTC\n\n  if (d.day !== undefined) {\n    if (keys(d).length > 1) {\n      log.warn(log.message.droppedDay(d));\n      d = duplicate(d);\n      delete d.day;\n    } else {\n      // Use a year that has 1/1 as Sunday so we can setDate below\n      date.setFullYear(SUNDAY_YEAR);\n\n      const day = normalize ? normalizeDay(d.day) : d.day;\n      date.setDate(+day + 1); // +1 since date start at 1 in JS\n    }\n  }\n\n  if (d.year !== undefined) {\n    date.setFullYear(d.year);\n  }\n\n  if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    date.setMonth(+quarter * 3);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    date.setMonth(+month);\n  }\n\n  if (d.date !== undefined) {\n    date.setDate(d.date);\n  }\n\n  if (d.hours !== undefined) {\n    date.setHours(d.hours);\n  }\n\n  if (d.minutes !== undefined) {\n    date.setMinutes(d.minutes);\n  }\n\n  if (d.seconds !== undefined) {\n    date.setSeconds(d.seconds);\n  }\n\n  if (d.milliseconds !== undefined) {\n    date.setMilliseconds(d.milliseconds);\n  }\n\n  return date.getTime();\n}\n\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nexport function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {\n  const units: (string | number)[] = [];\n\n  if (normalize && d.day !== undefined) {\n    if (keys(d).length > 1) {\n      log.warn(log.message.droppedDay(d));\n      d = duplicate(d);\n      delete d.day;\n    }\n  }\n\n  if (d.year !== undefined) {\n    units.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    units.push(SUNDAY_YEAR);\n  } else {\n    units.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    units.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    units.push(quarter + '*3');\n  } else {\n    units.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    units.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    units.push(day + '+1');\n  } else {\n    units.push(1); // Date starts at 1 in JS\n  }\n\n  // Note: can't use TimeUnit enum here as importing it will create\n  // circular dependency problem!\n  for (let timeUnit of ['hours', 'minutes', 'seconds', 'milliseconds']) {\n    if (d[timeUnit] !== undefined) {\n      units.push(d[timeUnit]);\n    } else {\n      units.push(0);\n    }\n  }\n\n  return 'datetime(' + units.join(', ') + ')';\n}\n","// utility for encoding mapping\nimport {FieldDef, PositionFieldDef, LegendFieldDef, OrderFieldDef, ValueDef, TextFieldDef, isFieldDef, ChannelDef, isValueDef, normalize, ConditionalValueDef} from './fielddef';\nimport {Channel, CHANNELS, supportMark} from './channel';\nimport {Facet} from './facet';\nimport {isArray, some, duplicate} from './util';\nimport {Mark} from './mark';\nimport * as log from './log';\n\nexport interface Encoding {\n  /**\n   * X coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  x?: PositionFieldDef | ValueDef<number>;\n\n  /**\n   * Y coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  y?: PositionFieldDef | ValueDef<number>;\n\n  /**\n   * X2 coordinates for ranged `bar`, `rule`, `area`\n   */\n  x2?: FieldDef | ValueDef<number>;\n\n  /**\n   * Y2 coordinates for ranged `bar`, `rule`, `area`\n   */\n  y2?: FieldDef | ValueDef<number>;\n\n  /**\n   * Color of the marks – either fill or stroke color based on mark type.\n   * (By default, fill color for `area`, `bar`, `tick`, `text`, `circle`, and `square` /\n   * stroke color for `line` and `point`.)\n   */\n  color?: LegendFieldDef<string> | ConditionalValueDef<string>;\n\n  /**\n   * Opacity of the marks – either can be a value or in a range.\n   */\n  opacity?: LegendFieldDef<number> | ConditionalValueDef<number>;\n\n  /**\n   * Size of the mark.\n   * - For `point`, `square` and `circle`\n   * – the symbol size, or pixel area of the mark.\n   * - For `bar` and `tick` – the bar and tick's size.\n   * - For `text` – the text's font size.\n   * - Size is currently unsupported for `line` and `area`.\n   */\n  size?: LegendFieldDef<number> | ConditionalValueDef<number>;\n\n  /**\n   * The symbol's shape (only for `point` marks). The supported values are\n   * `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\n   * or `\"triangle-down\"`, or else a custom SVG path string.\n   */\n  shape?: LegendFieldDef<string> | ConditionalValueDef<string>; // TODO: maybe distinguish ordinal-only\n\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDef | FieldDef[];\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: TextFieldDef | ConditionalValueDef<string|number>;\n\n  /**\n   * stack order for stacked marks or order of data points in line marks.\n   */\n  order?: OrderFieldDef | OrderFieldDef[];\n}\n\nexport interface EncodingWithFacet extends Encoding, Facet {}\n\nexport function channelHasField(encoding: EncodingWithFacet, channel: Channel): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, (fieldDef) => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function isAggregate(encoding: EncodingWithFacet) {\n  return some(CHANNELS, (channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);\n      } else {\n        return isFieldDef(channelDef) && !!channelDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function dropInvalidFieldDefs(mark: Mark, encoding: Encoding): Encoding {\n\n  // clone to prevent side effect to the original spec\n  encoding = duplicate(encoding);\n\n  Object.keys(encoding).forEach((channel: Channel) => {\n    if (!supportMark(channel, mark)) {\n      // Drop unsupported channel\n\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      delete encoding[channel];\n      return;\n    }\n\n    // Drop line's size if the field is aggregated.\n    if (channel === 'size' && mark === 'line') {\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef) && channelDef.aggregate) {\n        log.warn(log.message.incompatibleChannel(channel, mark, 'when the field is aggregated.'));\n        delete encoding[channel];\n      }\n      return;\n    }\n\n    if (isArray(encoding[channel])) {\n      // Array of fieldDefs for detail channel (or production rule)\n      encoding[channel] = encoding[channel].reduce((channelDefs: ChannelDef[], channelDef: ChannelDef) => {\n        if (!isFieldDef(channelDef) && !isValueDef(channelDef)) { // TODO: datum\n          log.warn(log.message.emptyFieldDef(channelDef, channel));\n        } else {\n          channelDefs.push(normalize(channelDef, channel));\n        }\n        return channelDefs;\n      }, []);\n    } else {\n      const channelDef = encoding[channel];\n      if (!isFieldDef(channelDef) && !isValueDef(channelDef)) { // TODO: datum\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        delete encoding[channel];\n        return;\n      }\n      normalize(channelDef, channel);\n    }\n  });\n  return encoding;\n}\n\n\nexport function isRanged(encoding: EncodingWithFacet) {\n  return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\n\nexport function fieldDefs(encoding: EncodingWithFacet): FieldDef[] {\n  let arr: FieldDef[] = [];\n  CHANNELS.forEach(function(channel) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n        arr.push(fieldDef);\n      });\n    }\n  });\n  return arr;\n};\n\nexport function forEach(mapping: any,\n    f: (fd: FieldDef, c: Channel) => void,\n    thisArg?: any) {\n  if (!mapping) {\n    return;\n  }\n\n  Object.keys(mapping).forEach((c: any) => {\n    const channel: Channel = c;\n    if (isArray(mapping[channel])) {\n      mapping[channel].forEach(function(channelDef: ChannelDef) {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, mapping[channel], channel);\n    }\n  });\n}\n\nexport function reduce<T, U>(mapping: U,\n    f: (acc: any, fd: FieldDef, c: Channel) => U,\n    init: T, thisArg?: any) {\n  if (!mapping) {\n    return init;\n  }\n\n  return Object.keys(mapping).reduce((r: T, c: any) => {\n    const channel: Channel = c;\n    if (isArray(mapping[channel])) {\n      return mapping[channel].reduce(function(r1: T, channelDef: ChannelDef) {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, mapping[channel], channel);\n    }\n  }, init);\n}\n","// utility for a field definition object\n\nimport {AggregateOp} from './aggregate';\nimport {Axis} from './axis';\nimport {Bin} from './bin';\nimport {Channel, rangeType} from './channel';\nimport {Config} from './config';\nimport {Legend} from './legend';\nimport * as log from './log';\nimport {Scale} from './scale';\nimport {StackOffset} from './stack';\nimport {SortField, SortOrder} from './sort';\nimport {TimeUnit, isDiscreteByDefault} from './timeunit';\nimport {Type, getFullName} from './type';\n\n/**\n * Definition object for a constant value of an encoding channel.\n */\nexport interface ValueDef<T> {\n  /**\n   * A constant value in visual domain.\n   */\n  value?: T;\n}\n\nexport interface ConditionalValueDef<T> extends ValueDef<T> {\n  condition?: Condition<T>;\n}\n\n/**\n *  Definition object for a data field, its type and transformation of an encoding channel.\n */\nexport interface FieldDef {\n  /**\n   * Name of the field from which to pull a data value.\n   */\n  field?: string;\n\n  /**\n   * The encoded field's type of measurement. This can be either a full type\n   * name (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`,  and `\"nominal\"`)\n   * or an initial character of the type name (`\"Q\"`, `\"T\"`, `\"O\"`, `\"N\"`).\n   * This property is case insensitive.\n   */\n  type?: Type;\n\n\n  // function\n\n  /**\n   * Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Flag for binning a `quantitative` field, or a bin property object\n   * for binning parameters.\n   */\n  bin?: boolean | Bin;\n\n  /**\n   * Aggregation function for the field\n   * (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n   */\n  aggregate?: AggregateOp;\n\n  /**\n   * Title for axis or legend.\n   */\n  title?: string;\n}\n\nexport interface Condition<T> {\n  selection: string;\n  value: T;\n}\n\nexport interface ScaleFieldDef extends FieldDef {\n  scale?: Scale;\n  sort?: SortField | SortOrder;\n}\n\nexport interface PositionFieldDef extends ScaleFieldDef {\n  /**\n   * @nullable\n   */\n  axis?: Axis;\n\n  /**\n   * Type of stacking offset if the field should be stacked.\n   * \"none\" or null, if the field should not be stacked.\n   */\n  stack?: StackOffset;\n}\nexport interface LegendFieldDef<T> extends ScaleFieldDef {\n   /**\n    * @nullable\n    */\n  legend?: Legend;\n\n  condition?: Condition<T>;\n}\n\n// Detail\n\n// Order Path have no scale\n\nexport interface OrderFieldDef extends FieldDef {\n  sort?: SortOrder;\n}\n\nexport interface TextFieldDef extends FieldDef {\n  // FIXME: add more reference to Vega's format pattern or d3's format pattern.\n  /**\n   * The formatting pattern for text value. If not defined, this will be determined automatically.\n   */\n  format?: string;\n\n  condition?: Condition<string|number>;\n};\n\nexport type ChannelDef = FieldDef | ValueDef<any>;\n\nexport function isFieldDef(channelDef: ChannelDef): channelDef is FieldDef | PositionFieldDef | LegendFieldDef<any> | OrderFieldDef | TextFieldDef {\n  return channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\n\nexport function isValueDef(channelDef: ChannelDef): channelDef is ValueDef<any> {\n  return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;\n}\n\n// TODO: consider if we want to distinguish ordinalOnlyScale from scale\nexport type FacetFieldDef = PositionFieldDef;\n\nexport interface FieldRefOption {\n  /** exclude bin, aggregate, timeUnit */\n  nofn?: boolean;\n  /** Wrap the field inside datum[...] per Vega convention */\n  datum?: boolean;\n  /** prepend fn with custom function prefix */\n  prefix?: string;\n  /** append suffix to the field ref for bin (default='start') */\n  binSuffix?: 'start' | 'end' | 'range';\n  /** append suffix to the field ref (general) */\n  suffix?: string;\n  /** Overrride which aggregate to use. Needed for unaggregated domain. */\n  aggregate?: AggregateOp;\n}\n\nexport function field(fieldDef: FieldDef, opt: FieldRefOption = {}) {\n  let field = fieldDef.field;\n  let prefix = opt.prefix;\n  let suffix = opt.suffix;\n\n  if (isCount(fieldDef)) {\n    field = 'count_*';\n  } else {\n    let fn: string = undefined;\n\n    if (!opt.nofn) {\n      if (fieldDef.bin) {\n        fn = 'bin';\n        suffix = opt.binSuffix;\n      } else if (fieldDef.aggregate) {\n        fn = String(opt.aggregate || fieldDef.aggregate);\n      } else if (fieldDef.timeUnit) {\n        fn = String(fieldDef.timeUnit);\n      }\n    }\n\n    if (!!fn) {\n      field = `${fn}_${field}`;\n    }\n  }\n\n  if (!!suffix) {\n    field = `${field}_${suffix}`;\n  }\n\n  if (!!prefix) {\n    field = `${prefix}_${field}`;\n  }\n\n  if (opt.datum) {\n    field = `datum[\"${field}\"]`;\n  }\n\n  return field;\n}\n\nexport function isDiscrete(fieldDef: FieldDef) {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      return true;\n    case 'quantitative':\n      return !!fieldDef.bin;\n    case 'temporal':\n      // TODO: deal with custom scale type case.\n      return isDiscreteByDefault(fieldDef.timeUnit);\n  }\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n\nexport function isContinuous(fieldDef: FieldDef) {\n  return !isDiscrete(fieldDef);\n}\n\nexport function isCount(fieldDef: FieldDef) {\n  return fieldDef.aggregate === 'count';\n}\n\nexport function title(fieldDef: FieldDef, config: Config) {\n  if (fieldDef.title != null) {\n    return fieldDef.title;\n  }\n  if (isCount(fieldDef)) {\n    return config.countTitle;\n  }\n  const fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n  if (fn) {\n    return fn.toUpperCase() + '(' + fieldDef.field + ')';\n  } else {\n    return fieldDef.field;\n  }\n}\n\nexport function defaultType(fieldDef: FieldDef, channel: Channel): Type {\n  if (!!fieldDef.timeUnit) {\n    return 'temporal';\n  }\n  if (!!fieldDef.bin) {\n    return 'quantitative';\n  }\n  switch (rangeType(channel)) {\n    case 'continuous':\n      return 'quantitative';\n    case 'discrete':\n      return 'nominal';\n    case 'flexible': // color\n      return 'nominal';\n    default:\n      return 'quantitative';\n  }\n}\n\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function normalize(fieldDef: ChannelDef, channel: Channel) {\n  // If a fieldDef contains a field, we need type.\n  if (isFieldDef(fieldDef)) { // TODO: or datum\n    // convert short type to full type\n    const fullType = getFullName(fieldDef.type);\n    if (fullType) {\n      fieldDef.type = fullType;\n    } else {\n      // If type is empty / invalid, then augment with default type\n      const newType = defaultType(fieldDef, channel);\n      log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));\n      fieldDef.type = newType;\n    }\n\n    const {compatible, warning} = channelCompatibility(fieldDef, channel);\n    if (!compatible) {\n      log.warn(warning);\n    }\n  }\n  return fieldDef;\n}\n\nconst COMPATIBLE = {compatible: true};\nexport function channelCompatibility(fieldDef: FieldDef, channel: Channel): {compatible: boolean; warning?: string;} {\n  switch (channel) {\n    case 'row':\n    case 'column':\n      if (isContinuous(fieldDef) && !fieldDef.timeUnit) {\n        // TODO:(https://github.com/vega/vega-lite/issues/2011):\n        // with timeUnit it's not always strictly continuous\n        return {\n          compatible: false,\n          warning: log.message.facetChannelShouldBeDiscrete(channel)\n        };\n      }\n      return COMPATIBLE;\n\n    case 'x':\n    case 'y':\n    case 'color':\n    case 'text':\n    case 'detail':\n      return COMPATIBLE;\n\n    case 'opacity':\n    case 'size':\n    case 'x2':\n    case 'y2':\n      if (isDiscrete(fieldDef) && !fieldDef.bin) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should not be used with discrete field.`\n        };\n      }\n      return COMPATIBLE;\n\n    case 'shape':\n      if (fieldDef.type !== 'nominal') {\n        return {\n          compatible: false,\n          warning: 'Shape channel should be used with nominal data only'\n        };\n      } else {\n        return COMPATIBLE;\n      }\n\n    case 'order':\n      if (fieldDef.type === 'nominal') {\n        return {\n          compatible: false,\n          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n        };\n      }\n      return COMPATIBLE;\n  }\n  throw new Error('channelCompatability not implemented for channel ' + channel);\n}\n","import {DateTime, dateTimeExpr, isDateTime} from './datetime';\nimport {field} from './fielddef';\nimport {TimeUnit, fieldExpr as timeUnitFieldExpr, isSingleTimeUnit} from './timeunit';\nimport {isArray, isString} from './util';\n\nexport type Filter = EqualFilter | RangeFilter | OneOfFilter ;\n\n\nexport interface EqualFilter {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered.\n   */\n  field: string;\n\n  /**\n   * Value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime;\n\n}\n\nexport function isEqualFilter(filter: any): filter is EqualFilter {\n  return filter && !!filter.field && filter.equal!==undefined;\n}\n\nexport interface RangeFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * Array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: (number|DateTime)[];\n\n}\n\nexport function isRangeFilter(filter: any): filter is RangeFilter {\n  if (filter && !!filter.field) {\n    if (isArray(filter.range) && filter.range.length === 2) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface OneOfFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: (string|number|boolean|DateTime)[];\n\n}\n\nexport function isOneOfFilter(filter: any): filter is OneOfFilter {\n  return filter && !!filter.field && (\n    isArray(filter.oneOf) ||\n    isArray(filter.in) // backward compatibility\n  );\n}\n\nexport function expression(filter: Filter | string) {\n  if (isString(filter)) {\n    return filter as string;\n  } else { // Filter Object\n    const fieldExpr = filter.timeUnit ?\n      // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n        // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n        // TODO: support utc\n      ('time(' + timeUnitFieldExpr(filter.timeUnit, filter.field) + ')') :\n      field(filter, {datum: true});\n\n    if (isEqualFilter(filter)) {\n      return fieldExpr + '===' + valueExpr(filter.equal, filter.timeUnit);\n    } else if (isOneOfFilter(filter)) {\n      // \"oneOf\" was formerly \"in\" -- so we need to add backward compatibility\n      const oneOf: OneOfFilter[] = filter.oneOf || filter['in'];\n      return 'indexof([' +\n        oneOf.map((v) => valueExpr(v, filter.timeUnit)).join(',') +\n        '], ' + fieldExpr + ') !== -1';\n    } else if (isRangeFilter(filter)) {\n      const lower = filter.range[0];\n      const upper = filter.range[1];\n\n      if (lower !== null &&  upper !== null) {\n        return 'inrange(' + fieldExpr + ', ' +\n          valueExpr(lower, filter.timeUnit) + ', ' +\n          valueExpr(upper, filter.timeUnit) + ')';\n      } else if (lower !== null) {\n        return fieldExpr + ' >= ' + lower;\n      } else if (upper !== null) {\n        return fieldExpr + ' <= ' + upper;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction valueExpr(v: any, timeUnit: TimeUnit) {\n  if (isDateTime(v)) {\n    const expr = dateTimeExpr(v, true);\n    return 'time(' + expr + ')';\n  }\n  if (isSingleTimeUnit(timeUnit)) {\n    const datetime: DateTime = {};\n    datetime[timeUnit] = v;\n    const expr = dateTimeExpr(datetime, true);\n    return 'time(' + expr + ')';\n  }\n  return JSON.stringify(v);\n}\n","import {DateTime} from './datetime';\nimport {VgLegendEncode, VgLegendBase, VgLegendConfig} from './vega.schema';\n\nexport interface LegendConfig extends VgLegendConfig {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n}\n\n/**\n * Properties of a legend or boolean flag for determining whether to show it.\n */\nexport interface Legend extends VgLegendBase {\n  /**\n   * Optional mark definitions for custom legend encoding.\n   */\n  encode?: VgLegendEncode;\n\n  /**\n   * An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.\n   */\n  format?: string;\n\n  /**\n   * The desired number of tick values for quantitative legends.\n   */\n  tickCount?: number;\n\n  /**\n   * A title for the legend. (Shows field name and its function by default.)\n   */\n  title?: string;\n  /**\n   * Explicitly set the visible legend values.\n   */\n  values?: number[] | string[] | DateTime[];\n\n  /**\n   * The name of a scale that maps to a shape value.\n   */\n  shape?: string;\n\n  /**\n   * The type of the legend. Use `symbol` to create a discrete legend and `gradient` for a continuous color gradient.\n   */\n  type?: 'symbol' | 'gradient';\n\n  /**\n   * A non-positive integer indicating z-index of the legend.\n   * If zindex is 0, legend should be drawn behind all chart elements.\n   * To put them in front, use zindex = 1.\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n}\n\nexport const defaultLegendConfig: LegendConfig = {\n  orient: undefined, // implicitly \"right\"\n};\n\nexport const LEGEND_PROPERTIES:(keyof Legend)[] = ['entryPadding', 'format', 'offset', 'orient', 'tickCount', 'title', 'type', 'values' ,'zindex'];\n","///<reference path=\"../typings/vega-util.d.ts\" />\n\n/**\n * Vega-Lite's singleton logger utility.\n */\n\nimport {logger, LoggerInterface, Warn} from 'vega-util';\n\nimport {AggregateOp} from './aggregate';\nimport {Channel} from './channel';\nimport {DateTime, DateTimeExpr} from './datetime';\nimport {FieldDef} from './fielddef';\nimport {Mark} from './mark';\nimport {TimeUnit} from './timeunit';\nimport {Type} from './type';\nimport {ScaleType} from './scale';\n\nexport {LoggerInterface} from 'vega-util';\n\n/**\n * Main (default) Vega Logger instance for Vega-Lite\n */\nconst main = logger(Warn);\nlet current: LoggerInterface = main;\n\n/**\n * Logger tool for checking if the code throws correct warning\n */\nexport class LocalLogger implements LoggerInterface {\n  public warns: any[] = [];\n  public infos: any[] = [];\n  public debugs: any[] = [];\n\n  public level() {\n    return this;\n  }\n\n  public warn(...args: any[]) {\n    this.warns.push(...args);\n    return this;\n  }\n\n  public info(...args: any[]) {\n    this.infos.push(...args);\n    return this;\n  }\n\n  public debug(...args: any[]) {\n    this.debugs.push(...args);\n    return this;\n  }\n}\n\nexport function runLocalLogger(f: (localLogger: LocalLogger) => void) {\n  const localLogger = current = new LocalLogger();\n  f(localLogger);\n  reset();\n}\n\nexport function wrap(f: (logger: LocalLogger) => void) {\n  return () => {\n    const logger = current = new LocalLogger();\n    f(logger);\n    reset();\n  };\n}\n\n/**\n * Set the singleton logger to be a custom logger\n */\nexport function set(logger: LoggerInterface) {\n  current = logger;\n  return current;\n}\n\n/**\n * Reset the main logger to use the default Vega Logger\n */\nexport function reset() {\n  current = main;\n  return current;\n}\n\nexport function warn(..._: any[]) {\n  current.warn.apply(current, arguments);\n}\n\nexport function info(..._: any[]) {\n  current.info.apply(current, arguments);\n}\n\nexport function debug(..._: any[]) {\n  current.debug.apply(current, arguments);\n}\n\n/**\n * Collection of all Vega-Lite Error Messages\n */\nexport namespace message {\n  export const INVALID_SPEC = 'Invalid spec';\n\n  // DATA\n  export const DEPRECATED_FILTER_NULL = 'filterNull is deprecated. Please use filterInvalid instead.';\n\n  // ENCODING & FACET\n  export function invalidFieldType(type: Type) {\n    return `Invalid field type \"${type}\"`;\n  }\n\n  export function emptyOrInvalidFieldType(type: Type | string, channel: Channel, newType: Type) {\n    return `Invalid field type (${type}) for channel ${channel}, using ${newType} instead.`;\n  }\n\n  export function emptyFieldDef(fieldDef: FieldDef, channel: Channel) {\n    return `Dropping ${JSON.stringify(fieldDef)} from channel ${channel} since it does not contain data field or value.`;\n  }\n\n  export function incompatibleChannel(channel: Channel, markOrFacet: Mark | 'facet', when?: string) {\n    return `${channel} dropped as it is incompatible with ${markOrFacet}` +\n      when ? `when ${when}` : '';\n  }\n\n  export function facetChannelShouldBeDiscrete(channel: string) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n  }\n\n  export function discreteChannelCannotEncode(channel: Channel, type: Type) {\n    return `Using discrete channel ${channel} to encode ${type} field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n  }\n\n  // Mark\n  export const BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL = 'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';\n\n  export function unclearOrientContinuous(mark: Mark) {\n    return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode continous fields. In this case, we use vertical by default';\n  }\n\n  export function unclearOrientDiscreteOrEmpty(mark: Mark) {\n    return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode discrete or empty fields.';\n  }\n\n  export function orientOverridden(original: string, actual: string) {\n    return `Specified orient ${original} overridden with ${actual}`;\n  }\n\n  // SCALE\n  export const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'custom domain scale cannot be unioned with default field-based domain';\n\n  export function cannotUseScalePropertyWithNonColor(prop: string) {\n    return `Cannot use ${prop} with non-color channel.`;\n  }\n\n  export function unaggregateDomainHasNoEffectForRawField(fieldDef: FieldDef) {\n    return `Using unaggregated domain with raw field has no effect (${JSON.stringify(fieldDef)}).`;\n  }\n\n  export function unaggregateDomainWithNonSharedDomainOp(aggregate: AggregateOp) {\n    return `Unaggregated domain not applicable for ${aggregate} since it produces values outside the origin domain of the source data.`;\n  }\n\n  export function unaggregatedDomainWithLogScale(fieldDef: FieldDef) {\n    return `Unaggregated domain is currently unsupported for log scale (${JSON.stringify(fieldDef)}).`;\n  }\n\n  export const CANNOT_USE_RANGE_WITH_POSITION =\n    'Cannot use custom range with x or y channel.  Please customize width, height, padding, or rangeStep instead.';\n\n    export const CANNOT_USE_PADDING_WITH_FACET = 'Cannot use padding with facet\\'s scale.  Please use spacing instead.';\n\n  export function cannotUseRangePropertyWithFacet(propName: string) {\n    return `Cannot use custom ${propName} with row or column channel. Please use width, height, or spacing instead.`;\n  }\n\n  export function rangeStepDropped(channel: Channel) {\n    return `rangeStep for ${channel} is dropped as top-level ${\n      channel === 'x' ? 'width' : 'height'} is provided.`;\n  }\n\n  export function cannotOverrideBinScaleType(channel: Channel, defaultScaleType: ScaleType) {\n    return `Cannot override scale type for binned channel ${channel}. We are using ${defaultScaleType} scale instead.`;\n  }\n\n  export function scaleTypeNotWorkWithChannel(channel: Channel, scaleType: ScaleType, defaultScaleType: ScaleType) {\n    return `Channel ${channel} does not work with ${scaleType} scale. We are using ${defaultScaleType} scale instead.`;\n  }\n\n  export function scalePropertyNotWorkWithScaleType(scaleType: ScaleType, propName: string, channel: Channel) {\n    return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n  }\n\n  export function scaleTypeNotWorkWithMark(mark: Mark, scaleType: ScaleType) {\n    return `Scale type \"${scaleType}\" does not work with mark ${mark}.`;\n  }\n\n  export const INVAID_DOMAIN = 'Invalid scale domain';\n\n  export const UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains';\n\n  // AXIS\n  export const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n\n  // STACK\n  export function cannotStackRangedMark(channel: Channel) {\n    return `Cannot stack ${channel} if there is already ${channel}2`;\n  }\n\n  export function cannotStackNonLinearScale(scaleType: ScaleType) {\n    return `Cannot stack non-linear scale (${scaleType})`;\n  }\n\n  export function cannotStackNonSummativeAggregate(aggregate: AggregateOp) {\n    return `Cannot stack when the aggregate function is non-summative (${aggregate})`;\n  }\n\n  // TIMEUNIT\n  export function invalidTimeUnit(unitName: string, value: string | number) {\n    return `Invalid ${unitName}: ${value}`;\n  }\n\n  export function dayReplacedWithDate(fullTimeUnit: TimeUnit) {\n    return `Time unit \"${fullTimeUnit}\" is not supported. We are replacing it with ` +\n      (fullTimeUnit+'').replace('day', 'date') + '.';\n  }\n\n  export function droppedDay(d: DateTime | DateTimeExpr) {\n    return 'Dropping day from datetime ' + JSON.stringify(d) +\n          ' as day cannot be combined with other units.';\n  }\n}\n\n","import {toSet} from './util';\nimport {Orient, Interpolate, VgMarkConfig} from './vega.schema';\nexport {Orient} from './vega.schema';\n\nexport namespace Mark {\n  export const AREA: 'area' = 'area';\n  export const BAR: 'bar' = 'bar';\n  export const LINE: 'line' = 'line';\n  export const POINT: 'point' = 'point';\n  export const RECT: 'rect' = 'rect';\n  export const RULE: 'rule' = 'rule';\n  export const TEXT: 'text' = 'text';\n  export const TICK: 'tick' = 'tick';\n  export const CIRCLE: 'circle' = 'circle';\n  export const SQUARE: 'square' = 'square';\n}\n\n/**\n * All types of primitive marks.\n */\nexport type Mark = typeof Mark.AREA | typeof Mark.BAR | typeof Mark.LINE | typeof Mark.POINT | typeof Mark.TEXT | typeof Mark.TICK | typeof Mark.RECT | typeof Mark.RULE | typeof Mark.CIRCLE | typeof Mark.SQUARE;\n\n\nexport const AREA = Mark.AREA;\nexport const BAR = Mark.BAR;\nexport const LINE = Mark.LINE;\nexport const POINT = Mark.POINT;\nexport const TEXT = Mark.TEXT;\nexport const TICK = Mark.TICK;\nexport const RECT = Mark.RECT;\nexport const RULE = Mark.RULE;\n\nexport const CIRCLE = Mark.CIRCLE;\nexport const SQUARE = Mark.SQUARE;\n\nexport const PRIMITIVE_MARKS = [AREA, BAR, LINE, POINT, TEXT, TICK, RECT, RULE, CIRCLE, SQUARE];\n\nexport interface MarkDef {\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  type: Mark;\n\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  /**\n   * The line interpolation method to use for line and area marks. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n\n  /**\n   * Depending on the interpolation type, sets the tension parameter (for line and area marks).\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n}\n\nexport function isMarkDef(mark: string | MarkDef): mark is MarkDef {\n  return mark['type'];\n}\n\nconst PRIMITIVE_MARK_INDEX = toSet(PRIMITIVE_MARKS);\n\nexport function isPrimitiveMark(mark: string | MarkDef): mark is Mark {\n  const markType = isMarkDef(mark) ? mark.type : mark;\n  return markType in PRIMITIVE_MARK_INDEX;\n}\n\nexport const STROKE_CONFIG = ['stroke', 'strokeWidth',\n  'strokeDash', 'strokeDashOffset', 'strokeOpacity'];\n\nexport const FILL_CONFIG = ['fill', 'fillOpacity'];\n\nexport const FILL_STROKE_CONFIG = [].concat(STROKE_CONFIG, FILL_CONFIG);\n\nexport interface MarkConfig extends VgMarkConfig {\n\n  // ---------- Color ----------\n  /**\n   * Whether the shape\\'s color should be used as fill color instead of stroke color.\n   * This is only applicable for \"bar\", \"point\", and \"area\".\n   * All marks except \"point\", \"line\", and \"rule\" are filled by default.\n   */\n  filled?: boolean;\n\n  // TODO: remove this once we correctly integrate theme\n  /**\n   * Default color.\n   */\n  color?: string;\n}\n\nexport const defaultMarkConfig: MarkConfig = {\n  color: '#4c78a8',\n};\n\nexport interface BarConfig extends MarkConfig {\n  /**\n   * Offset between bar for binned field.  Ideal value for this is either 0 (Preferred by statisticians) or 1 (Vega-Lite Default, D3 example style).\n   * @minimum 0\n   */\n  binSpacing?: number;\n  /**\n   * Default size of the bars on continuous scales.\n   * @minimum 0\n   */\n  continuousBandSize?: number;\n\n  /**\n   * The size of the bars.  If unspecified, the default size is  `bandSize-1`,\n   * which provides 1 pixel offset between bars.\n   * @minimum 0\n   */\n  discreteBandSize?: number;\n}\n\nexport const defaultBarConfig: BarConfig = {\n  binSpacing: 1,\n  continuousBandSize: 2\n};\n\nexport interface TextConfig extends MarkConfig {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n}\n\nexport const defaultTextConfig: TextConfig = {\n  baseline: 'middle',\n};\n\nexport interface TickConfig extends MarkConfig {\n  /**\n   * The width of the ticks.\n   * If this value is undefined (by default,), we use 2/3 of rangeStep by default.\n   * @minimum 0\n   */\n  bandSize?: number;\n\n  /**\n   * Thickness of the tick mark.\n   * @minimum 0\n   */\n  thickness?: number;\n}\n\nexport const defaultTickConfig: TickConfig = {\n  thickness: 1\n};\n","import * as log from './log';\nimport {Channel} from './channel';\nimport {DateTime} from './datetime';\nimport {contains, toSet} from './util';\n\nexport namespace ScaleType {\n  // Continuous - Quantitative\n  export const LINEAR: 'linear' = 'linear';\n  export const BIN_LINEAR: 'bin-linear' = 'bin-linear';\n  export const LOG: 'log' = 'log';\n  export const POW: 'pow' = 'pow';\n  export const SQRT: 'sqrt' = 'sqrt';\n  // Continuous - Time\n  export const TIME: 'time' = 'time';\n  export const UTC: 'utc'  = 'utc';\n  // sequential\n  export const SEQUENTIAL: 'sequential' = 'sequential';\n\n  // Quantile, Quantize, threshold\n  export const QUANTILE: 'quantile' = 'quantile';\n  export const QUANTIZE: 'quantize' = 'quantize';\n  export const THRESHOLD: 'threshold' = 'threshold';\n\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const BIN_ORDINAL: 'bin-ordinal' = 'bin-ordinal';\n  export const POINT: 'point' = 'point';\n  export const BAND: 'band' = 'band';\n}\n\nexport type ScaleType = typeof ScaleType.LINEAR | typeof ScaleType.BIN_LINEAR |\n  typeof ScaleType.LOG | typeof ScaleType.POW | typeof ScaleType.SQRT |\n  typeof ScaleType.TIME | typeof ScaleType.UTC |\n  // TODO: add 'quantize', 'quantile', 'threshold' back when we really support them\n  typeof ScaleType.SEQUENTIAL | // typeof ScaleType.QUANTILE | typeof ScaleType.QUANTIZE | typeof ScaleType.THRESHOLD |\n  typeof ScaleType.ORDINAL | typeof ScaleType.BIN_ORDINAL | typeof ScaleType.POINT | typeof ScaleType.BAND;\n\nexport const SCALE_TYPES: ScaleType[] = [\n  // Continuous - Quantitative\n  'linear', 'bin-linear', 'log', 'pow', 'sqrt',\n  // Continuous - Time\n  'time', 'utc',\n  // Sequential\n  'sequential', // TODO: add 'quantile', 'quantize' when we really support them\n  // Discrete\n  'ordinal', 'bin-ordinal', 'point', 'band',\n];\n\nexport const CONTINUOUS_TO_CONTINUOUS_SCALES: ScaleType[] = ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc'];\nconst CONTINUOUS_TO_CONTINUOUS_INDEX = toSet(CONTINUOUS_TO_CONTINUOUS_SCALES);\n\nexport const CONTINUOUS_DOMAIN_SCALES: ScaleType[] = CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['sequential' /* TODO add 'quantile', 'quantize', 'threshold'*/]);\nconst CONTINUOUS_DOMAIN_INDEX = toSet(CONTINUOUS_DOMAIN_SCALES);\n\nexport const DISCRETE_DOMAIN_SCALES: ScaleType[] = ['ordinal', 'bin-ordinal', 'point', 'band'];\nconst DISCRETE_DOMAIN_INDEX = toSet(DISCRETE_DOMAIN_SCALES);\n\nconst BIN_SCALES_INDEX = toSet(['bin-linear', 'bin-ordinal']);\n\nexport const TIME_SCALE_TYPES: ScaleType[] = ['time', 'utc'];\n\nexport function hasDiscreteDomain(type: ScaleType): type is 'ordinal' | 'bin-ordinal' | 'point' | 'band' {\n  return type in DISCRETE_DOMAIN_INDEX;\n}\n\nexport function isBinScale(type: ScaleType): type is 'bin-linear' | 'bin-ordinal' {\n  return type in BIN_SCALES_INDEX;\n}\n\nexport function hasContinuousDomain(type: ScaleType):\n  type is 'linear' | 'log' | 'pow' | 'sqrt' |  'time' | 'utc'|\n          'sequential' /* TODO add | 'quantile' | 'quantize' | 'threshold' */ {\n  return type in CONTINUOUS_DOMAIN_INDEX;\n}\n\nexport function isContinuousToContinuous(type: ScaleType): type is 'linear' | 'bin-linear' | 'log' | 'pow' | 'sqrt' |  'time' | 'utc' {\n  return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\n\nexport type NiceTime = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n\nexport interface ScaleConfig {\n  /**\n   * If true, rounds numeric output values to integers.\n   * This can be helpful for snapping to the pixel grid.\n   * (Only available for `x`, `y`, `size`, `row`, and `column` scales.)\n   */\n  round?: boolean;\n\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   *  Default range step for `x` ordinal scale when is mark is `text`.\n   *  @minimum 0\n   */\n  textXRangeStep?: number; // FIXME: consider if we will rename this \"tableColumnWidth\"\n  /**\n   * Default range step for (1) `y` ordinal scale,\n   * and (2) `x` ordinal scale when the mark is not `text`.\n   *\n   * @minimum 0\n   * @nullable\n   */\n  rangeStep?: number | null;\n\n  /**\n   * Default inner padding for `x` and `y` band-ordinal scales.\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingInner?: number;\n\n  /**\n   * Default outer padding for `x` and `y` band-ordinal scales.\n   * If not specified, by default, band scale's paddingOuter is paddingInner/2.\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingOuter?: number;\n\n  /**\n   * Default outer padding for `x` and `y` point-ordinal scales.\n   * @minimum 0\n   * @maximum 1\n   */\n  pointPadding?: number;\n\n  /**\n   * Default spacing between faceted plots.\n   * @TJS-type integer\n   * @minimum 0\n   */\n  facetSpacing?: number;\n\n  /**\n   * Use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  useUnaggregatedDomain?: boolean;\n\n  // nice should depends on type (quantitative or temporal), so\n  // let's not make a config.\n\n  // Configs for Range\n\n\n  /**\n   * The default max value for mapping quantitative fields to bar's size/bandSize.\n   * If undefined (default), we will use bandSize - 1.\n   * @minimum 0\n   */\n  maxBandSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to bar and tick's size/bandSize scale with zero=false\n   * If undefined (default), we will use the `continuousBandSize` value for bar and 3 for ticks.\n   * @minimum 0\n   */\n  minBandSize?: number;\n\n  /**\n   * The default max value for mapping quantitative fields to text's size/fontSize.\n   * If undefined (default), we will use bandSize - 1.\n   * @minimum 0\n   */\n  maxFontSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false\n   * @minimum 0\n   */\n  minFontSize?: number;\n\n  /**\n   * Default minimum opacity for mapping a field to opacity.\n   * @minimum 0\n   * @maximum 1\n   */\n  minOpacity?: number;\n\n  /**\n   * Default max opacity for mapping a field to opacity.\n   * @minimum 0\n   * @maximum 1\n   */\n  maxOpacity?: number;\n\n\n  /**\n   * Default minimum value for point size scale with zero=false.\n   * @minimum 0\n   */\n  minSize?: number;\n\n  /**\n   * Default max value for point size scale.\n   * @minimum 0\n   */\n  maxSize?: number;\n\n  /**\n   * Default minimum strokeWidth for strokeWidth (or rule/line's size) scale with zero=false.\n   * @minimum 0\n   */\n  minStrokeWidth?: number;\n\n  /**\n   * Default max strokeWidth for strokeWidth  (or rule/line's size) scale.\n   * @minimum 0\n   */\n  maxStrokeWidth?: number;\n\n  /**\n   * The default collection of symbol shapes for mapping nominal fields to shapes of point marks (i.e., range of a `shape` scale).\n   * Each value should be one of: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   */\n  shapes?: string[];\n}\n\nexport const defaultScaleConfig = {\n  round: true,\n  textXRangeStep: 90,\n  rangeStep: 21,\n  pointPadding: 0.5,\n  bandPaddingInner: 0.1,\n  facetSpacing: 16,\n\n  minFontSize: 8,\n  maxFontSize: 40,\n\n  minOpacity: 0.3,\n  maxOpacity: 0.8,\n\n  // FIXME: revise if these *can* become ratios of rangeStep\n  minSize: 9, // Point size is area. For square point, 9 = 3 pixel ^ 2, not too small!\n\n  minStrokeWidth: 1,\n  maxStrokeWidth: 4,\n\n  shapes: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down']\n};\n\nexport interface ExtendedScheme {\n  /**\n   * Color scheme that determines output color of an ordinal/sequential color scale.\n   */\n  name: string;\n\n  // TODO: add docs\n  extent?: number[];\n\n  // TODO: add docs\n  count?: number;\n}\n\nexport type Domain = number[] | string[] | DateTime[] | 'unaggregated';\nexport type Scheme = string | ExtendedScheme;\n\nexport type Range = number[] | string[] | string;\n\nexport function isExtendedScheme(scheme: string | ExtendedScheme): scheme is ExtendedScheme {\n  return scheme && !!scheme['name'];\n}\n\nexport interface Scale {\n  type?: ScaleType;\n  /**\n   * The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values.\n   *\n   * If the domain is 'unaggregated', we use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  domain?: Domain;\n\n  /**\n   * The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain.\n   */\n  range?: Range;\n\n  /**\n   * If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n   *\n   * __Default Rule:__ `true` for `\"x\"`, `\"y\"`, `\"row\"`, `\"column\"` channels if scale config's `round` is `true`; `false` otherwise.\n   */\n  round?: boolean;\n\n  // ordinal\n  /**\n   * The distance between the starts of adjacent bands or points in band or point scales.\n   * If this value is `null`, this will be determined to fit width (for x) or height (for y) of the plot.\n   * If both width and x-scale's rangeStep is provided, rangeStep will be dropped.  (The same rule is applied for height and y-scale's rangeStep.)\n   *\n   * __Default Rule:__ for `x` ordinal scale of a `text` mark, derived from [scale config](config.html#scale-config)'s `textXRangeStep`. Otherwise, derived from [scale config](config.html#scale-config)'s `rangeStep`.\n   * __Warning:__ If the cardinality of the scale domain is too high, the rangeStep might become less than one pixel and the mark might not appear correctly.\n   * @minimum 0\n   * @nullable\n   */\n  rangeStep?: number | null;\n\n  /**\n   * Range scheme (e.g., color schemes such as \"category10\" or \"viridis\").\n   */\n  scheme?: Scheme;\n\n  /**\n   * (For `row` and `column` only) A pixel value for padding between cells in the trellis plots.\n   * @TJS-type integer\n   */\n  spacing?: number;\n\n  /**\n   * Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the band size will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).\n   * A convenience property for setting the inner and outer padding to the same value.\n   * @minimum 0\n   * @maximum 1\n   */\n  padding?: number;\n\n  /**\n   * The inner padding of a band scale determines the ratio of the range that is reserved for blank space between bands. (For point scale, this property is ignored.)\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingInner?: number;\n\n  /**\n   * The outer padding determines the ratio of the range that is reserved for blank space before the first and after the last bands/points.\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingOuter?: number;\n\n  // typical\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   * If specified, modifies the scale domain to use a more human-friendly value range. If specified as a true boolean, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96). If specified as a string, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval.\n   */\n  nice?: boolean | NiceTime;\n  /**\n   * Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.\n   */\n  exponent?: number;\n  /**\n   * If `true`, ensures that a zero baseline value is included in the scale domain.\n   * Default value: `true` for `x` and `y` channel if the quantitative field is not binned\n   * and no custom `domain` is provided; `false` otherwise.\n   */\n  zero?: boolean;\n\n  // FIXME: Add description\n  interpolate?: 'rgb'| 'lab' | 'hcl' | 'hsl' | 'hsl-long' | 'hcl-long' | 'cubehelix' | 'cubehelix-long';\n}\n\nexport const SCALE_PROPERTIES:(keyof Scale)[]= [\n  'type', 'domain', 'range', 'round', 'rangeStep', 'scheme', 'padding', 'paddingInner', 'paddingOuter', 'clamp', 'nice',\n  'exponent', 'zero', 'interpolate'\n];\n\nexport function scaleTypeSupportProperty(scaleType: ScaleType, propName: keyof Scale) {\n  switch (propName) {\n    case 'type':\n    case 'domain':\n    case 'range':\n    case 'scheme':\n      return true;\n    case 'interpolate':\n      return scaleType === 'linear' || scaleType === 'bin-linear';\n    case 'round':\n      return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n    case 'rangeStep':\n    case 'padding':\n    case 'paddingOuter':\n      return contains(['point', 'band'], scaleType);\n    case 'paddingInner':\n      return scaleType === 'band';\n    case 'clamp':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential';\n    case 'nice':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || scaleType as any === 'quantize';\n    case 'exponent':\n      return scaleType === 'pow' || scaleType === 'log';\n    case 'zero':\n      // TODO: what about quantize, threshold?\n      return scaleType === 'bin-ordinal' || (!hasDiscreteDomain(scaleType) && !contains(['log', 'time', 'utc', 'bin-linear'], scaleType));\n  }\n  /* istanbul ignore next: should never reach here*/\n  throw new Error(`Invalid scale property ${propName}.`);\n}\n\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nexport function channelScalePropertyIncompatability(channel: Channel, propName: keyof Scale): string {\n  switch (propName) {\n    case 'range':\n      // User should not customize range for position and facet channel directly.\n      if (channel === 'x' || channel === 'y') {\n        return log.message.CANNOT_USE_RANGE_WITH_POSITION;\n      }\n      if (channel === 'row' || channel === 'column') {\n        return log.message.cannotUseRangePropertyWithFacet('range');\n      }\n      return undefined; // GOOD!\n    // band / point\n    case 'rangeStep':\n      if (channel === 'row' || channel === 'column') {\n        return log.message.cannotUseRangePropertyWithFacet('rangeStep');\n      }\n      return undefined; // GOOD!\n    case 'padding':\n    case 'paddingInner':\n    case 'paddingOuter':\n      if (channel === 'row' || channel === 'column') {\n        /*\n         * We do not use d3 scale's padding for row/column because padding there\n         * is a ratio ([0, 1]) and it causes the padding to be decimals.\n         * Therefore, we manually calculate \"spacing\" in the layout by ourselves.\n         */\n        return log.message.CANNOT_USE_PADDING_WITH_FACET;\n      }\n      return undefined; // GOOD!\n    case 'interpolate':\n    case 'scheme':\n      if (channel !== 'color') {\n        return log.message.cannotUseScalePropertyWithNonColor(channel);\n      }\n      return undefined;\n    case 'type':\n    case 'domain':\n    case 'round':\n    case 'clamp':\n    case 'exponent':\n    case 'nice':\n    case 'zero':\n      // These channel do not have strict requirement\n      return undefined; // GOOD!\n  }\n  /* istanbul ignore next: it should never reach here */\n  throw new Error('Invalid scale property \"${propName}\".');\n}\n","import {VgBinding} from './vega.schema';\n\nexport type SelectionTypes = 'single' | 'multi' | 'interval';\nexport type SelectionDomain = 'data' | 'visual';\nexport type SelectionResolutions = 'single' | 'independent' | 'union' |\n  'union_others' | 'intersect' | 'intersect_others';\n\nexport interface BaseSelectionDef {\n  // domain?: SelectionDomain;\n  on?: any;\n  // predicate?: string;\n  bind?: 'scales' | VgBinding | {[key: string]: VgBinding};\n\n  // Transforms\n  fields?: string[];\n  encodings?: string[];\n  toggle?: string | boolean;\n  translate?: string | boolean;\n  zoom?: string | boolean;\n  nearest?: boolean;\n}\n\nexport interface SelectionDef extends BaseSelectionDef {\n  type: SelectionTypes;\n}\n\nexport interface SelectionConfig {\n  single: BaseSelectionDef;\n  multi: BaseSelectionDef;\n  interval: BaseSelectionDef;\n}\n\nexport const defaultConfig:SelectionConfig = {\n  single: {on: 'click', fields: ['_id']},\n  multi: {on: 'click', fields: ['_id'], toggle: 'event.shiftKey'},\n  interval: {\n    on: '[mousedown, window:mouseup] > window:mousemove!',\n    encodings: ['x', 'y'],\n    translate: '[mousedown, window:mouseup] > window:mousemove!',\n    zoom: 'wheel'\n  }\n};\n","import {AggregateOp} from './aggregate';\n\nexport type SortOrder = 'ascending' | 'descending' | null;\n\nexport interface SortField {\n  /**\n   * The field name to aggregate over.\n   */\n  field: string;\n  /**\n   * The sort aggregation operator\n   */\n  op: AggregateOp;\n\n  order?: SortOrder;\n}\n\nexport function isSortField(sort: SortOrder | SortField): sort is SortField {\n  return !!sort && !!sort['field'] && !!sort['op'];\n}\n","/* Package of defining Vega-lite Specification's json schema at its utility functions */\n\nimport {Config, defaultOverlayConfig} from './config';\nimport * as compositeMark from './compositemark';\nimport {Data} from './data';\nimport {EncodingWithFacet, Encoding, channelHasField, isRanged} from './encoding';\nimport {Facet} from './facet';\nimport {FieldDef} from './fielddef';\n\nimport * as log from './log';\nimport {Mark, MarkDef, AREA, LINE, POINT, isPrimitiveMark} from './mark';\nimport {stack} from './stack';\nimport {Transform} from './transform';\nimport {ROW, COLUMN, X, Y, X2, Y2} from './channel';\nimport * as vlEncoding from './encoding';\nimport {contains, duplicate, extend, hash, keys, omit, pick, vals} from './util';\nimport {SelectionDef} from './selection';\n\nexport type Padding = number | {top?: number, bottom?: number, left?: number, right?: number};\n\nexport interface BaseSpec {\n  /**\n   * URL to JSON schema for this Vega-Lite specification.\n   * @format uri\n   */\n  $schema?: string;\n\n  /**\n   * Name of the visualization for later reference.\n   */\n  name?: string;\n\n  /**\n   * An optional description of this mark for commenting purpose.\n   * This property has no effect on the output visualization.\n   */\n  description?: string;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. This can be a single number or an object with `\"top\"`, `\"left\"`, `\"right\"`, `\"bottom\"` properties.\n   *\n   * __Default value__: `5`\n   *\n   * @minimum 0\n   */\n  padding?: Padding;\n\n  /**\n   * An object describing the data source\n   */\n  data?: Data;\n\n  /**\n   * An object describing filter and new field calculation.\n   */\n  transform?: Transform;\n\n  /**\n   * Configuration object\n   */\n  config?: Config;\n}\n\nexport interface GenericUnitSpec<M, E extends Encoding> extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  mark: M;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding: E;\n\n  /**\n   * A key-value mapping between selection names and definitions.\n   */\n  selection?: {[name: string]: SelectionDef};\n}\n\nexport type UnitSpec = GenericUnitSpec<Mark | MarkDef, Encoding>;\n\nexport type LayeredUnitSpec = GenericUnitSpec<string | MarkDef, Encoding>;\n\nexport type FacetedUnitSpec = GenericUnitSpec<string | MarkDef, EncodingWithFacet>;\n\nexport interface GenericLayerSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * Unit specs that will be layered.\n   */\n  // TODO: support layer of layer\n  layer: (GenericLayerSpec<U> | U)[];\n}\n\nexport type LayerSpec = GenericLayerSpec<UnitSpec>;\n\nexport interface GenericFacetSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec {\n  facet: Facet;\n\n  // TODO: support facet of facet\n  spec: GenericLayerSpec<U> | U;\n}\n\nexport type FacetSpec = GenericFacetSpec<UnitSpec>;\nexport type ExtendedFacetSpec = GenericFacetSpec<FacetedUnitSpec>;\n\nexport type GenericSpec<U extends GenericUnitSpec<any, any>> = U | GenericLayerSpec<U> | GenericFacetSpec<U>;\n\nexport type ExtendedSpec = GenericSpec<FacetedUnitSpec>;\n\nexport type Spec = GenericSpec<UnitSpec>;\n\n/* Custom type guards */\n\n\nexport function isFacetSpec(spec: GenericSpec<GenericUnitSpec<any, any>>): spec is GenericFacetSpec<GenericUnitSpec<any, any>> {\n  return spec['facet'] !== undefined;\n}\n\nexport function isFacetedUnitSpec(spec: ExtendedSpec): spec is FacetedUnitSpec {\n  if (isUnitSpec(spec)) {\n    const hasRow = channelHasField(spec.encoding, ROW);\n    const hasColumn = channelHasField(spec.encoding, COLUMN);\n\n    return hasRow || hasColumn;\n  }\n\n  return false;\n}\n\nexport function isUnitSpec(spec: ExtendedSpec | Spec): spec is FacetedUnitSpec | UnitSpec {\n  return !!spec['mark'];\n}\n\nexport function isLayerSpec(spec: ExtendedSpec | Spec): spec is GenericLayerSpec<GenericUnitSpec<any, Encoding>> {\n  return spec['layer'] !== undefined;\n}\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\n// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize\nexport function normalize(spec: ExtendedSpec): Spec {\n  if (isFacetSpec(spec)) {\n    return normalizeFacet(spec);\n  }\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec);\n  }\n  if (isFacetedUnitSpec(spec)) {\n    return normalizeFacetedUnit(spec);\n  }\n  if (isUnitSpec(spec)) {\n    return normalizeNonFacetUnit(spec);\n  }\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nfunction normalizeNonFacet(spec: GenericLayerSpec<LayeredUnitSpec> | LayeredUnitSpec) {\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec);\n  }\n  return normalizeNonFacetUnit(spec);\n}\n\nfunction normalizeFacet(spec: GenericFacetSpec<LayeredUnitSpec>): FacetSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    spec: normalizeNonFacet(subspec)\n  };\n}\n\nfunction normalizeLayer(spec: GenericLayerSpec<LayeredUnitSpec>): LayerSpec {\n  const {layer: layer, ...rest} = spec;\n  return {\n    ...rest,\n    layer: layer.map(normalizeNonFacet)\n  };\n}\n\nfunction normalizeFacetedUnit(spec: FacetedUnitSpec): FacetSpec {\n  // New encoding in the inside spec should not contain row / column\n  // as row/column should be moved to facet\n  const {row: row, column: column, ...encoding} = spec.encoding;\n\n  // Mark and encoding should be moved into the inner spec\n  const {mark: mark, encoding: _, ...outerSpec} = spec;\n\n  return {\n    ...outerSpec,\n    facet: {\n      ...(row ? {row} : {}),\n      ...(column ? {column}: {}),\n    },\n    spec: normalizeNonFacetUnit({\n      mark,\n      encoding\n    })\n  };\n}\n\nfunction isNonFacetUnitSpecWithPrimitiveMark(spec: GenericUnitSpec<string | MarkDef, Encoding>):\n  spec is GenericUnitSpec<Mark, Encoding> {\n    return isPrimitiveMark(spec.mark);\n}\n\nfunction normalizeNonFacetUnit(spec: GenericUnitSpec<string | MarkDef, Encoding>) {\n  const config = spec.config;\n  const overlayConfig = config && config.overlay;\n  const overlayWithLine = overlayConfig  && spec.mark === AREA &&\n    contains(['linepoint', 'line'], overlayConfig.area);\n  const overlayWithPoint = overlayConfig && (\n    (overlayConfig.line && spec.mark === LINE) ||\n    (overlayConfig.area === 'linepoint' && spec.mark === AREA)\n  );\n\n  if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {\n    // TODO: thoroughly test\n    if (isRanged(spec.encoding)) {\n      return normalizeRangedUnit(spec);\n    }\n\n    // TODO: consider moving this to become another case of compositeMark\n    if (overlayWithPoint || overlayWithLine) {\n      return normalizeOverlay(spec, overlayWithPoint, overlayWithLine);\n    }\n\n    return spec; // Nothing to normalize\n  } else {\n    return compositeMark.normalize(spec);\n  }\n}\n\nfunction normalizeRangedUnit(spec: UnitSpec) {\n  const hasX = channelHasField(spec.encoding, X);\n  const hasY = channelHasField(spec.encoding, Y);\n  const hasX2 = channelHasField(spec.encoding, X2);\n  const hasY2 = channelHasField(spec.encoding, Y2);\n  if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n    let normalizedSpec = duplicate(spec);\n    if (hasX2 && !hasX) {\n      normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n      delete normalizedSpec.encoding.x2;\n    }\n    if (hasY2 && !hasY) {\n      normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n      delete normalizedSpec.encoding.y2;\n    }\n\n    return normalizedSpec;\n  }\n  return spec;\n}\n\n\n// FIXME(#1804): rewrite this\nfunction normalizeOverlay(spec: UnitSpec, overlayWithPoint: boolean, overlayWithLine: boolean): LayerSpec {\n  let outerProps = ['name', 'description', 'data', 'transform'];\n  let baseSpec = omit(spec, outerProps.concat('config'));\n\n  let baseConfig = duplicate(spec.config);\n  delete baseConfig.overlay;\n  // TODO: remove shape, size\n\n  // Need to copy stack config to overlayed layer\n  const stacked = stack(spec.mark,\n    spec.encoding,\n    spec.config ? spec.config.stack : undefined\n  );\n\n  const layerSpec = {\n    ...pick(spec, outerProps),\n    layer: [baseSpec],\n    ...(keys(baseConfig).length > 0 ? {config: baseConfig} : {})\n  };\n\n  if (overlayWithLine) {\n    // TODO: add name with suffix\n    let lineSpec = duplicate(baseSpec);\n    lineSpec.mark = LINE;\n    // TODO: remove shape, size\n    let markConfig = extend({},\n      defaultOverlayConfig.lineStyle,\n      spec.config.overlay.lineStyle,\n      stacked ? {stacked: stacked.offset} : null\n    );\n    if (keys(markConfig).length > 0) {\n      lineSpec.config = {mark: markConfig};\n    }\n\n    layerSpec.layer.push(lineSpec);\n  }\n\n  if (overlayWithPoint) {\n    // TODO: add name with suffix\n    let pointSpec = duplicate(baseSpec);\n    pointSpec.mark = POINT;\n\n    let markConfig = extend({},\n      defaultOverlayConfig.pointStyle,\n      spec.config.overlay.pointStyle,\n      stacked ? {stacked: stacked.offset} : null\n    );\n    if (keys(markConfig).length > 0) {\n      pointSpec.config = {mark: markConfig};\n    }\n    layerSpec.layer.push(pointSpec);\n  }\n  return layerSpec;\n}\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\n/* Accumulate non-duplicate fieldDefs in a dictionary */\nfunction accumulate(dict: any, fieldDefs: FieldDef[]): any {\n  fieldDefs.forEach(function(fieldDef) {\n    // Consider only pure fieldDef properties (ignoring scale, axis, legend)\n    const pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce((f, key) => {\n      if (fieldDef[key] !== undefined) {\n        f[key] = fieldDef[key];\n      }\n      return f;\n    }, {});\n    let key = hash(pureFieldDef);\n    dict[key] = dict[key] || fieldDef;\n  });\n  return dict;\n}\n\n/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */\nfunction fieldDefIndex(spec: ExtendedSpec | ExtendedFacetSpec, dict: any = {}): any {\n  // TODO: Support repeat and concat\n  if (isLayerSpec(spec)) {\n    spec.layer.forEach(function(layer) {\n      if (isUnitSpec(layer)) {\n        accumulate(dict, vlEncoding.fieldDefs(layer.encoding));\n      } else {\n        fieldDefIndex(layer, dict);\n      }\n    });\n  } else if (isFacetSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.facet));\n    fieldDefIndex(spec.spec, dict);\n  } else { // Unit Spec\n    accumulate(dict, vlEncoding.fieldDefs(spec.encoding));\n  }\n  return dict;\n}\n\n/* Returns all non-duplicate fieldDefs in a spec in a flat array */\nexport function fieldDefs(spec: ExtendedSpec | ExtendedFacetSpec): FieldDef[] {\n  return vals(fieldDefIndex(spec));\n};\n\nexport function isStacked(spec: FacetedUnitSpec): boolean {\n  if (isPrimitiveMark(spec.mark)) {\n    return stack(spec.mark, spec.encoding,\n            spec.config ? spec.config.stack : undefined\n          ) !== null;\n  }\n  return false;\n}\n","import * as log from './log';\n\nimport {SUM_OPS} from './aggregate';\nimport {Channel, STACK_GROUP_CHANNELS, X, Y, X2, Y2} from './channel';\nimport {Encoding, channelHasField, isAggregate} from './encoding';\nimport {FieldDef, PositionFieldDef, isFieldDef} from './fielddef';\nimport {Mark, BAR, AREA, POINT, CIRCLE, SQUARE, LINE, RULE, TEXT, TICK, MarkDef, isMarkDef} from './mark';\nimport {ScaleType} from './scale';\nimport {contains, isArray} from './util';\n\n\n\nexport type StackOffset = 'zero' | 'center' | 'normalize' | 'none';\n\nexport interface StackProperties {\n  /** Dimension axis of the stack ('x' or 'y'). */\n  groupbyChannel: Channel;\n\n  /** Measure axis of the stack ('x' or 'y'). */\n  fieldChannel: Channel;\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: FieldDef,\n    channel: Channel\n  }[];\n\n  /**\n   * Modes for stacking marks:\n   * - `zero`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](mark.html#stacked-bar-chart) and [area](mark.html#stacked-area-chart) chart).\n   * - `normalize` - stacking with normalized domain (for creating normalized stacked [bar](mark.html#normalized-stacked-bar-chart) and [area](mark.html#normalized-stacked-area-chart) chart). <br/>\n   * -`center` - stacking with center baseline (for [streamgraph](mark.html#streamgraph)).\n   * - `none` - No-stacking. This will produce layered [bar](mark.html#layered-bar-chart) and area chart.\n   *\n   * __Default value:__ `zero` for plots with all of the following conditions: (1) `bar` or `area` marks (2) `color`, `opacity`, `size`, or `detail` channel mapped to a group-by field (3) One ordinal or nominal axis, and (4) one quantitative axis with linear scale and summative aggregation function (e.g., `sum`, `count`).\n   */\n  offset: StackOffset;\n}\n\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\n// Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\n\nexport function stack(m: Mark | MarkDef, encoding: Encoding, stackConfig: StackOffset): StackProperties {\n  const mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  // Should be aggregate plot\n  if (!isAggregate(encoding)) {\n    return null;\n  }\n\n  // Should have grouping level of detail\n  const stackBy = STACK_GROUP_CHANNELS.reduce((sc, channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n        if (isFieldDef(fieldDef) && !fieldDef.aggregate) {\n          sc.push({\n            channel: channel,\n            fieldDef: fieldDef\n          });\n        }\n      });\n    }\n    return sc;\n  }, []);\n\n  if (stackBy.length === 0) {\n    return null;\n  }\n\n  // Has only one aggregate axis\n  const hasXField = isFieldDef(encoding.x);\n  const hasYField = isFieldDef(encoding.y);\n  const xIsAggregate = isFieldDef(encoding.x) && !!encoding.x.aggregate;\n  const yIsAggregate = isFieldDef(encoding.y) && !!encoding.y.aggregate;\n\n  if (xIsAggregate !== yIsAggregate) {\n    const fieldChannel = xIsAggregate ? X : Y;\n    const fieldDef = encoding[fieldChannel] as PositionFieldDef;\n    const fieldChannelAggregate = fieldDef.aggregate;\n    const fieldChannelScale = fieldDef.scale;\n\n    let stackOffset: StackOffset = null;\n    if (fieldDef.stack !== undefined) {\n      stackOffset = fieldDef.stack;\n    } else if (contains(STACK_BY_DEFAULT_MARKS, mark)) {\n      // Bar and Area with sum ops are automatically stacked by default\n      stackOffset = stackConfig === undefined ? 'zero' : stackConfig;\n    } else {\n      stackOffset = stackConfig;\n    }\n\n    if (!stackOffset || stackOffset === 'none') {\n      return null;\n    }\n\n    // If stacked, check if it qualifies for stacking (and log warning if not qualified.)\n    if (fieldChannelScale && fieldChannelScale.type && fieldChannelScale.type !== ScaleType.LINEAR) {\n      log.warn(log.message.cannotStackNonLinearScale(fieldChannelScale.type));\n      return null;\n    }\n\n    if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n      return null;\n    }\n\n    if (!contains(SUM_OPS, fieldChannelAggregate)) {\n      log.warn(log.message.cannotStackNonSummativeAggregate(fieldChannelAggregate));\n      return null;\n    }\n\n    return {\n      groupbyChannel: xIsAggregate ? (hasYField ? Y : null) : (hasXField ? X : null),\n      fieldChannel: fieldChannel,\n      stackBy: stackBy,\n      offset: stackOffset\n    };\n  }\n  return null;\n}\n","import {DateTimeExpr, dateTimeExpr} from './datetime';\nimport {Dict, keys} from './util';\nimport * as log from './log';\n\nexport namespace TimeUnit {\n  export const YEAR: 'year' = 'year';\n  export const MONTH: 'month' = 'month';\n  export const DAY: 'day' = 'day';\n  export const DATE: 'date' = 'date';\n  export const HOURS: 'hours' = 'hours';\n  export const MINUTES: 'minutes' = 'minutes';\n  export const SECONDS: 'seconds' = 'seconds';\n  export const MILLISECONDS: 'milliseconds' = 'milliseconds';\n  export const YEARMONTH: 'yearmonth' = 'yearmonth';\n  export const YEARMONTHDATE: 'yearmonthdate' = 'yearmonthdate';\n  export const YEARMONTHDATEHOURS: 'yearmonthdatehours' = 'yearmonthdatehours';\n  export const YEARMONTHDATEHOURSMINUTES: 'yearmonthdatehoursminutes' = 'yearmonthdatehoursminutes';\n  export const YEARMONTHDATEHOURSMINUTESSECONDS: 'yearmonthdatehoursminutesseconds' = 'yearmonthdatehoursminutesseconds';\n\n  // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n  export const MONTHDATE: 'monthdate' = 'monthdate';\n  export const HOURSMINUTES: 'hoursminutes' = 'hoursminutes';\n  export const HOURSMINUTESSECONDS: 'hoursminutesseconds' = 'hoursminutesseconds';\n  export const MINUTESSECONDS: 'minutesseconds' = 'minutesseconds';\n  export const SECONDSMILLISECONDS: 'secondsmilliseconds' = 'secondsmilliseconds';\n  export const QUARTER: 'quarter' = 'quarter';\n  export const YEARQUARTER: 'yearquarter' = 'yearquarter';\n  export const QUARTERMONTH: 'quartermonth' = 'quartermonth';\n  export const YEARQUARTERMONTH: 'yearquartermonth' = 'yearquartermonth';\n}\n\nexport type TimeUnit = typeof TimeUnit.YEAR | typeof TimeUnit.MONTH | typeof TimeUnit.DAY | typeof TimeUnit.DATE | typeof TimeUnit.HOURS\n  | typeof TimeUnit.MINUTES | typeof TimeUnit.SECONDS | typeof TimeUnit.MILLISECONDS | typeof TimeUnit.YEARMONTH\n  | typeof TimeUnit.YEARMONTHDATE | typeof TimeUnit.YEARMONTHDATEHOURS | typeof TimeUnit.YEARMONTHDATEHOURSMINUTES\n  | typeof TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS | typeof TimeUnit.MONTHDATE | typeof TimeUnit.HOURSMINUTES\n  | typeof TimeUnit.HOURSMINUTESSECONDS | typeof TimeUnit.MINUTESSECONDS | typeof TimeUnit.SECONDSMILLISECONDS\n  | typeof TimeUnit.QUARTER | typeof TimeUnit.YEARQUARTER | typeof TimeUnit.QUARTERMONTH | typeof TimeUnit.YEARQUARTERMONTH;\n\n/** Time Unit that only corresponds to only one part of Date objects. */\nexport const SINGLE_TIMEUNITS = [\n  TimeUnit.YEAR,\n  TimeUnit.QUARTER,\n  TimeUnit.MONTH,\n  TimeUnit.DAY,\n  TimeUnit.DATE,\n  TimeUnit.HOURS,\n  TimeUnit.MINUTES,\n  TimeUnit.SECONDS,\n  TimeUnit.MILLISECONDS,\n];\n\nconst SINGLE_TIMEUNIT_INDEX: Dict<boolean> = SINGLE_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {});\n\nexport function isSingleTimeUnit(timeUnit: TimeUnit) {\n  return !!SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\n\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nexport function convert(unit: TimeUnit, date: Date): Date {\n  const result: Date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n  SINGLE_TIMEUNITS.forEach(function(singleUnit) {\n    if (containsTimeUnit(unit, singleUnit)) {\n      switch (singleUnit) {\n        case TimeUnit.DAY:\n          throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\n        case TimeUnit.YEAR:\n          result.setFullYear(date.getFullYear());\n          break;\n        case TimeUnit.QUARTER:\n          // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n          result.setMonth((Math.floor(date.getMonth() / 3)) * 3);\n          break;\n        case TimeUnit.MONTH:\n          result.setMonth(date.getMonth());\n          break;\n        case TimeUnit.DATE:\n          result.setDate(date.getDate());\n          break;\n        case TimeUnit.HOURS:\n          result.setHours(date.getHours());\n          break;\n        case TimeUnit.MINUTES:\n          result.setMinutes(date.getMinutes());\n          break;\n        case TimeUnit.SECONDS:\n          result.setSeconds(date.getSeconds());\n          break;\n        case TimeUnit.MILLISECONDS:\n          result.setMilliseconds(date.getMilliseconds());\n          break;\n      }\n    }\n  });\n\n  return result;\n}\n\nexport const MULTI_TIMEUNITS = [\n  TimeUnit.YEARQUARTER,\n  TimeUnit.YEARQUARTERMONTH,\n  TimeUnit.YEARMONTH,\n  TimeUnit.YEARMONTHDATE,\n  TimeUnit.YEARMONTHDATEHOURS,\n  TimeUnit.YEARMONTHDATEHOURSMINUTES,\n  TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n  TimeUnit.QUARTERMONTH,\n  TimeUnit.HOURSMINUTES,\n  TimeUnit.HOURSMINUTESSECONDS,\n  TimeUnit.MINUTESSECONDS,\n  TimeUnit.SECONDSMILLISECONDS,\n];\n\nconst MULTI_TIMEUNIT_INDEX: Dict<boolean> = MULTI_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {});\n\nexport function isMultiTimeUnit(timeUnit: TimeUnit) {\n  return !!MULTI_TIMEUNIT_INDEX[timeUnit];\n}\n\nexport const TIMEUNITS = [\n  TimeUnit.YEAR,\n  TimeUnit.QUARTER,\n  TimeUnit.MONTH,\n  TimeUnit.DAY,\n  TimeUnit.DATE,\n  TimeUnit.HOURS,\n  TimeUnit.MINUTES,\n  TimeUnit.SECONDS,\n  TimeUnit.MILLISECONDS,\n  TimeUnit.YEARQUARTER,\n  TimeUnit.YEARQUARTERMONTH,\n  TimeUnit.YEARMONTH,\n  TimeUnit.YEARMONTHDATE,\n  TimeUnit.YEARMONTHDATEHOURS,\n  TimeUnit.YEARMONTHDATEHOURSMINUTES,\n  TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n  TimeUnit.QUARTERMONTH,\n  TimeUnit.HOURSMINUTES,\n  TimeUnit.HOURSMINUTESSECONDS,\n  TimeUnit.MINUTESSECONDS,\n  TimeUnit.SECONDSMILLISECONDS\n];\n\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nexport function containsTimeUnit(fullTimeUnit: TimeUnit, timeUnit: TimeUnit) {\n  const index = fullTimeUnit.indexOf(timeUnit);\n  return index > -1 &&\n    (\n      timeUnit !== TimeUnit.SECONDS ||\n      index === 0 ||\n      fullTimeUnit.charAt(index-1) !== 'i' // exclude milliseconds\n    );\n}\n\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nexport function fieldExpr(fullTimeUnit: TimeUnit, field: string): string {\n  const fieldRef =  `datum[\"${field}\"]`;\n\n  function func(timeUnit: TimeUnit) {\n    if (timeUnit === TimeUnit.QUARTER) {\n      // quarter starting at 0 (0,3,6,9).\n      return `(quarter(${fieldRef})-1)`;\n    } else {\n      return `${timeUnit}(${fieldRef})`;\n    }\n  }\n\n  let d = SINGLE_TIMEUNITS.reduce((_d: DateTimeExpr, tu: TimeUnit) => {\n    if (containsTimeUnit(fullTimeUnit, tu)) {\n      _d[tu] = func(tu);\n    }\n    return _d;\n  }, {});\n\n  if (d.day && keys(d).length > 1) {\n    log.warn(log.message.dayReplacedWithDate(fullTimeUnit));\n    delete d.day;\n    d.date = func(TimeUnit.DATE);\n  }\n\n  return dateTimeExpr(d);\n}\n\n/** returns the smallest nice unit for scale.nice */\nexport function smallestUnit(timeUnit: TimeUnit): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    return 'second';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    return 'minute';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    return 'hour';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n      containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    return 'day';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    return 'month';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n    return 'year';\n  }\n  return undefined;\n}\n\n/** returns the signal expression used for axis labels for a time unit */\nexport function formatExpression(timeUnit: TimeUnit, field: string, shortTimeLabels: boolean): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  let dateComponents: string[] = [];\n  let expression = '';\n  const hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);\n\n  if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n   // special expression for quarter as prefix\n    expression = `'Q' + quarter(${field})`;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    // By default use short month name\n    dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n    dateComponents.push(shortTimeLabels ? '%a' : '%A');\n  } else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year\n  }\n\n  if (hasYear) {\n    dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n  }\n\n  let timeComponents: string[] = [];\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    timeComponents.push('%H');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    timeComponents.push('%M');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    timeComponents.push('%S');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n    timeComponents.push('%L');\n  }\n\n  let dateTimeComponents: string[] = [];\n  if (dateComponents.length > 0) {\n    dateTimeComponents.push(dateComponents.join(' '));\n  }\n  if (timeComponents.length > 0) {\n    dateTimeComponents.push(timeComponents.join(':'));\n  }\n\n  if (dateTimeComponents.length > 0) {\n    if (expression) {\n      // Add space between quarter and main time format\n      expression += ` + ' ' + `;\n    }\n    expression += `timeFormat(${field}, '${dateTimeComponents.join(' ')}')`;\n  }\n\n  // If expression is still an empty string, return undefined instead.\n  return expression || undefined;\n}\n\nexport function isDiscreteByDefault(timeUnit: TimeUnit) {\n  switch (timeUnit) {\n    // These time unit use discrete scale by default\n    case 'hours':\n    case 'day':\n    case 'month':\n    case 'quarter':\n      return true;\n  }\n  return false;\n}\n","/** Constants and utilities for data type */\n/** Data type based on level of measurement */\n\nexport namespace Type {\n  export const QUANTITATIVE: 'quantitative' = 'quantitative';\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const TEMPORAL: 'temporal' = 'temporal';\n  export const NOMINAL: 'nominal' = 'nominal';\n}\nexport type Type = typeof Type.QUANTITATIVE | typeof Type.ORDINAL | typeof Type.TEMPORAL | typeof Type.NOMINAL;\n\nexport const QUANTITATIVE = Type.QUANTITATIVE;\nexport const ORDINAL = Type.ORDINAL;\nexport const TEMPORAL = Type.TEMPORAL;\nexport const NOMINAL = Type.NOMINAL;\n\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nexport function getFullName(type: Type|string): Type {\n  if (type) {\n    type = type.toLowerCase();\n    switch (type) {\n      case 'q':\n      case QUANTITATIVE:\n        return 'quantitative';\n      case 't':\n      case TEMPORAL:\n        return 'temporal';\n      case 'o':\n      case ORDINAL:\n        return 'ordinal';\n      case 'n':\n      case NOMINAL:\n        return 'nominal';\n    }\n  }\n  // If we get invalid input, return undefined type.\n  return undefined;\n}\n","import * as stringify from 'json-stable-stringify';\nexport {extend, isArray, isObject, isNumber, isString, truncate, toSet, stringValue} from 'vega-util';\nimport {isNumber, isString, isArray} from 'vega-util';\n\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = {'a': 1, 'b': '2', 'c': 3};\n * pick(object, ['a', 'c']);\n * // → {'a': 1, 'c': 3}\n *\n */\nexport function pick(obj: any, props: string[]) {\n  const copy = {};\n  props.forEach((prop) => {\n    if (obj.hasOwnProperty(prop)) {\n      copy[prop] = obj[prop];\n    }\n  });\n  return copy;\n}\n\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nexport function omit(obj: any, props: string[]) {\n  const copy = duplicate(obj);\n  props.forEach((prop) => {\n    delete copy[prop];\n  });\n  return copy;\n}\n\nexport function hash(a: any) {\n  if (isString(a) || isNumber(a) || isBoolean(a)) {\n    return String(a);\n  }\n  return stringify(a);\n}\n\nexport function contains<T>(array: Array<T>, item: T) {\n  return array.indexOf(item) > -1;\n}\n\n/** Returns the array without the elements in item */\nexport function without<T>(array: Array<T>, excludedItems: Array<T>) {\n  return array.filter(item => !contains(excludedItems, item));\n}\n\nexport function union<T>(array: Array<T>, other: Array<T>) {\n  return array.concat(without(other, array));\n}\n\nexport function reduce(obj: any, f: (a: any, i: any, d: any, k: any, o: any) => any, init: any, thisArg?: any) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (const k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        init = f.call(thisArg, init, obj[k], k, obj);\n      }\n    }\n    return init;\n  }\n}\n\n/**\n * Returns true if any item returns true.\n */\nexport function some<T>(arr: Array<T>, f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if all items return true.\n */\n export function every<T>(arr: Array<T>, f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (!f(arr[k], k, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function flatten(arrays: any[]) {\n  return [].concat.apply([], arrays);\n}\n\n/**\n * recursively merges src into dest\n */\nexport function mergeDeep(dest: any, ...src: any[]) {\n  for (const s of src) {\n    dest = deepMerge_(dest, s);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction deepMerge_(dest: any, src: any) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (const p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || isArray(src[p]) || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      mergeDeep(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n\nexport function unique<T>(values: T[], f: (item: T) => string): T[] {\n  const results: any[] = [];\n  const u = {};\n  let v: string;\n  for (const val of values) {\n    v = f(val);\n    if (v in u) {\n      continue;\n    }\n    u[v] = 1;\n    results.push(val);\n  }\n  return results;\n};\n\nexport interface Dict<T> {\n  [key: string]: T;\n}\n\nexport type StringSet = Dict<boolean>;\n\n/**\n * Returns true if the two dictionaries disagree. Applies only to defined values.\n */\nexport function differ<T>(dict: Dict<T>, other: Dict<T>) {\n  for (const key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (other[key] && dict[key] && other[key] !== dict[key]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport const keys = Object.keys;\n\nexport function vals<T>(x: {[key: string]: T}): T[] {\n  const _vals: T[] = [];\n  for (const k in x) {\n    if (x.hasOwnProperty(k)) {\n      _vals.push(x[k]);\n    }\n  }\n  return _vals;\n};\n\nexport function duplicate<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nexport function isBoolean(b: any): b is boolean {\n  return b === true || b === false;\n}\n","import {FacetedUnitSpec} from './spec';\nimport {isMarkDef} from './mark';\n\n// TODO: move to vl.spec.validator?\n\nimport {toSet} from './util';\nimport {BAR} from './mark';\n\nexport interface RequiredChannelMap {\n  [mark: string]: Array<string>;\n}\n\n/**\n * Required Encoding Channels for each mark type\n * @type {Object}\n */\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\n  text: ['text'],\n  line: ['x', 'y'],\n  area: ['x', 'y']\n};\n\nexport interface SupportedChannelMap {\n  [mark: string]: {\n    [channel: string]: number\n  };\n}\n\n/**\n * Supported Encoding Channel for each mark type\n */\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\n  bar: toSet(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\n  line: toSet(['row', 'column', 'x', 'y', 'color', 'detail']), // TODO: add size when Vega supports\n  area: toSet(['row', 'column', 'x', 'y', 'color', 'detail']),\n  tick: toSet(['row', 'column', 'x', 'y', 'color', 'detail']),\n  circle: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  square: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  point: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\n  text: toSet(['row', 'column', 'size', 'color', 'text']) // TODO(#724) revise\n};\n\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nexport function getEncodingMappingError(spec: FacetedUnitSpec,\n  requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\n  supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\n  ) {\n  let mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n  let encoding = spec.encoding;\n  let requiredChannels = requiredChannelMap[mark];\n  let supportedChannels = supportedChannelMap[mark];\n\n  for (let i in requiredChannels) { // all required channels are in encoding`\n    if (!(requiredChannels[i] in encoding)) {\n      return 'Missing encoding channel \\\"' + requiredChannels[i] +\n        '\\\" for mark \\\"' + mark + '\\\"';\n    }\n  }\n\n  for (let channel in encoding) { // all channels in encoding are supported\n    if (!supportedChannels[channel]) {\n      return 'Encoding channel \\\"' + channel +\n        '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n    }\n  }\n\n  if (mark === BAR && !encoding.x && !encoding.y) {\n    return 'Missing both x and y for bar';\n  }\n\n  return null;\n}\n","import {StackOffset} from './stack';\nimport {ScaleType, NiceTime} from './scale';\nimport {isArray} from './util';\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: any;\n  url?: any;\n  transform?: any;\n}\n\n\nexport type VgParentRef = {\n  parent: string\n};\n\nexport type VgFieldRef = string | VgParentRef | VgParentRef[];\n\nexport type VgSortField = boolean | {\n  field: VgFieldRef,\n  op: string\n};\n\nexport type VgDataRef = {\n  data: string,\n  field: VgFieldRef,\n  sort?: VgSortField\n};\n\nexport type VgSignalRef = {\n  signal: string\n};\n\n// TODO: add type of value (Make it VgValueRef<T> {value?:T ...})\nexport type VgValueRef = {\n  value?: number | string | boolean,\n  field?: string | {\n    datum?: string,\n    group?: string,\n    parent?: string\n  },\n  signal?: string;\n  scale?: string, // TODO: object\n  mult?: number,\n  offset?: number | VgValueRef,\n  band?: boolean | number\n};\n\n// TODO: add vg prefix\nexport type DataRefUnionDomain = {\n  fields: (any[] | VgDataRef)[],\n  sort?: boolean | {\n    op: 'count'\n  }\n};\n\n// TODO: add vg prefix\nexport type FieldRefUnionDomain = {\n  data: string,\n  fields: VgFieldRef[],\n  sort?: boolean | {\n    op: 'count'\n  }\n};\n\nexport type VgRangeScheme = {scheme: string, extent?: number[], count?: number};\nexport type VgRange = string | VgDataRef | (number|string|VgDataRef)[] | VgRangeScheme | {step: number};\n\nexport type VgDomain = any[] | VgDataRef | DataRefUnionDomain | FieldRefUnionDomain | VgSignalRef;\n\nexport type VgScale = {\n  name: string,\n  type: ScaleType,\n  domain: VgDomain,\n  domainRaw?: VgSignalRef,\n  range: VgRange,\n\n  clamp?: boolean,\n  exponent?: number,\n  nice?: boolean | NiceTime,\n  padding?: number,\n  paddingInner?: number,\n  paddingOuter?: number,\n  reverse?: boolean,\n  round?: boolean,\n  zero?: boolean\n};\n\nexport function isDataRefUnionedDomain(domain: VgDomain): domain is DataRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n  return false;\n}\n\nexport function isFieldRefUnionDomain(domain: VgDomain): domain is FieldRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: VgDomain): domain is VgDataRef {\n  if (!isArray(domain)) {\n     return 'field' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isSignalRefDomain(domain: VgDomain): domain is VgSignalRef {\n  if (!isArray(domain)) {\n    return 'signal' in domain;\n  }\n  return false;\n}\n\nexport type VgEncodeEntry = any;\n// TODO: make export interface VgEncodeEntry {\n//   x?: VgValueRef<number>\n//   y?: VgValueRef<number>\n//  ...\n//   color?: VgValueRef<string>\n//  ...\n// }\n\nexport type VgAxis = any;\nexport type VgLegend = any;\n\nexport interface VgBinTransform {\n  type: 'bin';\n  field: string;\n  as: string;\n  extent?: {signal: string};\n  // TODO: add other properties\n}\n\nexport interface VgExtentTransform {\n  type: 'extent';\n  field: string;\n  signal: string;\n}\n\nexport interface VgFormulaTransform {\n  type: 'formula';\n  as: string;\n  expr: string;\n}\n\nexport interface VgAxisEncode {\n  ticks?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  title?: VgGuideEncode;\n  grid?: VgGuideEncode;\n  domain?: VgGuideEncode;\n}\n\nexport interface VgLegendEncode {\n  title?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  legend?: VgGuideEncode;\n  symbols?: VgGuideEncode;\n  gradient?: VgGuideEncode;\n}\n\nexport type VgGuideEncode = any; // TODO: replace this (See guideEncode in Vega Schema)\n\nexport type VgTransform = VgBinTransform | VgExtentTransform | VgFormulaTransform | any;\n\nexport interface VgStackTransform {\n  type: 'stack';\n  offset?: StackOffset;\n  groupby: string[];\n  field: string;\n  sort: VgSort;\n  as: string[];\n}\n\nexport type VgSort = {\n  field: string;\n  order: 'ascending' | 'descending';\n} | {\n  field: string[];\n  order: ('ascending' | 'descending')[];\n};\n\nexport interface VgImputeTransform {\n  type: 'impute';\n  groupby?: string[];\n  field: string;\n  orderby?: string[];\n  method?: 'value' | 'median' | 'max' | 'min' | 'mean';\n  value?: any;\n};\n\nexport type VgCheckboxBinding = {\n  input: 'checkbox';\n  element?: string;\n};\n\nexport type VgRadioBinding = {\n  input: 'radio';\n  options: string[];\n  element?: string;\n};\n\nexport type VgSelectBinding = {\n  input: 'select';\n  options: string[];\n  element?: string;\n};\n\nexport type VgRangeBinding = {\n  input: 'range';\n  min?: number;\n  max?: number;\n  step?: number;\n  element?: string;\n};\n\nexport type VgGenericBinding = {\n  input: string;\n  element?: string;\n};\n\nexport type VgBinding = VgCheckboxBinding | VgRadioBinding |\n  VgSelectBinding | VgRangeBinding | VgGenericBinding;\n\n\n/**\n * Base object for Vega's Axis and Axis Config.\n * All of these properties are both properties of Vega's Axis and Axis Config.\n */\nexport interface VgAxisBase {\n  /**\n   * A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis (default true).\n   */\n  domain?: boolean;\n\n  /**\n   * A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.\n   */\n  grid?: boolean;\n\n  /**\n   * A boolean flag indicating if labels should be included as part of the axis (default true).\n   */\n  labels?: boolean;\n\n  /**\n   * The rotation angle of the axis labels.\n   * @minimum 0\n   * @maximum 360\n   */\n  labelAngle?: number;\n\n  /**\n   * Whether the axis should include ticks.\n   */\n  ticks?: boolean;\n\n  /**\n   * The size, in pixels, of major, minor and end ticks.\n   * @minimum 0\n   */\n  tickSize?: number;\n\n  /**\n   * Max length for axis title if the title is automatically generated from the field's description. By default, this is automatically based on cell size and characterWidth property.\n   * @minimum 0\n   * @TJS-type integer\n   */\n  titleMaxLength?: number;\n\n  /**\n   * The padding, in pixels, between title and axis.\n   */\n  titlePadding?: number;\n\n  /**\n   * The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\n   */\n  minExtent?: number;\n\n  /**\n   * The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\n   */\n  maxExtent?: number;\n}\n\nexport interface VgAxisConfig extends VgAxisBase {\n // ---------- Axis ----------\n  /**\n   * Stroke width of axis domain line\n   */\n  domainWidth?: number;\n\n  /**\n   * Color of axis domain line.\n   */\n  domainColor?: string;\n\n  // ---------- Grid ----------\n  /**\n   * Color of gridlines.\n   */\n  gridColor?: string;\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the grid dash array.\n   * @minimum 0\n   */\n  gridDash?: number[];\n\n  /**\n   * The stroke opacity of grid (value between [0,1])\n   * @minimum 0\n   * @maximum 1\n   */\n  gridOpacity?: number;\n\n  /**\n   * The grid width, in pixels.\n   * @minimum 0\n   */\n  gridWidth?: number;\n\n  // ---------- Ticks ----------\n  /**\n   * The color of the axis's tick.\n   */\n  tickColor?: string;\n\n  /**\n   * The color of the tick label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n\n  /**\n   * The font of the tick label.\n   */\n  labelFont?: string;\n\n  /**\n   * The font size of label, in pixels.\n   * @minimum 0\n   */\n  labelFontSize?: number;\n\n  /**\n   * The width, in pixels, of ticks.\n   * @minimum 0\n   */\n  tickWidth?: number;\n\n  // ---------- Title ----------\n  /**\n   * Color of the title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * Font of the title.\n   */\n  titleFont?: string;\n\n  /**\n   * Font size of the title.\n   * @minimum 0\n   */\n  titleFontSize?: number;\n\n  /**\n   * Font weight of the title.\n   */\n  titleFontWeight?: string | number;\n}\n\nexport interface VgLegendBase {\n  /**\n   * Padding (in pixels) between legend entries in a symbol legend.\n   */\n  entryPadding?: number;\n\n  /**\n   * The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".\n   */\n  orient?: string;\n\n  /**\n   * The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.\n   */\n  offset?: number;\n\n  /**\n   * The padding, in pixels, between the legend and axis.\n   */\n  padding?: number;\n}\n\nexport interface VgLegendConfig extends VgLegendBase {\n  // ---------- Gradient ----------\n  /**\n   * The color of the gradient stroke, can be in hex color code or regular color name.\n   */\n  gradientStrokeColor?: string;\n\n  /**\n   * The width of the gradient stroke, in pixels.\n   * @minimum 0\n   */\n  gradientStrokeWidth?: number;\n\n  /**\n   * The height of the gradient, in pixels.\n   * @minimum 0\n   */\n  gradientHeight?: number;\n\n  /**\n   * The width of the gradient, in pixels.\n   * @minimum 0\n   */\n  gradientWidth?: number;\n\n  // ---------- Label ----------\n  /**\n   * The alignment of the legend label, can be left, middle or right.\n   */\n  labelAlign?: string;\n\n  /**\n   * The position of the baseline of legend label, can be top, middle or bottom.\n   */\n  labelBaseline?: string;\n\n  /**\n   * The color of the legend label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n\n  /**\n   * The font of the legend label.\n   */\n  labelFont?: string;\n\n  /**\n   * The font size of legend label.\n   * @minimum 0\n   */\n  labelFontSize?: number;\n\n  /**\n   * The offset of the legend label.\n   * @minimum 0\n   */\n  labelOffset?: number;\n\n  // ---------- Symbols ----------\n  /**\n   * The color of the legend symbol,\n   */\n  symbolColor?: string;\n\n  /**\n   * Default shape type (such as \"circle\") for legend symbols.\n   */\n  symbolType?: string;\n\n  /**\n   * The size of the legend symbol, in pixels.\n   * @minimum 0\n   */\n  symbolSize?: number;\n\n  /**\n   * The width of the symbol's stroke.\n   * @minimum 0\n   */\n  symbolStrokeWidth?: number;\n\n  // ---------- Title ----------\n  /**\n   * Optional mark property definitions for custom legend styling.\n   */\n  /**\n   * The color of the legend title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * The font of the legend title.\n   */\n  titleFont?: string;\n\n  /**\n   * The font size of the legend title.\n   */\n  titleFontSize?: number;\n\n  /**\n   * The font weight of the legend title.\n   */\n  titleFontWeight?: string | number;\n\n  /**\n   * The padding, in pixels, between title and legend.\n   */\n  titlePadding?: number;\n}\n\nexport type FontStyle = 'normal' | 'italic';\nexport type FontWeight = 'normal' | 'bold';\n/**\n * @TJS-type integer\n * @minimum 100\n * @maximum 900\n */\nexport type FontWeightNumber = number;\nexport type HorizontalAlign = 'left' | 'right' | 'center';\nexport type Interpolate = 'linear' | 'linear-closed' |\n  'step' | 'step-before' | 'step-after' |\n  'basis' | 'basis-open' | 'basis-closed' |\n  'cardinal' | 'cardinal-open' | 'cardinal-closed' |\n  'bundle' | 'monotone';\nexport type Orient = 'horizontal' | 'vertical';\nexport type VerticalAlign = 'top' | 'middle' | 'bottom';\n\nexport interface VgMarkConfig {\n\n  /**\n   * Default Fill Color.  This has higher precedence than config.color\n   */\n  fill?: string;\n\n  /**\n   * Default Stroke Color.  This has higher precedence than config.color\n   */\n  stroke?: string;\n\n  // ---------- Opacity ----------\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  opacity?: number;\n\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  fillOpacity?: number;\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  strokeOpacity?: number;\n\n  // ---------- Stroke Style ----------\n  /**\n   * @minimum 0\n   */\n  strokeWidth?: number;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   */\n  strokeDashOffset?: number;\n\n  // ---------- Orientation: Bar, Tick, Line, Area ----------\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  // ---------- Interpolation: Line / area ----------\n  /**\n   * The line interpolation method to use for line and area marks. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n  /**\n   * Depending on the interpolation type, sets the tension parameter (for line and area marks).\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n\n  /**\n   * The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   */\n  shape?: string;\n\n  /**\n   * The pixel area each the point/circle/square.\n   * For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   * @minimum 0\n   */\n  size?: number;\n\n  // Text / Label Mark Config\n\n  /**\n   * The horizontal alignment of the text. One of left, right, center.\n   */\n  align?: HorizontalAlign;\n\n  /**\n   * The rotation angle of the text, in degrees.\n   * @minimum 0\n   * @maximum 360\n   */\n  angle?: number;\n\n  /**\n   * The vertical alignment of the text. One of top, middle, bottom.\n   */\n  baseline?: VerticalAlign;\n\n  /**\n   * The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dx?: number;\n\n  /**\n   * The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dy?: number;\n\n  /**\n   * Polar coordinate radial offset, in pixels, of the text label from the origin determined by the x and y properties.\n   * @minimum 0\n   */\n  radius?: number;\n\n  /**\n   * Polar coordinate angle, in radians, of the text label from the origin determined by the x and y properties. Values for theta follow the same convention of arc mark startAngle and endAngle properties: angles are measured in radians, with 0 indicating \"north\".\n   */\n  theta?: number;\n\n  /**\n   * The typeface to set the text in (e.g., Helvetica Neue).\n   * @minimum 0\n   */\n  font?: string;\n\n  /**\n   * The font size, in pixels.\n   * @minimum 0\n   */\n  fontSize?: number;\n\n  /**\n   * The font style (e.g., italic).\n   */\n  fontStyle?: FontStyle;\n  /**\n   * The font weight (e.g., `\"normal\"`, `\"bold\"`, `900`).\n   */\n  fontWeight?: FontWeight | FontWeightNumber;\n\n  /**\n   * Placeholder Text\n   */\n  text?: string;\n}\n","export import axis = require('./axis');\nexport import aggregate = require('./aggregate');\nexport import bin = require('./bin');\nexport import channel = require('./channel');\nexport import compositeMark = require('./compositemark');\nexport {compile}  from './compile/compile';\nexport import config = require('./config');\nexport import data = require('./data');\nexport import datetime = require('./datetime');\nexport import encoding = require('./encoding');\nexport import facet = require('./facet');\nexport import fieldDef = require('./fielddef');\nexport import legend = require('./legend');\nexport import mark = require('./mark');\nexport import scale = require('./scale');\nexport import sort = require('./sort');\nexport import spec = require('./spec');\nexport import stack = require('./stack');\nexport import timeUnit = require('./timeunit');\nexport import transform = require('./transform');\nexport import type = require('./type');\nexport import util = require('./util');\nexport import validate = require('./validate');\n\nexport const version: string = require('../package.json').version;\n"]}